var cg = Object.defineProperty; var dg = (t, e, n) => e in t ? cg(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n; var z = (t, e, n) => (dg(t, typeof e != "symbol" ? e + "" : e, n), n); (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r); new MutationObserver(r => { for (const o of r) if (o.type === "childList") for (const s of o.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && i(s) }).observe(document, { childList: !0, subtree: !0 }); function n(r) { const o = {}; return r.integrity && (o.integrity = r.integrity), r.referrerPolicy && (o.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? o.credentials = "include" : r.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function i(r) { if (r.ep) return; r.ep = !0; const o = n(r); fetch(r.href, o) } })(); function jn(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var of = { exports: {} }, cs = {}, sf = { exports: {} }, B = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var br = Symbol.for("react.element"), fg = Symbol.for("react.portal"), hg = Symbol.for("react.fragment"), pg = Symbol.for("react.strict_mode"), gg = Symbol.for("react.profiler"), mg = Symbol.for("react.provider"), vg = Symbol.for("react.context"), yg = Symbol.for("react.forward_ref"), xg = Symbol.for("react.suspense"), _g = Symbol.for("react.memo"), wg = Symbol.for("react.lazy"), Du = Symbol.iterator; function kg(t) { return t === null || typeof t != "object" ? null : (t = Du && t[Du] || t["@@iterator"], typeof t == "function" ? t : null) } var lf = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, af = Object.assign, uf = {}; function vi(t, e, n) { this.props = t, this.context = e, this.refs = uf, this.updater = n || lf } vi.prototype.isReactComponent = {}; vi.prototype.setState = function (t, e) { if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, t, e, "setState") }; vi.prototype.forceUpdate = function (t) { this.updater.enqueueForceUpdate(this, t, "forceUpdate") }; function cf() { } cf.prototype = vi.prototype; function Ea(t, e, n) { this.props = t, this.context = e, this.refs = uf, this.updater = n || lf } var Ca = Ea.prototype = new cf; Ca.constructor = Ea; af(Ca, vi.prototype); Ca.isPureReactComponent = !0; var Nu = Array.isArray, df = Object.prototype.hasOwnProperty, Pa = { current: null }, ff = { key: !0, ref: !0, __self: !0, __source: !0 }; function hf(t, e, n) { var i, r = {}, o = null, s = null; if (e != null) for (i in e.ref !== void 0 && (s = e.ref), e.key !== void 0 && (o = "" + e.key), e) df.call(e, i) && !ff.hasOwnProperty(i) && (r[i] = e[i]); var l = arguments.length - 2; if (l === 1) r.children = n; else if (1 < l) { for (var a = Array(l), u = 0; u < l; u++)a[u] = arguments[u + 2]; r.children = a } if (t && t.defaultProps) for (i in l = t.defaultProps, l) r[i] === void 0 && (r[i] = l[i]); return { $$typeof: br, type: t, key: o, ref: s, props: r, _owner: Pa.current } } function bg(t, e) { return { $$typeof: br, type: t.type, key: e, ref: t.ref, props: t.props, _owner: t._owner } } function Oa(t) { return typeof t == "object" && t !== null && t.$$typeof === br } function Sg(t) { var e = { "=": "=0", ":": "=2" }; return "$" + t.replace(/[=:]/g, function (n) { return e[n] }) } var zu = /\/+/g; function Ms(t, e) { return typeof t == "object" && t !== null && t.key != null ? Sg("" + t.key) : e.toString(36) } function uo(t, e, n, i, r) { var o = typeof t; (o === "undefined" || o === "boolean") && (t = null); var s = !1; if (t === null) s = !0; else switch (o) { case "string": case "number": s = !0; break; case "object": switch (t.$$typeof) { case br: case fg: s = !0 } }if (s) return s = t, r = r(s), t = i === "" ? "." + Ms(s, 0) : i, Nu(r) ? (n = "", t != null && (n = t.replace(zu, "$&/") + "/"), uo(r, e, n, "", function (u) { return u })) : r != null && (Oa(r) && (r = bg(r, n + (!r.key || s && s.key === r.key ? "" : ("" + r.key).replace(zu, "$&/") + "/") + t)), e.push(r)), 1; if (s = 0, i = i === "" ? "." : i + ":", Nu(t)) for (var l = 0; l < t.length; l++) { o = t[l]; var a = i + Ms(o, l); s += uo(o, e, n, a, r) } else if (a = kg(t), typeof a == "function") for (t = a.call(t), l = 0; !(o = t.next()).done;)o = o.value, a = i + Ms(o, l++), s += uo(o, e, n, a, r); else if (o === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."); return s } function jr(t, e, n) { if (t == null) return t; var i = [], r = 0; return uo(t, i, "", "", function (o) { return e.call(n, o, r++) }), i } function Eg(t) { if (t._status === -1) { var e = t._result; e = e(), e.then(function (n) { (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n) }, function (n) { (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n) }), t._status === -1 && (t._status = 0, t._result = e) } if (t._status === 1) return t._result.default; throw t._result } var Re = { current: null }, co = { transition: null }, Cg = { ReactCurrentDispatcher: Re, ReactCurrentBatchConfig: co, ReactCurrentOwner: Pa }; B.Children = { map: jr, forEach: function (t, e, n) { jr(t, function () { e.apply(this, arguments) }, n) }, count: function (t) { var e = 0; return jr(t, function () { e++ }), e }, toArray: function (t) { return jr(t, function (e) { return e }) || [] }, only: function (t) { if (!Oa(t)) throw Error("React.Children.only expected to receive a single React element child."); return t } }; B.Component = vi; B.Fragment = hg; B.Profiler = gg; B.PureComponent = Ea; B.StrictMode = pg; B.Suspense = xg; B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Cg; B.cloneElement = function (t, e, n) { if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + "."); var i = af({}, t.props), r = t.key, o = t.ref, s = t._owner; if (e != null) { if (e.ref !== void 0 && (o = e.ref, s = Pa.current), e.key !== void 0 && (r = "" + e.key), t.type && t.type.defaultProps) var l = t.type.defaultProps; for (a in e) df.call(e, a) && !ff.hasOwnProperty(a) && (i[a] = e[a] === void 0 && l !== void 0 ? l[a] : e[a]) } var a = arguments.length - 2; if (a === 1) i.children = n; else if (1 < a) { l = Array(a); for (var u = 0; u < a; u++)l[u] = arguments[u + 2]; i.children = l } return { $$typeof: br, type: t.type, key: r, ref: o, props: i, _owner: s } }; B.createContext = function (t) { return t = { $$typeof: vg, _currentValue: t, _currentValue2: t, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, t.Provider = { $$typeof: mg, _context: t }, t.Consumer = t }; B.createElement = hf; B.createFactory = function (t) { var e = hf.bind(null, t); return e.type = t, e }; B.createRef = function () { return { current: null } }; B.forwardRef = function (t) { return { $$typeof: yg, render: t } }; B.isValidElement = Oa; B.lazy = function (t) { return { $$typeof: wg, _payload: { _status: -1, _result: t }, _init: Eg } }; B.memo = function (t, e) { return { $$typeof: _g, type: t, compare: e === void 0 ? null : e } }; B.startTransition = function (t) { var e = co.transition; co.transition = {}; try { t() } finally { co.transition = e } }; B.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; B.useCallback = function (t, e) { return Re.current.useCallback(t, e) }; B.useContext = function (t) { return Re.current.useContext(t) }; B.useDebugValue = function () { }; B.useDeferredValue = function (t) { return Re.current.useDeferredValue(t) }; B.useEffect = function (t, e) { return Re.current.useEffect(t, e) }; B.useId = function () { return Re.current.useId() }; B.useImperativeHandle = function (t, e, n) { return Re.current.useImperativeHandle(t, e, n) }; B.useInsertionEffect = function (t, e) { return Re.current.useInsertionEffect(t, e) }; B.useLayoutEffect = function (t, e) { return Re.current.useLayoutEffect(t, e) }; B.useMemo = function (t, e) { return Re.current.useMemo(t, e) }; B.useReducer = function (t, e, n) { return Re.current.useReducer(t, e, n) }; B.useRef = function (t) { return Re.current.useRef(t) }; B.useState = function (t) { return Re.current.useState(t) }; B.useSyncExternalStore = function (t, e, n) { return Re.current.useSyncExternalStore(t, e, n) }; B.useTransition = function () { return Re.current.useTransition() }; B.version = "18.2.0"; sf.exports = B; var Oe = sf.exports; const kn = jn(Oe);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Pg = Oe, Og = Symbol.for("react.element"), Mg = Symbol.for("react.fragment"), Tg = Object.prototype.hasOwnProperty, Rg = Pg.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, Ag = { key: !0, ref: !0, __self: !0, __source: !0 }; function pf(t, e, n) { var i, r = {}, o = null, s = null; n !== void 0 && (o = "" + n), e.key !== void 0 && (o = "" + e.key), e.ref !== void 0 && (s = e.ref); for (i in e) Tg.call(e, i) && !Ag.hasOwnProperty(i) && (r[i] = e[i]); if (t && t.defaultProps) for (i in e = t.defaultProps, e) r[i] === void 0 && (r[i] = e[i]); return { $$typeof: Og, type: t, key: o, ref: s, props: r, _owner: Rg.current } } cs.Fragment = Mg; cs.jsx = pf; cs.jsxs = pf; of.exports = cs; var E = of.exports, ul = {}, gf = { exports: {} }, Qe = {}, mf = { exports: {} }, vf = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (t) { function e(R, j) { var N = R.length; R.push(j); e: for (; 0 < N;) { var V = N - 1 >>> 1, Q = R[V]; if (0 < r(Q, j)) R[V] = j, R[N] = Q, N = V; else break e } } function n(R) { return R.length === 0 ? null : R[0] } function i(R) { if (R.length === 0) return null; var j = R[0], N = R.pop(); if (N !== j) { R[0] = N; e: for (var V = 0, Q = R.length, Be = Q >>> 1; V < Be;) { var ke = 2 * (V + 1) - 1, kt = R[ke], He = ke + 1, Ar = R[He]; if (0 > r(kt, N)) He < Q && 0 > r(Ar, kt) ? (R[V] = Ar, R[He] = N, V = He) : (R[V] = kt, R[ke] = N, V = ke); else if (He < Q && 0 > r(Ar, N)) R[V] = Ar, R[He] = N, V = He; else break e } } return j } function r(R, j) { var N = R.sortIndex - j.sortIndex; return N !== 0 ? N : R.id - j.id } if (typeof performance == "object" && typeof performance.now == "function") { var o = performance; t.unstable_now = function () { return o.now() } } else { var s = Date, l = s.now(); t.unstable_now = function () { return s.now() - l } } var a = [], u = [], d = 1, f = null, c = 3, h = !1, g = !1, v = !1, _ = typeof setTimeout == "function" ? setTimeout : null, m = typeof clearTimeout == "function" ? clearTimeout : null, p = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function y(R) { for (var j = n(u); j !== null;) { if (j.callback === null) i(u); else if (j.startTime <= R) i(u), j.sortIndex = j.expirationTime, e(a, j); else break; j = n(u) } } function w(R) { if (v = !1, y(R), !g) if (n(a) !== null) g = !0, F(S); else { var j = n(u); j !== null && Y(w, j.startTime - R) } } function S(R, j) { g = !1, v && (v = !1, m(b), b = -1), h = !0; var N = c; try { for (y(j), f = n(a); f !== null && (!(f.expirationTime > j) || R && !M());) { var V = f.callback; if (typeof V == "function") { f.callback = null, c = f.priorityLevel; var Q = V(f.expirationTime <= j); j = t.unstable_now(), typeof Q == "function" ? f.callback = Q : f === n(a) && i(a), y(j) } else i(a); f = n(a) } if (f !== null) var Be = !0; else { var ke = n(u); ke !== null && Y(w, ke.startTime - j), Be = !1 } return Be } finally { f = null, c = N, h = !1 } } var x = !1, k = null, b = -1, C = 5, P = -1; function M() { return !(t.unstable_now() - P < C) } function T() { if (k !== null) { var R = t.unstable_now(); P = R; var j = !0; try { j = k(!0, R) } finally { j ? L() : (x = !1, k = null) } } else x = !1 } var L; if (typeof p == "function") L = function () { p(T) }; else if (typeof MessageChannel < "u") { var I = new MessageChannel, D = I.port2; I.port1.onmessage = T, L = function () { D.postMessage(null) } } else L = function () { _(T, 0) }; function F(R) { k = R, x || (x = !0, L()) } function Y(R, j) { b = _(function () { R(t.unstable_now()) }, j) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (R) { R.callback = null }, t.unstable_continueExecution = function () { g || h || (g = !0, F(S)) }, t.unstable_forceFrameRate = function (R) { 0 > R || 125 < R ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < R ? Math.floor(1e3 / R) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return c }, t.unstable_getFirstCallbackNode = function () { return n(a) }, t.unstable_next = function (R) { switch (c) { case 1: case 2: case 3: var j = 3; break; default: j = c }var N = c; c = j; try { return R() } finally { c = N } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (R, j) { switch (R) { case 1: case 2: case 3: case 4: case 5: break; default: R = 3 }var N = c; c = R; try { return j() } finally { c = N } }, t.unstable_scheduleCallback = function (R, j, N) { var V = t.unstable_now(); switch (typeof N == "object" && N !== null ? (N = N.delay, N = typeof N == "number" && 0 < N ? V + N : V) : N = V, R) { case 1: var Q = -1; break; case 2: Q = 250; break; case 5: Q = 1073741823; break; case 4: Q = 1e4; break; default: Q = 5e3 }return Q = N + Q, R = { id: d++, callback: j, priorityLevel: R, startTime: N, expirationTime: Q, sortIndex: -1 }, N > V ? (R.sortIndex = N, e(u, R), n(a) === null && R === n(u) && (v ? (m(b), b = -1) : v = !0, Y(w, N - V))) : (R.sortIndex = Q, e(a, R), g || h || (g = !0, F(S))), R }, t.unstable_shouldYield = M, t.unstable_wrapCallback = function (R) { var j = c; return function () { var N = c; c = j; try { return R.apply(this, arguments) } finally { c = N } } } })(vf); mf.exports = vf; var jg = mf.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var yf = Oe, Ye = jg; function O(t) { for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++)e += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var xf = new Set, nr = {}; function Ln(t, e) { ai(t, e), ai(t + "Capture", e) } function ai(t, e) { for (nr[t] = e, t = 0; t < e.length; t++)xf.add(e[t]) } var At = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), cl = Object.prototype.hasOwnProperty, Lg = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Iu = {}, Fu = {}; function Dg(t) { return cl.call(Fu, t) ? !0 : cl.call(Iu, t) ? !1 : Lg.test(t) ? Fu[t] = !0 : (Iu[t] = !0, !1) } function Ng(t, e, n, i) { if (n !== null && n.type === 0) return !1; switch (typeof e) { case "function": case "symbol": return !0; case "boolean": return i ? !1 : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-"); default: return !1 } } function zg(t, e, n, i) { if (e === null || typeof e > "u" || Ng(t, e, n, i)) return !0; if (i) return !1; if (n !== null) switch (n.type) { case 3: return !e; case 4: return e === !1; case 5: return isNaN(e); case 6: return isNaN(e) || 1 > e }return !1 } function Ae(t, e, n, i, r, o, s) { this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = i, this.attributeNamespace = r, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = o, this.removeEmptyString = s } var _e = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (t) { _e[t] = new Ae(t, 0, !1, t, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (t) { var e = t[0]; _e[e] = new Ae(e, 1, !1, t[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) { _e[t] = new Ae(t, 2, !1, t.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) { _e[t] = new Ae(t, 2, !1, t, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (t) { _e[t] = new Ae(t, 3, !1, t.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (t) { _e[t] = new Ae(t, 3, !0, t, null, !1, !1) });["capture", "download"].forEach(function (t) { _e[t] = new Ae(t, 4, !1, t, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (t) { _e[t] = new Ae(t, 6, !1, t, null, !1, !1) });["rowSpan", "start"].forEach(function (t) { _e[t] = new Ae(t, 5, !1, t.toLowerCase(), null, !1, !1) }); var Ma = /[\-:]([a-z])/g; function Ta(t) { return t[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (t) { var e = t.replace(Ma, Ta); _e[e] = new Ae(e, 1, !1, t, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (t) { var e = t.replace(Ma, Ta); _e[e] = new Ae(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (t) { var e = t.replace(Ma, Ta); _e[e] = new Ae(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (t) { _e[t] = new Ae(t, 1, !1, t.toLowerCase(), null, !1, !1) }); _e.xlinkHref = new Ae("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (t) { _e[t] = new Ae(t, 1, !1, t.toLowerCase(), null, !0, !0) }); function Ra(t, e, n, i) { var r = _e.hasOwnProperty(e) ? _e[e] : null; (r !== null ? r.type !== 0 : i || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (zg(e, n, r, i) && (n = null), i || r === null ? Dg(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : r.mustUseProperty ? t[r.propertyName] = n === null ? r.type === 3 ? !1 : "" : n : (e = r.attributeName, i = r.attributeNamespace, n === null ? t.removeAttribute(e) : (r = r.type, n = r === 3 || r === 4 && n === !0 ? "" : "" + n, i ? t.setAttributeNS(i, e, n) : t.setAttribute(e, n)))) } var Nt = yf.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Lr = Symbol.for("react.element"), Bn = Symbol.for("react.portal"), Hn = Symbol.for("react.fragment"), Aa = Symbol.for("react.strict_mode"), dl = Symbol.for("react.profiler"), _f = Symbol.for("react.provider"), wf = Symbol.for("react.context"), ja = Symbol.for("react.forward_ref"), fl = Symbol.for("react.suspense"), hl = Symbol.for("react.suspense_list"), La = Symbol.for("react.memo"), It = Symbol.for("react.lazy"), kf = Symbol.for("react.offscreen"), Bu = Symbol.iterator; function wi(t) { return t === null || typeof t != "object" ? null : (t = Bu && t[Bu] || t["@@iterator"], typeof t == "function" ? t : null) } var ie = Object.assign, Ts; function Di(t) {
  if (Ts === void 0) try { throw Error() } catch (n) { var e = n.stack.trim().match(/\n( *(at )?)/); Ts = e && e[1] || "" } return `
`+ Ts + t
} var Rs = !1; function As(t, e) {
  if (!t || Rs) return ""; Rs = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (e) if (e = function () { throw Error() }, Object.defineProperty(e.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(e, []) } catch (u) { var i = u } Reflect.construct(t, [], e) } else { try { e.call() } catch (u) { i = u } t.call(e.prototype) } else { try { throw Error() } catch (u) { i = u } t() } } catch (u) {
    if (u && i && typeof u.stack == "string") {
      for (var r = u.stack.split(`
`), o = i.stack.split(`
`), s = r.length - 1, l = o.length - 1; 1 <= s && 0 <= l && r[s] !== o[l];)l--; for (; 1 <= s && 0 <= l; s--, l--)if (r[s] !== o[l]) {
        if (s !== 1 || l !== 1) do if (s--, l--, 0 > l || r[s] !== o[l]) {
          var a = `
`+ r[s].replace(" at new ", " at "); return t.displayName && a.includes("<anonymous>") && (a = a.replace("<anonymous>", t.displayName)), a
        } while (1 <= s && 0 <= l); break
      }
    }
  } finally { Rs = !1, Error.prepareStackTrace = n } return (t = t ? t.displayName || t.name : "") ? Di(t) : ""
} function Ig(t) { switch (t.tag) { case 5: return Di(t.type); case 16: return Di("Lazy"); case 13: return Di("Suspense"); case 19: return Di("SuspenseList"); case 0: case 2: case 15: return t = As(t.type, !1), t; case 11: return t = As(t.type.render, !1), t; case 1: return t = As(t.type, !0), t; default: return "" } } function pl(t) { if (t == null) return null; if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t; switch (t) { case Hn: return "Fragment"; case Bn: return "Portal"; case dl: return "Profiler"; case Aa: return "StrictMode"; case fl: return "Suspense"; case hl: return "SuspenseList" }if (typeof t == "object") switch (t.$$typeof) { case wf: return (t.displayName || "Context") + ".Consumer"; case _f: return (t._context.displayName || "Context") + ".Provider"; case ja: var e = t.render; return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t; case La: return e = t.displayName || null, e !== null ? e : pl(t.type) || "Memo"; case It: e = t._payload, t = t._init; try { return pl(t(e)) } catch { } }return null } function Fg(t) { var e = t.type; switch (t.tag) { case 24: return "Cache"; case 9: return (e.displayName || "Context") + ".Consumer"; case 10: return (e._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return e; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return pl(e); case 8: return e === Aa ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e }return null } function sn(t) { switch (typeof t) { case "boolean": case "number": case "string": case "undefined": return t; case "object": return t; default: return "" } } function bf(t) { var e = t.type; return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio") } function Bg(t) { var e = bf(t) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e), i = "" + t[e]; if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var r = n.get, o = n.set; return Object.defineProperty(t, e, { configurable: !0, get: function () { return r.call(this) }, set: function (s) { i = "" + s, o.call(this, s) } }), Object.defineProperty(t, e, { enumerable: n.enumerable }), { getValue: function () { return i }, setValue: function (s) { i = "" + s }, stopTracking: function () { t._valueTracker = null, delete t[e] } } } } function Dr(t) { t._valueTracker || (t._valueTracker = Bg(t)) } function Sf(t) { if (!t) return !1; var e = t._valueTracker; if (!e) return !0; var n = e.getValue(), i = ""; return t && (i = bf(t) ? t.checked ? "true" : "false" : t.value), t = i, t !== n ? (e.setValue(t), !0) : !1 } function Co(t) { if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null; try { return t.activeElement || t.body } catch { return t.body } } function gl(t, e) { var n = e.checked; return ie({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? t._wrapperState.initialChecked }) } function Hu(t, e) { var n = e.defaultValue == null ? "" : e.defaultValue, i = e.checked != null ? e.checked : e.defaultChecked; n = sn(e.value != null ? e.value : n), t._wrapperState = { initialChecked: i, initialValue: n, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null } } function Ef(t, e) { e = e.checked, e != null && Ra(t, "checked", e, !1) } function ml(t, e) { Ef(t, e); var n = sn(e.value), i = e.type; if (n != null) i === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n); else if (i === "submit" || i === "reset") { t.removeAttribute("value"); return } e.hasOwnProperty("value") ? vl(t, e.type, n) : e.hasOwnProperty("defaultValue") && vl(t, e.type, sn(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked) } function Wu(t, e, n) { if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) { var i = e.type; if (!(i !== "submit" && i !== "reset" || e.value !== void 0 && e.value !== null)) return; e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e } n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n) } function vl(t, e, n) { (e !== "number" || Co(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n)) } var Ni = Array.isArray; function Jn(t, e, n, i) { if (t = t.options, e) { e = {}; for (var r = 0; r < n.length; r++)e["$" + n[r]] = !0; for (n = 0; n < t.length; n++)r = e.hasOwnProperty("$" + t[n].value), t[n].selected !== r && (t[n].selected = r), r && i && (t[n].defaultSelected = !0) } else { for (n = "" + sn(n), e = null, r = 0; r < t.length; r++) { if (t[r].value === n) { t[r].selected = !0, i && (t[r].defaultSelected = !0); return } e !== null || t[r].disabled || (e = t[r]) } e !== null && (e.selected = !0) } } function yl(t, e) { if (e.dangerouslySetInnerHTML != null) throw Error(O(91)); return ie({}, e, { value: void 0, defaultValue: void 0, children: "" + t._wrapperState.initialValue }) } function Vu(t, e) { var n = e.value; if (n == null) { if (n = e.children, e = e.defaultValue, n != null) { if (e != null) throw Error(O(92)); if (Ni(n)) { if (1 < n.length) throw Error(O(93)); n = n[0] } e = n } e == null && (e = ""), n = e } t._wrapperState = { initialValue: sn(n) } } function Cf(t, e) { var n = sn(e.value), i = sn(e.defaultValue); n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), i != null && (t.defaultValue = "" + i) } function $u(t) { var e = t.textContent; e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e) } function Pf(t) { switch (t) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function xl(t, e) { return t == null || t === "http://www.w3.org/1999/xhtml" ? Pf(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t } var Nr, Of = function (t) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, n, i, r) { MSApp.execUnsafeLocalFunction(function () { return t(e, n, i, r) }) } : t }(function (t, e) { if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e; else { for (Nr = Nr || document.createElement("div"), Nr.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Nr.firstChild; t.firstChild;)t.removeChild(t.firstChild); for (; e.firstChild;)t.appendChild(e.firstChild) } }); function ir(t, e) { if (e) { var n = t.firstChild; if (n && n === t.lastChild && n.nodeType === 3) { n.nodeValue = e; return } } t.textContent = e } var $i = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Hg = ["Webkit", "ms", "Moz", "O"]; Object.keys($i).forEach(function (t) { Hg.forEach(function (e) { e = e + t.charAt(0).toUpperCase() + t.substring(1), $i[e] = $i[t] }) }); function Mf(t, e, n) { return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || $i.hasOwnProperty(t) && $i[t] ? ("" + e).trim() : e + "px" } function Tf(t, e) { t = t.style; for (var n in e) if (e.hasOwnProperty(n)) { var i = n.indexOf("--") === 0, r = Mf(n, e[n], i); n === "float" && (n = "cssFloat"), i ? t.setProperty(n, r) : t[n] = r } } var Wg = ie({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function _l(t, e) { if (e) { if (Wg[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(O(137, t)); if (e.dangerouslySetInnerHTML != null) { if (e.children != null) throw Error(O(60)); if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(O(61)) } if (e.style != null && typeof e.style != "object") throw Error(O(62)) } } function wl(t, e) { if (t.indexOf("-") === -1) return typeof e.is == "string"; switch (t) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var kl = null; function Da(t) { return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t } var bl = null, ei = null, ti = null; function Uu(t) { if (t = Cr(t)) { if (typeof bl != "function") throw Error(O(280)); var e = t.stateNode; e && (e = gs(e), bl(t.stateNode, t.type, e)) } } function Rf(t) { ei ? ti ? ti.push(t) : ti = [t] : ei = t } function Af() { if (ei) { var t = ei, e = ti; if (ti = ei = null, Uu(t), e) for (t = 0; t < e.length; t++)Uu(e[t]) } } function jf(t, e) { return t(e) } function Lf() { } var js = !1; function Df(t, e, n) { if (js) return t(e, n); js = !0; try { return jf(t, e, n) } finally { js = !1, (ei !== null || ti !== null) && (Lf(), Af()) } } function rr(t, e) { var n = t.stateNode; if (n === null) return null; var i = gs(n); if (i === null) return null; n = i[e]; e: switch (e) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (i = !i.disabled) || (t = t.type, i = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !i; break e; default: t = !1 }if (t) return null; if (n && typeof n != "function") throw Error(O(231, e, typeof n)); return n } var Sl = !1; if (At) try { var ki = {}; Object.defineProperty(ki, "passive", { get: function () { Sl = !0 } }), window.addEventListener("test", ki, ki), window.removeEventListener("test", ki, ki) } catch { Sl = !1 } function Vg(t, e, n, i, r, o, s, l, a) { var u = Array.prototype.slice.call(arguments, 3); try { e.apply(n, u) } catch (d) { this.onError(d) } } var Ui = !1, Po = null, Oo = !1, El = null, $g = { onError: function (t) { Ui = !0, Po = t } }; function Ug(t, e, n, i, r, o, s, l, a) { Ui = !1, Po = null, Vg.apply($g, arguments) } function Xg(t, e, n, i, r, o, s, l, a) { if (Ug.apply(this, arguments), Ui) { if (Ui) { var u = Po; Ui = !1, Po = null } else throw Error(O(198)); Oo || (Oo = !0, El = u) } } function Dn(t) { var e = t, n = t; if (t.alternate) for (; e.return;)e = e.return; else { t = e; do e = t, e.flags & 4098 && (n = e.return), t = e.return; while (t) } return e.tag === 3 ? n : null } function Nf(t) { if (t.tag === 13) { var e = t.memoizedState; if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated } return null } function Xu(t) { if (Dn(t) !== t) throw Error(O(188)) } function Yg(t) { var e = t.alternate; if (!e) { if (e = Dn(t), e === null) throw Error(O(188)); return e !== t ? null : t } for (var n = t, i = e; ;) { var r = n.return; if (r === null) break; var o = r.alternate; if (o === null) { if (i = r.return, i !== null) { n = i; continue } break } if (r.child === o.child) { for (o = r.child; o;) { if (o === n) return Xu(r), t; if (o === i) return Xu(r), e; o = o.sibling } throw Error(O(188)) } if (n.return !== i.return) n = r, i = o; else { for (var s = !1, l = r.child; l;) { if (l === n) { s = !0, n = r, i = o; break } if (l === i) { s = !0, i = r, n = o; break } l = l.sibling } if (!s) { for (l = o.child; l;) { if (l === n) { s = !0, n = o, i = r; break } if (l === i) { s = !0, i = o, n = r; break } l = l.sibling } if (!s) throw Error(O(189)) } } if (n.alternate !== i) throw Error(O(190)) } if (n.tag !== 3) throw Error(O(188)); return n.stateNode.current === n ? t : e } function zf(t) { return t = Yg(t), t !== null ? If(t) : null } function If(t) { if (t.tag === 5 || t.tag === 6) return t; for (t = t.child; t !== null;) { var e = If(t); if (e !== null) return e; t = t.sibling } return null } var Ff = Ye.unstable_scheduleCallback, Yu = Ye.unstable_cancelCallback, Qg = Ye.unstable_shouldYield, Kg = Ye.unstable_requestPaint, le = Ye.unstable_now, Gg = Ye.unstable_getCurrentPriorityLevel, Na = Ye.unstable_ImmediatePriority, Bf = Ye.unstable_UserBlockingPriority, Mo = Ye.unstable_NormalPriority, Zg = Ye.unstable_LowPriority, Hf = Ye.unstable_IdlePriority, ds = null, _t = null; function qg(t) { if (_t && typeof _t.onCommitFiberRoot == "function") try { _t.onCommitFiberRoot(ds, t, void 0, (t.current.flags & 128) === 128) } catch { } } var ct = Math.clz32 ? Math.clz32 : tm, Jg = Math.log, em = Math.LN2; function tm(t) { return t >>>= 0, t === 0 ? 32 : 31 - (Jg(t) / em | 0) | 0 } var zr = 64, Ir = 4194304; function zi(t) { switch (t & -t) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return t & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return t } } function To(t, e) { var n = t.pendingLanes; if (n === 0) return 0; var i = 0, r = t.suspendedLanes, o = t.pingedLanes, s = n & 268435455; if (s !== 0) { var l = s & ~r; l !== 0 ? i = zi(l) : (o &= s, o !== 0 && (i = zi(o))) } else s = n & ~r, s !== 0 ? i = zi(s) : o !== 0 && (i = zi(o)); if (i === 0) return 0; if (e !== 0 && e !== i && !(e & r) && (r = i & -i, o = e & -e, r >= o || r === 16 && (o & 4194240) !== 0)) return e; if (i & 4 && (i |= n & 16), e = t.entangledLanes, e !== 0) for (t = t.entanglements, e &= i; 0 < e;)n = 31 - ct(e), r = 1 << n, i |= t[n], e &= ~r; return i } function nm(t, e) { switch (t) { case 1: case 2: case 4: return e + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function im(t, e) { for (var n = t.suspendedLanes, i = t.pingedLanes, r = t.expirationTimes, o = t.pendingLanes; 0 < o;) { var s = 31 - ct(o), l = 1 << s, a = r[s]; a === -1 ? (!(l & n) || l & i) && (r[s] = nm(l, e)) : a <= e && (t.expiredLanes |= l), o &= ~l } } function Cl(t) { return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0 } function Wf() { var t = zr; return zr <<= 1, !(zr & 4194240) && (zr = 64), t } function Ls(t) { for (var e = [], n = 0; 31 > n; n++)e.push(t); return e } function Sr(t, e, n) { t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - ct(e), t[e] = n } function rm(t, e) { var n = t.pendingLanes & ~e; t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements; var i = t.eventTimes; for (t = t.expirationTimes; 0 < n;) { var r = 31 - ct(n), o = 1 << r; e[r] = 0, i[r] = -1, t[r] = -1, n &= ~o } } function za(t, e) { var n = t.entangledLanes |= e; for (t = t.entanglements; n;) { var i = 31 - ct(n), r = 1 << i; r & e | t[i] & e && (t[i] |= e), n &= ~r } } var X = 0; function Vf(t) { return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1 } var $f, Ia, Uf, Xf, Yf, Pl = !1, Fr = [], Kt = null, Gt = null, Zt = null, or = new Map, sr = new Map, Ht = [], om = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Qu(t, e) { switch (t) { case "focusin": case "focusout": Kt = null; break; case "dragenter": case "dragleave": Gt = null; break; case "mouseover": case "mouseout": Zt = null; break; case "pointerover": case "pointerout": or.delete(e.pointerId); break; case "gotpointercapture": case "lostpointercapture": sr.delete(e.pointerId) } } function bi(t, e, n, i, r, o) { return t === null || t.nativeEvent !== o ? (t = { blockedOn: e, domEventName: n, eventSystemFlags: i, nativeEvent: o, targetContainers: [r] }, e !== null && (e = Cr(e), e !== null && Ia(e)), t) : (t.eventSystemFlags |= i, e = t.targetContainers, r !== null && e.indexOf(r) === -1 && e.push(r), t) } function sm(t, e, n, i, r) { switch (e) { case "focusin": return Kt = bi(Kt, t, e, n, i, r), !0; case "dragenter": return Gt = bi(Gt, t, e, n, i, r), !0; case "mouseover": return Zt = bi(Zt, t, e, n, i, r), !0; case "pointerover": var o = r.pointerId; return or.set(o, bi(or.get(o) || null, t, e, n, i, r)), !0; case "gotpointercapture": return o = r.pointerId, sr.set(o, bi(sr.get(o) || null, t, e, n, i, r)), !0 }return !1 } function Qf(t) { var e = xn(t.target); if (e !== null) { var n = Dn(e); if (n !== null) { if (e = n.tag, e === 13) { if (e = Nf(n), e !== null) { t.blockedOn = e, Yf(t.priority, function () { Uf(n) }); return } } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) { t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } t.blockedOn = null } function fo(t) { if (t.blockedOn !== null) return !1; for (var e = t.targetContainers; 0 < e.length;) { var n = Ol(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent); if (n === null) { n = t.nativeEvent; var i = new n.constructor(n.type, n); kl = i, n.target.dispatchEvent(i), kl = null } else return e = Cr(n), e !== null && Ia(e), t.blockedOn = n, !1; e.shift() } return !0 } function Ku(t, e, n) { fo(t) && n.delete(e) } function lm() { Pl = !1, Kt !== null && fo(Kt) && (Kt = null), Gt !== null && fo(Gt) && (Gt = null), Zt !== null && fo(Zt) && (Zt = null), or.forEach(Ku), sr.forEach(Ku) } function Si(t, e) { t.blockedOn === e && (t.blockedOn = null, Pl || (Pl = !0, Ye.unstable_scheduleCallback(Ye.unstable_NormalPriority, lm))) } function lr(t) { function e(r) { return Si(r, t) } if (0 < Fr.length) { Si(Fr[0], t); for (var n = 1; n < Fr.length; n++) { var i = Fr[n]; i.blockedOn === t && (i.blockedOn = null) } } for (Kt !== null && Si(Kt, t), Gt !== null && Si(Gt, t), Zt !== null && Si(Zt, t), or.forEach(e), sr.forEach(e), n = 0; n < Ht.length; n++)i = Ht[n], i.blockedOn === t && (i.blockedOn = null); for (; 0 < Ht.length && (n = Ht[0], n.blockedOn === null);)Qf(n), n.blockedOn === null && Ht.shift() } var ni = Nt.ReactCurrentBatchConfig, Ro = !0; function am(t, e, n, i) { var r = X, o = ni.transition; ni.transition = null; try { X = 1, Fa(t, e, n, i) } finally { X = r, ni.transition = o } } function um(t, e, n, i) { var r = X, o = ni.transition; ni.transition = null; try { X = 4, Fa(t, e, n, i) } finally { X = r, ni.transition = o } } function Fa(t, e, n, i) { if (Ro) { var r = Ol(t, e, n, i); if (r === null) $s(t, e, i, Ao, n), Qu(t, i); else if (sm(r, t, e, n, i)) i.stopPropagation(); else if (Qu(t, i), e & 4 && -1 < om.indexOf(t)) { for (; r !== null;) { var o = Cr(r); if (o !== null && $f(o), o = Ol(t, e, n, i), o === null && $s(t, e, i, Ao, n), o === r) break; r = o } r !== null && i.stopPropagation() } else $s(t, e, i, null, n) } } var Ao = null; function Ol(t, e, n, i) { if (Ao = null, t = Da(i), t = xn(t), t !== null) if (e = Dn(t), e === null) t = null; else if (n = e.tag, n === 13) { if (t = Nf(e), t !== null) return t; t = null } else if (n === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; t = null } else e !== t && (t = null); return Ao = t, null } function Kf(t) { switch (t) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Gg()) { case Na: return 1; case Bf: return 4; case Mo: case Zg: return 16; case Hf: return 536870912; default: return 16 }default: return 16 } } var Vt = null, Ba = null, ho = null; function Gf() { if (ho) return ho; var t, e = Ba, n = e.length, i, r = "value" in Vt ? Vt.value : Vt.textContent, o = r.length; for (t = 0; t < n && e[t] === r[t]; t++); var s = n - t; for (i = 1; i <= s && e[n - i] === r[o - i]; i++); return ho = r.slice(t, 1 < i ? 1 - i : void 0) } function po(t) { var e = t.keyCode; return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0 } function Br() { return !0 } function Gu() { return !1 } function Ke(t) { function e(n, i, r, o, s) { this._reactName = n, this._targetInst = r, this.type = i, this.nativeEvent = o, this.target = s, this.currentTarget = null; for (var l in t) t.hasOwnProperty(l) && (n = t[l], this[l] = n ? n(o) : o[l]); return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1) ? Br : Gu, this.isPropagationStopped = Gu, this } return ie(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = Br) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = Br) }, persist: function () { }, isPersistent: Br }), e } var yi = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (t) { return t.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Ha = Ke(yi), Er = ie({}, yi, { view: 0, detail: 0 }), cm = Ke(Er), Ds, Ns, Ei, fs = ie({}, Er, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Wa, button: 0, buttons: 0, relatedTarget: function (t) { return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget }, movementX: function (t) { return "movementX" in t ? t.movementX : (t !== Ei && (Ei && t.type === "mousemove" ? (Ds = t.screenX - Ei.screenX, Ns = t.screenY - Ei.screenY) : Ns = Ds = 0, Ei = t), Ds) }, movementY: function (t) { return "movementY" in t ? t.movementY : Ns } }), Zu = Ke(fs), dm = ie({}, fs, { dataTransfer: 0 }), fm = Ke(dm), hm = ie({}, Er, { relatedTarget: 0 }), zs = Ke(hm), pm = ie({}, yi, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), gm = Ke(pm), mm = ie({}, yi, { clipboardData: function (t) { return "clipboardData" in t ? t.clipboardData : window.clipboardData } }), vm = Ke(mm), ym = ie({}, yi, { data: 0 }), qu = Ke(ym), xm = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, _m = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, wm = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function km(t) { var e = this.nativeEvent; return e.getModifierState ? e.getModifierState(t) : (t = wm[t]) ? !!e[t] : !1 } function Wa() { return km } var bm = ie({}, Er, { key: function (t) { if (t.key) { var e = xm[t.key] || t.key; if (e !== "Unidentified") return e } return t.type === "keypress" ? (t = po(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? _m[t.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Wa, charCode: function (t) { return t.type === "keypress" ? po(t) : 0 }, keyCode: function (t) { return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 }, which: function (t) { return t.type === "keypress" ? po(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 } }), Sm = Ke(bm), Em = ie({}, fs, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Ju = Ke(Em), Cm = ie({}, Er, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Wa }), Pm = Ke(Cm), Om = ie({}, yi, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Mm = Ke(Om), Tm = ie({}, fs, { deltaX: function (t) { return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0 }, deltaY: function (t) { return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), Rm = Ke(Tm), Am = [9, 13, 27, 32], Va = At && "CompositionEvent" in window, Xi = null; At && "documentMode" in document && (Xi = document.documentMode); var jm = At && "TextEvent" in window && !Xi, Zf = At && (!Va || Xi && 8 < Xi && 11 >= Xi), ec = String.fromCharCode(32), tc = !1; function qf(t, e) { switch (t) { case "keyup": return Am.indexOf(e.keyCode) !== -1; case "keydown": return e.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Jf(t) { return t = t.detail, typeof t == "object" && "data" in t ? t.data : null } var Wn = !1; function Lm(t, e) { switch (t) { case "compositionend": return Jf(e); case "keypress": return e.which !== 32 ? null : (tc = !0, ec); case "textInput": return t = e.data, t === ec && tc ? null : t; default: return null } } function Dm(t, e) { if (Wn) return t === "compositionend" || !Va && qf(t, e) ? (t = Gf(), ho = Ba = Vt = null, Wn = !1, t) : null; switch (t) { case "paste": return null; case "keypress": if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && 1 < e.char.length) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case "compositionend": return Zf && e.locale !== "ko" ? null : e.data; default: return null } } var Nm = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function nc(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e === "input" ? !!Nm[t.type] : e === "textarea" } function eh(t, e, n, i) { Rf(i), e = jo(e, "onChange"), 0 < e.length && (n = new Ha("onChange", "change", null, n, i), t.push({ event: n, listeners: e })) } var Yi = null, ar = null; function zm(t) { dh(t, 0) } function hs(t) { var e = Un(t); if (Sf(e)) return t } function Im(t, e) { if (t === "change") return e } var th = !1; if (At) { var Is; if (At) { var Fs = "oninput" in document; if (!Fs) { var ic = document.createElement("div"); ic.setAttribute("oninput", "return;"), Fs = typeof ic.oninput == "function" } Is = Fs } else Is = !1; th = Is && (!document.documentMode || 9 < document.documentMode) } function rc() { Yi && (Yi.detachEvent("onpropertychange", nh), ar = Yi = null) } function nh(t) { if (t.propertyName === "value" && hs(ar)) { var e = []; eh(e, ar, t, Da(t)), Df(zm, e) } } function Fm(t, e, n) { t === "focusin" ? (rc(), Yi = e, ar = n, Yi.attachEvent("onpropertychange", nh)) : t === "focusout" && rc() } function Bm(t) { if (t === "selectionchange" || t === "keyup" || t === "keydown") return hs(ar) } function Hm(t, e) { if (t === "click") return hs(e) } function Wm(t, e) { if (t === "input" || t === "change") return hs(e) } function Vm(t, e) { return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e } var ft = typeof Object.is == "function" ? Object.is : Vm; function ur(t, e) { if (ft(t, e)) return !0; if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1; var n = Object.keys(t), i = Object.keys(e); if (n.length !== i.length) return !1; for (i = 0; i < n.length; i++) { var r = n[i]; if (!cl.call(e, r) || !ft(t[r], e[r])) return !1 } return !0 } function oc(t) { for (; t && t.firstChild;)t = t.firstChild; return t } function sc(t, e) { var n = oc(t); t = 0; for (var i; n;) { if (n.nodeType === 3) { if (i = t + n.textContent.length, t <= e && i >= e) return { node: n, offset: e - t }; t = i } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = oc(n) } } function ih(t, e) { return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? ih(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1 } function rh() { for (var t = window, e = Co(); e instanceof t.HTMLIFrameElement;) { try { var n = typeof e.contentWindow.location.href == "string" } catch { n = !1 } if (n) t = e.contentWindow; else break; e = Co(t.document) } return e } function $a(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true") } function $m(t) { var e = rh(), n = t.focusedElem, i = t.selectionRange; if (e !== n && n && n.ownerDocument && ih(n.ownerDocument.documentElement, n)) { if (i !== null && $a(n)) { if (e = i.start, t = i.end, t === void 0 && (t = e), "selectionStart" in n) n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length); else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) { t = t.getSelection(); var r = n.textContent.length, o = Math.min(i.start, r); i = i.end === void 0 ? o : Math.min(i.end, r), !t.extend && o > i && (r = i, i = o, o = r), r = sc(n, o); var s = sc(n, i); r && s && (t.rangeCount !== 1 || t.anchorNode !== r.node || t.anchorOffset !== r.offset || t.focusNode !== s.node || t.focusOffset !== s.offset) && (e = e.createRange(), e.setStart(r.node, r.offset), t.removeAllRanges(), o > i ? (t.addRange(e), t.extend(s.node, s.offset)) : (e.setEnd(s.node, s.offset), t.addRange(e))) } } for (e = [], t = n; t = t.parentNode;)t.nodeType === 1 && e.push({ element: t, left: t.scrollLeft, top: t.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top } } var Um = At && "documentMode" in document && 11 >= document.documentMode, Vn = null, Ml = null, Qi = null, Tl = !1; function lc(t, e, n) { var i = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Tl || Vn == null || Vn !== Co(i) || (i = Vn, "selectionStart" in i && $a(i) ? i = { start: i.selectionStart, end: i.selectionEnd } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(), i = { anchorNode: i.anchorNode, anchorOffset: i.anchorOffset, focusNode: i.focusNode, focusOffset: i.focusOffset }), Qi && ur(Qi, i) || (Qi = i, i = jo(Ml, "onSelect"), 0 < i.length && (e = new Ha("onSelect", "select", null, e, n), t.push({ event: e, listeners: i }), e.target = Vn))) } function Hr(t, e) { var n = {}; return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n } var $n = { animationend: Hr("Animation", "AnimationEnd"), animationiteration: Hr("Animation", "AnimationIteration"), animationstart: Hr("Animation", "AnimationStart"), transitionend: Hr("Transition", "TransitionEnd") }, Bs = {}, oh = {}; At && (oh = document.createElement("div").style, "AnimationEvent" in window || (delete $n.animationend.animation, delete $n.animationiteration.animation, delete $n.animationstart.animation), "TransitionEvent" in window || delete $n.transitionend.transition); function ps(t) { if (Bs[t]) return Bs[t]; if (!$n[t]) return t; var e = $n[t], n; for (n in e) if (e.hasOwnProperty(n) && n in oh) return Bs[t] = e[n]; return t } var sh = ps("animationend"), lh = ps("animationiteration"), ah = ps("animationstart"), uh = ps("transitionend"), ch = new Map, ac = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function un(t, e) { ch.set(t, e), Ln(e, [t]) } for (var Hs = 0; Hs < ac.length; Hs++) { var Ws = ac[Hs], Xm = Ws.toLowerCase(), Ym = Ws[0].toUpperCase() + Ws.slice(1); un(Xm, "on" + Ym) } un(sh, "onAnimationEnd"); un(lh, "onAnimationIteration"); un(ah, "onAnimationStart"); un("dblclick", "onDoubleClick"); un("focusin", "onFocus"); un("focusout", "onBlur"); un(uh, "onTransitionEnd"); ai("onMouseEnter", ["mouseout", "mouseover"]); ai("onMouseLeave", ["mouseout", "mouseover"]); ai("onPointerEnter", ["pointerout", "pointerover"]); ai("onPointerLeave", ["pointerout", "pointerover"]); Ln("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); Ln("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); Ln("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); Ln("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); Ln("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); Ln("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Ii = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Qm = new Set("cancel close invalid load scroll toggle".split(" ").concat(Ii)); function uc(t, e, n) { var i = t.type || "unknown-event"; t.currentTarget = n, Xg(i, e, void 0, t), t.currentTarget = null } function dh(t, e) { e = (e & 4) !== 0; for (var n = 0; n < t.length; n++) { var i = t[n], r = i.event; i = i.listeners; e: { var o = void 0; if (e) for (var s = i.length - 1; 0 <= s; s--) { var l = i[s], a = l.instance, u = l.currentTarget; if (l = l.listener, a !== o && r.isPropagationStopped()) break e; uc(r, l, u), o = a } else for (s = 0; s < i.length; s++) { if (l = i[s], a = l.instance, u = l.currentTarget, l = l.listener, a !== o && r.isPropagationStopped()) break e; uc(r, l, u), o = a } } } if (Oo) throw t = El, Oo = !1, El = null, t } function Z(t, e) { var n = e[Dl]; n === void 0 && (n = e[Dl] = new Set); var i = t + "__bubble"; n.has(i) || (fh(e, t, 2, !1), n.add(i)) } function Vs(t, e, n) { var i = 0; e && (i |= 4), fh(n, t, i, e) } var Wr = "_reactListening" + Math.random().toString(36).slice(2); function cr(t) { if (!t[Wr]) { t[Wr] = !0, xf.forEach(function (n) { n !== "selectionchange" && (Qm.has(n) || Vs(n, !1, t), Vs(n, !0, t)) }); var e = t.nodeType === 9 ? t : t.ownerDocument; e === null || e[Wr] || (e[Wr] = !0, Vs("selectionchange", !1, e)) } } function fh(t, e, n, i) { switch (Kf(e)) { case 1: var r = am; break; case 4: r = um; break; default: r = Fa }n = r.bind(null, e, n, t), r = void 0, !Sl || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0), i ? r !== void 0 ? t.addEventListener(e, n, { capture: !0, passive: r }) : t.addEventListener(e, n, !0) : r !== void 0 ? t.addEventListener(e, n, { passive: r }) : t.addEventListener(e, n, !1) } function $s(t, e, n, i, r) { var o = i; if (!(e & 1) && !(e & 2) && i !== null) e: for (; ;) { if (i === null) return; var s = i.tag; if (s === 3 || s === 4) { var l = i.stateNode.containerInfo; if (l === r || l.nodeType === 8 && l.parentNode === r) break; if (s === 4) for (s = i.return; s !== null;) { var a = s.tag; if ((a === 3 || a === 4) && (a = s.stateNode.containerInfo, a === r || a.nodeType === 8 && a.parentNode === r)) return; s = s.return } for (; l !== null;) { if (s = xn(l), s === null) return; if (a = s.tag, a === 5 || a === 6) { i = o = s; continue e } l = l.parentNode } } i = i.return } Df(function () { var u = o, d = Da(n), f = []; e: { var c = ch.get(t); if (c !== void 0) { var h = Ha, g = t; switch (t) { case "keypress": if (po(n) === 0) break e; case "keydown": case "keyup": h = Sm; break; case "focusin": g = "focus", h = zs; break; case "focusout": g = "blur", h = zs; break; case "beforeblur": case "afterblur": h = zs; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": h = Zu; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": h = fm; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": h = Pm; break; case sh: case lh: case ah: h = gm; break; case uh: h = Mm; break; case "scroll": h = cm; break; case "wheel": h = Rm; break; case "copy": case "cut": case "paste": h = vm; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": h = Ju }var v = (e & 4) !== 0, _ = !v && t === "scroll", m = v ? c !== null ? c + "Capture" : null : c; v = []; for (var p = u, y; p !== null;) { y = p; var w = y.stateNode; if (y.tag === 5 && w !== null && (y = w, m !== null && (w = rr(p, m), w != null && v.push(dr(p, w, y)))), _) break; p = p.return } 0 < v.length && (c = new h(c, g, null, n, d), f.push({ event: c, listeners: v })) } } if (!(e & 7)) { e: { if (c = t === "mouseover" || t === "pointerover", h = t === "mouseout" || t === "pointerout", c && n !== kl && (g = n.relatedTarget || n.fromElement) && (xn(g) || g[jt])) break e; if ((h || c) && (c = d.window === d ? d : (c = d.ownerDocument) ? c.defaultView || c.parentWindow : window, h ? (g = n.relatedTarget || n.toElement, h = u, g = g ? xn(g) : null, g !== null && (_ = Dn(g), g !== _ || g.tag !== 5 && g.tag !== 6) && (g = null)) : (h = null, g = u), h !== g)) { if (v = Zu, w = "onMouseLeave", m = "onMouseEnter", p = "mouse", (t === "pointerout" || t === "pointerover") && (v = Ju, w = "onPointerLeave", m = "onPointerEnter", p = "pointer"), _ = h == null ? c : Un(h), y = g == null ? c : Un(g), c = new v(w, p + "leave", h, n, d), c.target = _, c.relatedTarget = y, w = null, xn(d) === u && (v = new v(m, p + "enter", g, n, d), v.target = y, v.relatedTarget = _, w = v), _ = w, h && g) t: { for (v = h, m = g, p = 0, y = v; y; y = zn(y))p++; for (y = 0, w = m; w; w = zn(w))y++; for (; 0 < p - y;)v = zn(v), p--; for (; 0 < y - p;)m = zn(m), y--; for (; p--;) { if (v === m || m !== null && v === m.alternate) break t; v = zn(v), m = zn(m) } v = null } else v = null; h !== null && cc(f, c, h, v, !1), g !== null && _ !== null && cc(f, _, g, v, !0) } } e: { if (c = u ? Un(u) : window, h = c.nodeName && c.nodeName.toLowerCase(), h === "select" || h === "input" && c.type === "file") var S = Im; else if (nc(c)) if (th) S = Wm; else { S = Bm; var x = Fm } else (h = c.nodeName) && h.toLowerCase() === "input" && (c.type === "checkbox" || c.type === "radio") && (S = Hm); if (S && (S = S(t, u))) { eh(f, S, n, d); break e } x && x(t, c, u), t === "focusout" && (x = c._wrapperState) && x.controlled && c.type === "number" && vl(c, "number", c.value) } switch (x = u ? Un(u) : window, t) { case "focusin": (nc(x) || x.contentEditable === "true") && (Vn = x, Ml = u, Qi = null); break; case "focusout": Qi = Ml = Vn = null; break; case "mousedown": Tl = !0; break; case "contextmenu": case "mouseup": case "dragend": Tl = !1, lc(f, n, d); break; case "selectionchange": if (Um) break; case "keydown": case "keyup": lc(f, n, d) }var k; if (Va) e: { switch (t) { case "compositionstart": var b = "onCompositionStart"; break e; case "compositionend": b = "onCompositionEnd"; break e; case "compositionupdate": b = "onCompositionUpdate"; break e }b = void 0 } else Wn ? qf(t, n) && (b = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (b = "onCompositionStart"); b && (Zf && n.locale !== "ko" && (Wn || b !== "onCompositionStart" ? b === "onCompositionEnd" && Wn && (k = Gf()) : (Vt = d, Ba = "value" in Vt ? Vt.value : Vt.textContent, Wn = !0)), x = jo(u, b), 0 < x.length && (b = new qu(b, t, null, n, d), f.push({ event: b, listeners: x }), k ? b.data = k : (k = Jf(n), k !== null && (b.data = k)))), (k = jm ? Lm(t, n) : Dm(t, n)) && (u = jo(u, "onBeforeInput"), 0 < u.length && (d = new qu("onBeforeInput", "beforeinput", null, n, d), f.push({ event: d, listeners: u }), d.data = k)) } dh(f, e) }) } function dr(t, e, n) { return { instance: t, listener: e, currentTarget: n } } function jo(t, e) { for (var n = e + "Capture", i = []; t !== null;) { var r = t, o = r.stateNode; r.tag === 5 && o !== null && (r = o, o = rr(t, n), o != null && i.unshift(dr(t, o, r)), o = rr(t, e), o != null && i.push(dr(t, o, r))), t = t.return } return i } function zn(t) { if (t === null) return null; do t = t.return; while (t && t.tag !== 5); return t || null } function cc(t, e, n, i, r) { for (var o = e._reactName, s = []; n !== null && n !== i;) { var l = n, a = l.alternate, u = l.stateNode; if (a !== null && a === i) break; l.tag === 5 && u !== null && (l = u, r ? (a = rr(n, o), a != null && s.unshift(dr(n, a, l))) : r || (a = rr(n, o), a != null && s.push(dr(n, a, l)))), n = n.return } s.length !== 0 && t.push({ event: e, listeners: s }) } var Km = /\r\n?/g, Gm = /\u0000|\uFFFD/g; function dc(t) {
  return (typeof t == "string" ? t : "" + t).replace(Km, `
`).replace(Gm, "")
} function Vr(t, e, n) { if (e = dc(e), dc(t) !== e && n) throw Error(O(425)) } function Lo() { } var Rl = null, Al = null; function jl(t, e) { return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } var Ll = typeof setTimeout == "function" ? setTimeout : void 0, Zm = typeof clearTimeout == "function" ? clearTimeout : void 0, fc = typeof Promise == "function" ? Promise : void 0, qm = typeof queueMicrotask == "function" ? queueMicrotask : typeof fc < "u" ? function (t) { return fc.resolve(null).then(t).catch(Jm) } : Ll; function Jm(t) { setTimeout(function () { throw t }) } function Us(t, e) { var n = e, i = 0; do { var r = n.nextSibling; if (t.removeChild(n), r && r.nodeType === 8) if (n = r.data, n === "/$") { if (i === 0) { t.removeChild(r), lr(e); return } i-- } else n !== "$" && n !== "$?" && n !== "$!" || i++; n = r } while (n); lr(e) } function qt(t) { for (; t != null; t = t.nextSibling) { var e = t.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = t.data, e === "$" || e === "$!" || e === "$?") break; if (e === "/$") return null } } return t } function hc(t) { t = t.previousSibling; for (var e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "$" || n === "$!" || n === "$?") { if (e === 0) return t; e-- } else n === "/$" && e++ } t = t.previousSibling } return null } var xi = Math.random().toString(36).slice(2), xt = "__reactFiber$" + xi, fr = "__reactProps$" + xi, jt = "__reactContainer$" + xi, Dl = "__reactEvents$" + xi, e0 = "__reactListeners$" + xi, t0 = "__reactHandles$" + xi; function xn(t) { var e = t[xt]; if (e) return e; for (var n = t.parentNode; n;) { if (e = n[jt] || n[xt]) { if (n = e.alternate, e.child !== null || n !== null && n.child !== null) for (t = hc(t); t !== null;) { if (n = t[xt]) return n; t = hc(t) } return e } t = n, n = t.parentNode } return null } function Cr(t) { return t = t[xt] || t[jt], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t } function Un(t) { if (t.tag === 5 || t.tag === 6) return t.stateNode; throw Error(O(33)) } function gs(t) { return t[fr] || null } var Nl = [], Xn = -1; function cn(t) { return { current: t } } function q(t) { 0 > Xn || (t.current = Nl[Xn], Nl[Xn] = null, Xn--) } function G(t, e) { Xn++, Nl[Xn] = t.current, t.current = e } var ln = {}, Ce = cn(ln), ze = cn(!1), Cn = ln; function ui(t, e) { var n = t.type.contextTypes; if (!n) return ln; var i = t.stateNode; if (i && i.__reactInternalMemoizedUnmaskedChildContext === e) return i.__reactInternalMemoizedMaskedChildContext; var r = {}, o; for (o in n) r[o] = e[o]; return i && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = r), r } function Ie(t) { return t = t.childContextTypes, t != null } function Do() { q(ze), q(Ce) } function pc(t, e, n) { if (Ce.current !== ln) throw Error(O(168)); G(Ce, e), G(ze, n) } function hh(t, e, n) { var i = t.stateNode; if (e = e.childContextTypes, typeof i.getChildContext != "function") return n; i = i.getChildContext(); for (var r in i) if (!(r in e)) throw Error(O(108, Fg(t) || "Unknown", r)); return ie({}, n, i) } function No(t) { return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || ln, Cn = Ce.current, G(Ce, t), G(ze, ze.current), !0 } function gc(t, e, n) { var i = t.stateNode; if (!i) throw Error(O(169)); n ? (t = hh(t, e, Cn), i.__reactInternalMemoizedMergedChildContext = t, q(ze), q(Ce), G(Ce, t)) : q(ze), G(ze, n) } var Pt = null, ms = !1, Xs = !1; function ph(t) { Pt === null ? Pt = [t] : Pt.push(t) } function n0(t) { ms = !0, ph(t) } function dn() { if (!Xs && Pt !== null) { Xs = !0; var t = 0, e = X; try { var n = Pt; for (X = 1; t < n.length; t++) { var i = n[t]; do i = i(!0); while (i !== null) } Pt = null, ms = !1 } catch (r) { throw Pt !== null && (Pt = Pt.slice(t + 1)), Ff(Na, dn), r } finally { X = e, Xs = !1 } } return null } var Yn = [], Qn = 0, zo = null, Io = 0, qe = [], Je = 0, Pn = null, Mt = 1, Tt = ""; function mn(t, e) { Yn[Qn++] = Io, Yn[Qn++] = zo, zo = t, Io = e } function gh(t, e, n) { qe[Je++] = Mt, qe[Je++] = Tt, qe[Je++] = Pn, Pn = t; var i = Mt; t = Tt; var r = 32 - ct(i) - 1; i &= ~(1 << r), n += 1; var o = 32 - ct(e) + r; if (30 < o) { var s = r - r % 5; o = (i & (1 << s) - 1).toString(32), i >>= s, r -= s, Mt = 1 << 32 - ct(e) + r | n << r | i, Tt = o + t } else Mt = 1 << o | n << r | i, Tt = t } function Ua(t) { t.return !== null && (mn(t, 1), gh(t, 1, 0)) } function Xa(t) { for (; t === zo;)zo = Yn[--Qn], Yn[Qn] = null, Io = Yn[--Qn], Yn[Qn] = null; for (; t === Pn;)Pn = qe[--Je], qe[Je] = null, Tt = qe[--Je], qe[Je] = null, Mt = qe[--Je], qe[Je] = null } var Xe = null, Ue = null, J = !1, ut = null; function mh(t, e) { var n = et(5, null, null, 0); n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [n], t.flags |= 16) : e.push(n) } function mc(t, e) { switch (t.tag) { case 5: var n = t.type; return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, Xe = t, Ue = qt(e.firstChild), !0) : !1; case 6: return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, Xe = t, Ue = null, !0) : !1; case 13: return e = e.nodeType !== 8 ? null : e, e !== null ? (n = Pn !== null ? { id: Mt, overflow: Tt } : null, t.memoizedState = { dehydrated: e, treeContext: n, retryLane: 1073741824 }, n = et(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, Xe = t, Ue = null, !0) : !1; default: return !1 } } function zl(t) { return (t.mode & 1) !== 0 && (t.flags & 128) === 0 } function Il(t) { if (J) { var e = Ue; if (e) { var n = e; if (!mc(t, e)) { if (zl(t)) throw Error(O(418)); e = qt(n.nextSibling); var i = Xe; e && mc(t, e) ? mh(i, n) : (t.flags = t.flags & -4097 | 2, J = !1, Xe = t) } } else { if (zl(t)) throw Error(O(418)); t.flags = t.flags & -4097 | 2, J = !1, Xe = t } } } function vc(t) { for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;)t = t.return; Xe = t } function $r(t) { if (t !== Xe) return !1; if (!J) return vc(t), J = !0, !1; var e; if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !jl(t.type, t.memoizedProps)), e && (e = Ue)) { if (zl(t)) throw vh(), Error(O(418)); for (; e;)mh(t, e), e = qt(e.nextSibling) } if (vc(t), t.tag === 13) { if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(O(317)); e: { for (t = t.nextSibling, e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "/$") { if (e === 0) { Ue = qt(t.nextSibling); break e } e-- } else n !== "$" && n !== "$!" && n !== "$?" || e++ } t = t.nextSibling } Ue = null } } else Ue = Xe ? qt(t.stateNode.nextSibling) : null; return !0 } function vh() { for (var t = Ue; t;)t = qt(t.nextSibling) } function ci() { Ue = Xe = null, J = !1 } function Ya(t) { ut === null ? ut = [t] : ut.push(t) } var i0 = Nt.ReactCurrentBatchConfig; function lt(t, e) { if (t && t.defaultProps) { e = ie({}, e), t = t.defaultProps; for (var n in t) e[n] === void 0 && (e[n] = t[n]); return e } return e } var Fo = cn(null), Bo = null, Kn = null, Qa = null; function Ka() { Qa = Kn = Bo = null } function Ga(t) { var e = Fo.current; q(Fo), t._currentValue = e } function Fl(t, e, n) { for (; t !== null;) { var i = t.alternate; if ((t.childLanes & e) !== e ? (t.childLanes |= e, i !== null && (i.childLanes |= e)) : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e), t === n) break; t = t.return } } function ii(t, e) { Bo = t, Qa = Kn = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & e && (Ne = !0), t.firstContext = null) } function it(t) { var e = t._currentValue; if (Qa !== t) if (t = { context: t, memoizedValue: e, next: null }, Kn === null) { if (Bo === null) throw Error(O(308)); Kn = t, Bo.dependencies = { lanes: 0, firstContext: t } } else Kn = Kn.next = t; return e } var _n = null; function Za(t) { _n === null ? _n = [t] : _n.push(t) } function yh(t, e, n, i) { var r = e.interleaved; return r === null ? (n.next = n, Za(e)) : (n.next = r.next, r.next = n), e.interleaved = n, Lt(t, i) } function Lt(t, e) { t.lanes |= e; var n = t.alternate; for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null;)t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return; return n.tag === 3 ? n.stateNode : null } var Ft = !1; function qa(t) { t.updateQueue = { baseState: t.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function xh(t, e) { t = t.updateQueue, e.updateQueue === t && (e.updateQueue = { baseState: t.baseState, firstBaseUpdate: t.firstBaseUpdate, lastBaseUpdate: t.lastBaseUpdate, shared: t.shared, effects: t.effects }) } function Rt(t, e) { return { eventTime: t, lane: e, tag: 0, payload: null, callback: null, next: null } } function Jt(t, e, n) { var i = t.updateQueue; if (i === null) return null; if (i = i.shared, H & 2) { var r = i.pending; return r === null ? e.next = e : (e.next = r.next, r.next = e), i.pending = e, Lt(t, n) } return r = i.interleaved, r === null ? (e.next = e, Za(i)) : (e.next = r.next, r.next = e), i.interleaved = e, Lt(t, n) } function go(t, e, n) { if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) { var i = e.lanes; i &= t.pendingLanes, n |= i, e.lanes = n, za(t, n) } } function yc(t, e) { var n = t.updateQueue, i = t.alternate; if (i !== null && (i = i.updateQueue, n === i)) { var r = null, o = null; if (n = n.firstBaseUpdate, n !== null) { do { var s = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; o === null ? r = o = s : o = o.next = s, n = n.next } while (n !== null); o === null ? r = o = e : o = o.next = e } else r = o = e; n = { baseState: i.baseState, firstBaseUpdate: r, lastBaseUpdate: o, shared: i.shared, effects: i.effects }, t.updateQueue = n; return } t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e } function Ho(t, e, n, i) { var r = t.updateQueue; Ft = !1; var o = r.firstBaseUpdate, s = r.lastBaseUpdate, l = r.shared.pending; if (l !== null) { r.shared.pending = null; var a = l, u = a.next; a.next = null, s === null ? o = u : s.next = u, s = a; var d = t.alternate; d !== null && (d = d.updateQueue, l = d.lastBaseUpdate, l !== s && (l === null ? d.firstBaseUpdate = u : l.next = u, d.lastBaseUpdate = a)) } if (o !== null) { var f = r.baseState; s = 0, d = u = a = null, l = o; do { var c = l.lane, h = l.eventTime; if ((i & c) === c) { d !== null && (d = d.next = { eventTime: h, lane: 0, tag: l.tag, payload: l.payload, callback: l.callback, next: null }); e: { var g = t, v = l; switch (c = e, h = n, v.tag) { case 1: if (g = v.payload, typeof g == "function") { f = g.call(h, f, c); break e } f = g; break e; case 3: g.flags = g.flags & -65537 | 128; case 0: if (g = v.payload, c = typeof g == "function" ? g.call(h, f, c) : g, c == null) break e; f = ie({}, f, c); break e; case 2: Ft = !0 } } l.callback !== null && l.lane !== 0 && (t.flags |= 64, c = r.effects, c === null ? r.effects = [l] : c.push(l)) } else h = { eventTime: h, lane: c, tag: l.tag, payload: l.payload, callback: l.callback, next: null }, d === null ? (u = d = h, a = f) : d = d.next = h, s |= c; if (l = l.next, l === null) { if (l = r.shared.pending, l === null) break; c = l, l = c.next, c.next = null, r.lastBaseUpdate = c, r.shared.pending = null } } while (1); if (d === null && (a = f), r.baseState = a, r.firstBaseUpdate = u, r.lastBaseUpdate = d, e = r.shared.interleaved, e !== null) { r = e; do s |= r.lane, r = r.next; while (r !== e) } else o === null && (r.shared.lanes = 0); Mn |= s, t.lanes = s, t.memoizedState = f } } function xc(t, e, n) { if (t = e.effects, e.effects = null, t !== null) for (e = 0; e < t.length; e++) { var i = t[e], r = i.callback; if (r !== null) { if (i.callback = null, i = n, typeof r != "function") throw Error(O(191, r)); r.call(i) } } } var _h = new yf.Component().refs; function Bl(t, e, n, i) { e = t.memoizedState, n = n(i, e), n = n == null ? e : ie({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n) } var vs = { isMounted: function (t) { return (t = t._reactInternals) ? Dn(t) === t : !1 }, enqueueSetState: function (t, e, n) { t = t._reactInternals; var i = Me(), r = tn(t), o = Rt(i, r); o.payload = e, n != null && (o.callback = n), e = Jt(t, o, r), e !== null && (dt(e, t, r, i), go(e, t, r)) }, enqueueReplaceState: function (t, e, n) { t = t._reactInternals; var i = Me(), r = tn(t), o = Rt(i, r); o.tag = 1, o.payload = e, n != null && (o.callback = n), e = Jt(t, o, r), e !== null && (dt(e, t, r, i), go(e, t, r)) }, enqueueForceUpdate: function (t, e) { t = t._reactInternals; var n = Me(), i = tn(t), r = Rt(n, i); r.tag = 2, e != null && (r.callback = e), e = Jt(t, r, i), e !== null && (dt(e, t, i, n), go(e, t, i)) } }; function _c(t, e, n, i, r, o, s) { return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(i, o, s) : e.prototype && e.prototype.isPureReactComponent ? !ur(n, i) || !ur(r, o) : !0 } function wh(t, e, n) { var i = !1, r = ln, o = e.contextType; return typeof o == "object" && o !== null ? o = it(o) : (r = Ie(e) ? Cn : Ce.current, i = e.contextTypes, o = (i = i != null) ? ui(t, r) : ln), e = new e(n, o), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = vs, t.stateNode = e, e._reactInternals = t, i && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = r, t.__reactInternalMemoizedMaskedChildContext = o), e } function wc(t, e, n, i) { t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, i), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, i), e.state !== t && vs.enqueueReplaceState(e, e.state, null) } function Hl(t, e, n, i) { var r = t.stateNode; r.props = n, r.state = t.memoizedState, r.refs = _h, qa(t); var o = e.contextType; typeof o == "object" && o !== null ? r.context = it(o) : (o = Ie(e) ? Cn : Ce.current, r.context = ui(t, o)), r.state = t.memoizedState, o = e.getDerivedStateFromProps, typeof o == "function" && (Bl(t, e, o, n), r.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), e !== r.state && vs.enqueueReplaceState(r, r.state, null), Ho(t, n, r, i), r.state = t.memoizedState), typeof r.componentDidMount == "function" && (t.flags |= 4194308) } function Ci(t, e, n) { if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(O(309)); var i = n.stateNode } if (!i) throw Error(O(147, t)); var r = i, o = "" + t; return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === o ? e.ref : (e = function (s) { var l = r.refs; l === _h && (l = r.refs = {}), s === null ? delete l[o] : l[o] = s }, e._stringRef = o, e) } if (typeof t != "string") throw Error(O(284)); if (!n._owner) throw Error(O(290, t)) } return t } function Ur(t, e) { throw t = Object.prototype.toString.call(e), Error(O(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t)) } function kc(t) { var e = t._init; return e(t._payload) } function kh(t) { function e(m, p) { if (t) { var y = m.deletions; y === null ? (m.deletions = [p], m.flags |= 16) : y.push(p) } } function n(m, p) { if (!t) return null; for (; p !== null;)e(m, p), p = p.sibling; return null } function i(m, p) { for (m = new Map; p !== null;)p.key !== null ? m.set(p.key, p) : m.set(p.index, p), p = p.sibling; return m } function r(m, p) { return m = nn(m, p), m.index = 0, m.sibling = null, m } function o(m, p, y) { return m.index = y, t ? (y = m.alternate, y !== null ? (y = y.index, y < p ? (m.flags |= 2, p) : y) : (m.flags |= 2, p)) : (m.flags |= 1048576, p) } function s(m) { return t && m.alternate === null && (m.flags |= 2), m } function l(m, p, y, w) { return p === null || p.tag !== 6 ? (p = Js(y, m.mode, w), p.return = m, p) : (p = r(p, y), p.return = m, p) } function a(m, p, y, w) { var S = y.type; return S === Hn ? d(m, p, y.props.children, w, y.key) : p !== null && (p.elementType === S || typeof S == "object" && S !== null && S.$$typeof === It && kc(S) === p.type) ? (w = r(p, y.props), w.ref = Ci(m, p, y), w.return = m, w) : (w = wo(y.type, y.key, y.props, null, m.mode, w), w.ref = Ci(m, p, y), w.return = m, w) } function u(m, p, y, w) { return p === null || p.tag !== 4 || p.stateNode.containerInfo !== y.containerInfo || p.stateNode.implementation !== y.implementation ? (p = el(y, m.mode, w), p.return = m, p) : (p = r(p, y.children || []), p.return = m, p) } function d(m, p, y, w, S) { return p === null || p.tag !== 7 ? (p = Sn(y, m.mode, w, S), p.return = m, p) : (p = r(p, y), p.return = m, p) } function f(m, p, y) { if (typeof p == "string" && p !== "" || typeof p == "number") return p = Js("" + p, m.mode, y), p.return = m, p; if (typeof p == "object" && p !== null) { switch (p.$$typeof) { case Lr: return y = wo(p.type, p.key, p.props, null, m.mode, y), y.ref = Ci(m, null, p), y.return = m, y; case Bn: return p = el(p, m.mode, y), p.return = m, p; case It: var w = p._init; return f(m, w(p._payload), y) }if (Ni(p) || wi(p)) return p = Sn(p, m.mode, y, null), p.return = m, p; Ur(m, p) } return null } function c(m, p, y, w) { var S = p !== null ? p.key : null; if (typeof y == "string" && y !== "" || typeof y == "number") return S !== null ? null : l(m, p, "" + y, w); if (typeof y == "object" && y !== null) { switch (y.$$typeof) { case Lr: return y.key === S ? a(m, p, y, w) : null; case Bn: return y.key === S ? u(m, p, y, w) : null; case It: return S = y._init, c(m, p, S(y._payload), w) }if (Ni(y) || wi(y)) return S !== null ? null : d(m, p, y, w, null); Ur(m, y) } return null } function h(m, p, y, w, S) { if (typeof w == "string" && w !== "" || typeof w == "number") return m = m.get(y) || null, l(p, m, "" + w, S); if (typeof w == "object" && w !== null) { switch (w.$$typeof) { case Lr: return m = m.get(w.key === null ? y : w.key) || null, a(p, m, w, S); case Bn: return m = m.get(w.key === null ? y : w.key) || null, u(p, m, w, S); case It: var x = w._init; return h(m, p, y, x(w._payload), S) }if (Ni(w) || wi(w)) return m = m.get(y) || null, d(p, m, w, S, null); Ur(p, w) } return null } function g(m, p, y, w) { for (var S = null, x = null, k = p, b = p = 0, C = null; k !== null && b < y.length; b++) { k.index > b ? (C = k, k = null) : C = k.sibling; var P = c(m, k, y[b], w); if (P === null) { k === null && (k = C); break } t && k && P.alternate === null && e(m, k), p = o(P, p, b), x === null ? S = P : x.sibling = P, x = P, k = C } if (b === y.length) return n(m, k), J && mn(m, b), S; if (k === null) { for (; b < y.length; b++)k = f(m, y[b], w), k !== null && (p = o(k, p, b), x === null ? S = k : x.sibling = k, x = k); return J && mn(m, b), S } for (k = i(m, k); b < y.length; b++)C = h(k, m, b, y[b], w), C !== null && (t && C.alternate !== null && k.delete(C.key === null ? b : C.key), p = o(C, p, b), x === null ? S = C : x.sibling = C, x = C); return t && k.forEach(function (M) { return e(m, M) }), J && mn(m, b), S } function v(m, p, y, w) { var S = wi(y); if (typeof S != "function") throw Error(O(150)); if (y = S.call(y), y == null) throw Error(O(151)); for (var x = S = null, k = p, b = p = 0, C = null, P = y.next(); k !== null && !P.done; b++, P = y.next()) { k.index > b ? (C = k, k = null) : C = k.sibling; var M = c(m, k, P.value, w); if (M === null) { k === null && (k = C); break } t && k && M.alternate === null && e(m, k), p = o(M, p, b), x === null ? S = M : x.sibling = M, x = M, k = C } if (P.done) return n(m, k), J && mn(m, b), S; if (k === null) { for (; !P.done; b++, P = y.next())P = f(m, P.value, w), P !== null && (p = o(P, p, b), x === null ? S = P : x.sibling = P, x = P); return J && mn(m, b), S } for (k = i(m, k); !P.done; b++, P = y.next())P = h(k, m, b, P.value, w), P !== null && (t && P.alternate !== null && k.delete(P.key === null ? b : P.key), p = o(P, p, b), x === null ? S = P : x.sibling = P, x = P); return t && k.forEach(function (T) { return e(m, T) }), J && mn(m, b), S } function _(m, p, y, w) { if (typeof y == "object" && y !== null && y.type === Hn && y.key === null && (y = y.props.children), typeof y == "object" && y !== null) { switch (y.$$typeof) { case Lr: e: { for (var S = y.key, x = p; x !== null;) { if (x.key === S) { if (S = y.type, S === Hn) { if (x.tag === 7) { n(m, x.sibling), p = r(x, y.props.children), p.return = m, m = p; break e } } else if (x.elementType === S || typeof S == "object" && S !== null && S.$$typeof === It && kc(S) === x.type) { n(m, x.sibling), p = r(x, y.props), p.ref = Ci(m, x, y), p.return = m, m = p; break e } n(m, x); break } else e(m, x); x = x.sibling } y.type === Hn ? (p = Sn(y.props.children, m.mode, w, y.key), p.return = m, m = p) : (w = wo(y.type, y.key, y.props, null, m.mode, w), w.ref = Ci(m, p, y), w.return = m, m = w) } return s(m); case Bn: e: { for (x = y.key; p !== null;) { if (p.key === x) if (p.tag === 4 && p.stateNode.containerInfo === y.containerInfo && p.stateNode.implementation === y.implementation) { n(m, p.sibling), p = r(p, y.children || []), p.return = m, m = p; break e } else { n(m, p); break } else e(m, p); p = p.sibling } p = el(y, m.mode, w), p.return = m, m = p } return s(m); case It: return x = y._init, _(m, p, x(y._payload), w) }if (Ni(y)) return g(m, p, y, w); if (wi(y)) return v(m, p, y, w); Ur(m, y) } return typeof y == "string" && y !== "" || typeof y == "number" ? (y = "" + y, p !== null && p.tag === 6 ? (n(m, p.sibling), p = r(p, y), p.return = m, m = p) : (n(m, p), p = Js(y, m.mode, w), p.return = m, m = p), s(m)) : n(m, p) } return _ } var di = kh(!0), bh = kh(!1), Pr = {}, wt = cn(Pr), hr = cn(Pr), pr = cn(Pr); function wn(t) { if (t === Pr) throw Error(O(174)); return t } function Ja(t, e) { switch (G(pr, e), G(hr, t), G(wt, Pr), t = e.nodeType, t) { case 9: case 11: e = (e = e.documentElement) ? e.namespaceURI : xl(null, ""); break; default: t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = xl(e, t) }q(wt), G(wt, e) } function fi() { q(wt), q(hr), q(pr) } function Sh(t) { wn(pr.current); var e = wn(wt.current), n = xl(e, t.type); e !== n && (G(hr, t), G(wt, n)) } function eu(t) { hr.current === t && (q(wt), q(hr)) } var ee = cn(0); function Wo(t) { for (var e = t; e !== null;) { if (e.tag === 13) { var n = e.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if (e.flags & 128) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return null; e = e.return } e.sibling.return = e.return, e = e.sibling } return null } var Ys = []; function tu() { for (var t = 0; t < Ys.length; t++)Ys[t]._workInProgressVersionPrimary = null; Ys.length = 0 } var mo = Nt.ReactCurrentDispatcher, Qs = Nt.ReactCurrentBatchConfig, On = 0, ne = null, ce = null, fe = null, Vo = !1, Ki = !1, gr = 0, r0 = 0; function be() { throw Error(O(321)) } function nu(t, e) { if (e === null) return !1; for (var n = 0; n < e.length && n < t.length; n++)if (!ft(t[n], e[n])) return !1; return !0 } function iu(t, e, n, i, r, o) { if (On = o, ne = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, mo.current = t === null || t.memoizedState === null ? a0 : u0, t = n(i, r), Ki) { o = 0; do { if (Ki = !1, gr = 0, 25 <= o) throw Error(O(301)); o += 1, fe = ce = null, e.updateQueue = null, mo.current = c0, t = n(i, r) } while (Ki) } if (mo.current = $o, e = ce !== null && ce.next !== null, On = 0, fe = ce = ne = null, Vo = !1, e) throw Error(O(300)); return t } function ru() { var t = gr !== 0; return gr = 0, t } function mt() { var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return fe === null ? ne.memoizedState = fe = t : fe = fe.next = t, fe } function rt() { if (ce === null) { var t = ne.alternate; t = t !== null ? t.memoizedState : null } else t = ce.next; var e = fe === null ? ne.memoizedState : fe.next; if (e !== null) fe = e, ce = t; else { if (t === null) throw Error(O(310)); ce = t, t = { memoizedState: ce.memoizedState, baseState: ce.baseState, baseQueue: ce.baseQueue, queue: ce.queue, next: null }, fe === null ? ne.memoizedState = fe = t : fe = fe.next = t } return fe } function mr(t, e) { return typeof e == "function" ? e(t) : e } function Ks(t) { var e = rt(), n = e.queue; if (n === null) throw Error(O(311)); n.lastRenderedReducer = t; var i = ce, r = i.baseQueue, o = n.pending; if (o !== null) { if (r !== null) { var s = r.next; r.next = o.next, o.next = s } i.baseQueue = r = o, n.pending = null } if (r !== null) { o = r.next, i = i.baseState; var l = s = null, a = null, u = o; do { var d = u.lane; if ((On & d) === d) a !== null && (a = a.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), i = u.hasEagerState ? u.eagerState : t(i, u.action); else { var f = { lane: d, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; a === null ? (l = a = f, s = i) : a = a.next = f, ne.lanes |= d, Mn |= d } u = u.next } while (u !== null && u !== o); a === null ? s = i : a.next = l, ft(i, e.memoizedState) || (Ne = !0), e.memoizedState = i, e.baseState = s, e.baseQueue = a, n.lastRenderedState = i } if (t = n.interleaved, t !== null) { r = t; do o = r.lane, ne.lanes |= o, Mn |= o, r = r.next; while (r !== t) } else r === null && (n.lanes = 0); return [e.memoizedState, n.dispatch] } function Gs(t) { var e = rt(), n = e.queue; if (n === null) throw Error(O(311)); n.lastRenderedReducer = t; var i = n.dispatch, r = n.pending, o = e.memoizedState; if (r !== null) { n.pending = null; var s = r = r.next; do o = t(o, s.action), s = s.next; while (s !== r); ft(o, e.memoizedState) || (Ne = !0), e.memoizedState = o, e.baseQueue === null && (e.baseState = o), n.lastRenderedState = o } return [o, i] } function Eh() { } function Ch(t, e) { var n = ne, i = rt(), r = e(), o = !ft(i.memoizedState, r); if (o && (i.memoizedState = r, Ne = !0), i = i.queue, ou(Mh.bind(null, n, i, t), [t]), i.getSnapshot !== e || o || fe !== null && fe.memoizedState.tag & 1) { if (n.flags |= 2048, vr(9, Oh.bind(null, n, i, r, e), void 0, null), pe === null) throw Error(O(349)); On & 30 || Ph(n, e, r) } return r } function Ph(t, e, n) { t.flags |= 16384, t = { getSnapshot: e, value: n }, e = ne.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, ne.updateQueue = e, e.stores = [t]) : (n = e.stores, n === null ? e.stores = [t] : n.push(t)) } function Oh(t, e, n, i) { e.value = n, e.getSnapshot = i, Th(e) && Rh(t) } function Mh(t, e, n) { return n(function () { Th(e) && Rh(t) }) } function Th(t) { var e = t.getSnapshot; t = t.value; try { var n = e(); return !ft(t, n) } catch { return !0 } } function Rh(t) { var e = Lt(t, 1); e !== null && dt(e, t, 1, -1) } function bc(t) { var e = mt(); return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: mr, lastRenderedState: t }, e.queue = t, t = t.dispatch = l0.bind(null, ne, t), [e.memoizedState, t] } function vr(t, e, n, i) { return t = { tag: t, create: e, destroy: n, deps: i, next: null }, e = ne.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, ne.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (i = n.next, n.next = t, t.next = i, e.lastEffect = t)), t } function Ah() { return rt().memoizedState } function vo(t, e, n, i) { var r = mt(); ne.flags |= t, r.memoizedState = vr(1 | e, n, void 0, i === void 0 ? null : i) } function ys(t, e, n, i) { var r = rt(); i = i === void 0 ? null : i; var o = void 0; if (ce !== null) { var s = ce.memoizedState; if (o = s.destroy, i !== null && nu(i, s.deps)) { r.memoizedState = vr(e, n, o, i); return } } ne.flags |= t, r.memoizedState = vr(1 | e, n, o, i) } function Sc(t, e) { return vo(8390656, 8, t, e) } function ou(t, e) { return ys(2048, 8, t, e) } function jh(t, e) { return ys(4, 2, t, e) } function Lh(t, e) { return ys(4, 4, t, e) } function Dh(t, e) { if (typeof e == "function") return t = t(), e(t), function () { e(null) }; if (e != null) return t = t(), e.current = t, function () { e.current = null } } function Nh(t, e, n) { return n = n != null ? n.concat([t]) : null, ys(4, 4, Dh.bind(null, e, t), n) } function su() { } function zh(t, e) { var n = rt(); e = e === void 0 ? null : e; var i = n.memoizedState; return i !== null && e !== null && nu(e, i[1]) ? i[0] : (n.memoizedState = [t, e], t) } function Ih(t, e) { var n = rt(); e = e === void 0 ? null : e; var i = n.memoizedState; return i !== null && e !== null && nu(e, i[1]) ? i[0] : (t = t(), n.memoizedState = [t, e], t) } function Fh(t, e, n) { return On & 21 ? (ft(n, e) || (n = Wf(), ne.lanes |= n, Mn |= n, t.baseState = !0), e) : (t.baseState && (t.baseState = !1, Ne = !0), t.memoizedState = n) } function o0(t, e) { var n = X; X = n !== 0 && 4 > n ? n : 4, t(!0); var i = Qs.transition; Qs.transition = {}; try { t(!1), e() } finally { X = n, Qs.transition = i } } function Bh() { return rt().memoizedState } function s0(t, e, n) { var i = tn(t); if (n = { lane: i, action: n, hasEagerState: !1, eagerState: null, next: null }, Hh(t)) Wh(e, n); else if (n = yh(t, e, n, i), n !== null) { var r = Me(); dt(n, t, i, r), Vh(n, e, i) } } function l0(t, e, n) { var i = tn(t), r = { lane: i, action: n, hasEagerState: !1, eagerState: null, next: null }; if (Hh(t)) Wh(e, r); else { var o = t.alternate; if (t.lanes === 0 && (o === null || o.lanes === 0) && (o = e.lastRenderedReducer, o !== null)) try { var s = e.lastRenderedState, l = o(s, n); if (r.hasEagerState = !0, r.eagerState = l, ft(l, s)) { var a = e.interleaved; a === null ? (r.next = r, Za(e)) : (r.next = a.next, a.next = r), e.interleaved = r; return } } catch { } finally { } n = yh(t, e, r, i), n !== null && (r = Me(), dt(n, t, i, r), Vh(n, e, i)) } } function Hh(t) { var e = t.alternate; return t === ne || e !== null && e === ne } function Wh(t, e) { Ki = Vo = !0; var n = t.pending; n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e } function Vh(t, e, n) { if (n & 4194240) { var i = e.lanes; i &= t.pendingLanes, n |= i, e.lanes = n, za(t, n) } } var $o = { readContext: it, useCallback: be, useContext: be, useEffect: be, useImperativeHandle: be, useInsertionEffect: be, useLayoutEffect: be, useMemo: be, useReducer: be, useRef: be, useState: be, useDebugValue: be, useDeferredValue: be, useTransition: be, useMutableSource: be, useSyncExternalStore: be, useId: be, unstable_isNewReconciler: !1 }, a0 = { readContext: it, useCallback: function (t, e) { return mt().memoizedState = [t, e === void 0 ? null : e], t }, useContext: it, useEffect: Sc, useImperativeHandle: function (t, e, n) { return n = n != null ? n.concat([t]) : null, vo(4194308, 4, Dh.bind(null, e, t), n) }, useLayoutEffect: function (t, e) { return vo(4194308, 4, t, e) }, useInsertionEffect: function (t, e) { return vo(4, 2, t, e) }, useMemo: function (t, e) { var n = mt(); return e = e === void 0 ? null : e, t = t(), n.memoizedState = [t, e], t }, useReducer: function (t, e, n) { var i = mt(); return e = n !== void 0 ? n(e) : e, i.memoizedState = i.baseState = e, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: t, lastRenderedState: e }, i.queue = t, t = t.dispatch = s0.bind(null, ne, t), [i.memoizedState, t] }, useRef: function (t) { var e = mt(); return t = { current: t }, e.memoizedState = t }, useState: bc, useDebugValue: su, useDeferredValue: function (t) { return mt().memoizedState = t }, useTransition: function () { var t = bc(!1), e = t[0]; return t = o0.bind(null, t[1]), mt().memoizedState = t, [e, t] }, useMutableSource: function () { }, useSyncExternalStore: function (t, e, n) { var i = ne, r = mt(); if (J) { if (n === void 0) throw Error(O(407)); n = n() } else { if (n = e(), pe === null) throw Error(O(349)); On & 30 || Ph(i, e, n) } r.memoizedState = n; var o = { value: n, getSnapshot: e }; return r.queue = o, Sc(Mh.bind(null, i, o, t), [t]), i.flags |= 2048, vr(9, Oh.bind(null, i, o, n, e), void 0, null), n }, useId: function () { var t = mt(), e = pe.identifierPrefix; if (J) { var n = Tt, i = Mt; n = (i & ~(1 << 32 - ct(i) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = gr++, 0 < n && (e += "H" + n.toString(32)), e += ":" } else n = r0++, e = ":" + e + "r" + n.toString(32) + ":"; return t.memoizedState = e }, unstable_isNewReconciler: !1 }, u0 = { readContext: it, useCallback: zh, useContext: it, useEffect: ou, useImperativeHandle: Nh, useInsertionEffect: jh, useLayoutEffect: Lh, useMemo: Ih, useReducer: Ks, useRef: Ah, useState: function () { return Ks(mr) }, useDebugValue: su, useDeferredValue: function (t) { var e = rt(); return Fh(e, ce.memoizedState, t) }, useTransition: function () { var t = Ks(mr)[0], e = rt().memoizedState; return [t, e] }, useMutableSource: Eh, useSyncExternalStore: Ch, useId: Bh, unstable_isNewReconciler: !1 }, c0 = { readContext: it, useCallback: zh, useContext: it, useEffect: ou, useImperativeHandle: Nh, useInsertionEffect: jh, useLayoutEffect: Lh, useMemo: Ih, useReducer: Gs, useRef: Ah, useState: function () { return Gs(mr) }, useDebugValue: su, useDeferredValue: function (t) { var e = rt(); return ce === null ? e.memoizedState = t : Fh(e, ce.memoizedState, t) }, useTransition: function () { var t = Gs(mr)[0], e = rt().memoizedState; return [t, e] }, useMutableSource: Eh, useSyncExternalStore: Ch, useId: Bh, unstable_isNewReconciler: !1 }; function hi(t, e) {
  try { var n = "", i = e; do n += Ig(i), i = i.return; while (i); var r = n } catch (o) {
    r = `
Error generating stack: `+ o.message + `
`+ o.stack
  } return { value: t, source: e, stack: r, digest: null }
} function Zs(t, e, n) { return { value: t, source: null, stack: n ?? null, digest: e ?? null } } function Wl(t, e) { try { console.error(e.value) } catch (n) { setTimeout(function () { throw n }) } } var d0 = typeof WeakMap == "function" ? WeakMap : Map; function $h(t, e, n) { n = Rt(-1, n), n.tag = 3, n.payload = { element: null }; var i = e.value; return n.callback = function () { Xo || (Xo = !0, ql = i), Wl(t, e) }, n } function Uh(t, e, n) { n = Rt(-1, n), n.tag = 3; var i = t.type.getDerivedStateFromError; if (typeof i == "function") { var r = e.value; n.payload = function () { return i(r) }, n.callback = function () { Wl(t, e) } } var o = t.stateNode; return o !== null && typeof o.componentDidCatch == "function" && (n.callback = function () { Wl(t, e), typeof i != "function" && (en === null ? en = new Set([this]) : en.add(this)); var s = e.stack; this.componentDidCatch(e.value, { componentStack: s !== null ? s : "" }) }), n } function Ec(t, e, n) { var i = t.pingCache; if (i === null) { i = t.pingCache = new d0; var r = new Set; i.set(e, r) } else r = i.get(e), r === void 0 && (r = new Set, i.set(e, r)); r.has(n) || (r.add(n), t = E0.bind(null, t, e, n), e.then(t, t)) } function Cc(t) { do { var e; if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t; t = t.return } while (t !== null); return null } function Pc(t, e, n, i, r) { return t.mode & 1 ? (t.flags |= 65536, t.lanes = r, t) : (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = Rt(-1, 1), e.tag = 2, Jt(n, e, 1))), n.lanes |= 1), t) } var f0 = Nt.ReactCurrentOwner, Ne = !1; function Pe(t, e, n, i) { e.child = t === null ? bh(e, null, n, i) : di(e, t.child, n, i) } function Oc(t, e, n, i, r) { n = n.render; var o = e.ref; return ii(e, r), i = iu(t, e, n, i, o, r), n = ru(), t !== null && !Ne ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~r, Dt(t, e, r)) : (J && n && Ua(e), e.flags |= 1, Pe(t, e, i, r), e.child) } function Mc(t, e, n, i, r) { if (t === null) { var o = n.type; return typeof o == "function" && !pu(o) && o.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = o, Xh(t, e, o, i, r)) : (t = wo(n.type, null, i, e, e.mode, r), t.ref = e.ref, t.return = e, e.child = t) } if (o = t.child, !(t.lanes & r)) { var s = o.memoizedProps; if (n = n.compare, n = n !== null ? n : ur, n(s, i) && t.ref === e.ref) return Dt(t, e, r) } return e.flags |= 1, t = nn(o, i), t.ref = e.ref, t.return = e, e.child = t } function Xh(t, e, n, i, r) { if (t !== null) { var o = t.memoizedProps; if (ur(o, i) && t.ref === e.ref) if (Ne = !1, e.pendingProps = i = o, (t.lanes & r) !== 0) t.flags & 131072 && (Ne = !0); else return e.lanes = t.lanes, Dt(t, e, r) } return Vl(t, e, n, i, r) } function Yh(t, e, n) { var i = e.pendingProps, r = i.children, o = t !== null ? t.memoizedState : null; if (i.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(Zn, $e), $e |= n; else { if (!(n & 1073741824)) return t = o !== null ? o.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: t, cachePool: null, transitions: null }, e.updateQueue = null, G(Zn, $e), $e |= t, null; e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, i = o !== null ? o.baseLanes : n, G(Zn, $e), $e |= i } else o !== null ? (i = o.baseLanes | n, e.memoizedState = null) : i = n, G(Zn, $e), $e |= i; return Pe(t, e, r, n), e.child } function Qh(t, e) { var n = e.ref; (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152) } function Vl(t, e, n, i, r) { var o = Ie(n) ? Cn : Ce.current; return o = ui(e, o), ii(e, r), n = iu(t, e, n, i, o, r), i = ru(), t !== null && !Ne ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~r, Dt(t, e, r)) : (J && i && Ua(e), e.flags |= 1, Pe(t, e, n, r), e.child) } function Tc(t, e, n, i, r) { if (Ie(n)) { var o = !0; No(e) } else o = !1; if (ii(e, r), e.stateNode === null) yo(t, e), wh(e, n, i), Hl(e, n, i, r), i = !0; else if (t === null) { var s = e.stateNode, l = e.memoizedProps; s.props = l; var a = s.context, u = n.contextType; typeof u == "object" && u !== null ? u = it(u) : (u = Ie(n) ? Cn : Ce.current, u = ui(e, u)); var d = n.getDerivedStateFromProps, f = typeof d == "function" || typeof s.getSnapshotBeforeUpdate == "function"; f || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (l !== i || a !== u) && wc(e, s, i, u), Ft = !1; var c = e.memoizedState; s.state = c, Ho(e, i, s, r), a = e.memoizedState, l !== i || c !== a || ze.current || Ft ? (typeof d == "function" && (Bl(e, n, d, i), a = e.memoizedState), (l = Ft || _c(e, n, l, i, c, a, u)) ? (f || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = i, e.memoizedState = a), s.props = i, s.state = a, s.context = u, i = l) : (typeof s.componentDidMount == "function" && (e.flags |= 4194308), i = !1) } else { s = e.stateNode, xh(t, e), l = e.memoizedProps, u = e.type === e.elementType ? l : lt(e.type, l), s.props = u, f = e.pendingProps, c = s.context, a = n.contextType, typeof a == "object" && a !== null ? a = it(a) : (a = Ie(n) ? Cn : Ce.current, a = ui(e, a)); var h = n.getDerivedStateFromProps; (d = typeof h == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (l !== f || c !== a) && wc(e, s, i, a), Ft = !1, c = e.memoizedState, s.state = c, Ho(e, i, s, r); var g = e.memoizedState; l !== f || c !== g || ze.current || Ft ? (typeof h == "function" && (Bl(e, n, h, i), g = e.memoizedState), (u = Ft || _c(e, n, u, i, c, g, a) || !1) ? (d || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(i, g, a), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(i, g, a)), typeof s.componentDidUpdate == "function" && (e.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || l === t.memoizedProps && c === t.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || l === t.memoizedProps && c === t.memoizedState || (e.flags |= 1024), e.memoizedProps = i, e.memoizedState = g), s.props = i, s.state = g, s.context = a, i = u) : (typeof s.componentDidUpdate != "function" || l === t.memoizedProps && c === t.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || l === t.memoizedProps && c === t.memoizedState || (e.flags |= 1024), i = !1) } return $l(t, e, n, i, o, r) } function $l(t, e, n, i, r, o) { Qh(t, e); var s = (e.flags & 128) !== 0; if (!i && !s) return r && gc(e, n, !1), Dt(t, e, o); i = e.stateNode, f0.current = e; var l = s && typeof n.getDerivedStateFromError != "function" ? null : i.render(); return e.flags |= 1, t !== null && s ? (e.child = di(e, t.child, null, o), e.child = di(e, null, l, o)) : Pe(t, e, l, o), e.memoizedState = i.state, r && gc(e, n, !0), e.child } function Kh(t) { var e = t.stateNode; e.pendingContext ? pc(t, e.pendingContext, e.pendingContext !== e.context) : e.context && pc(t, e.context, !1), Ja(t, e.containerInfo) } function Rc(t, e, n, i, r) { return ci(), Ya(r), e.flags |= 256, Pe(t, e, n, i), e.child } var Ul = { dehydrated: null, treeContext: null, retryLane: 0 }; function Xl(t) { return { baseLanes: t, cachePool: null, transitions: null } } function Gh(t, e, n) { var i = e.pendingProps, r = ee.current, o = !1, s = (e.flags & 128) !== 0, l; if ((l = s) || (l = t !== null && t.memoizedState === null ? !1 : (r & 2) !== 0), l ? (o = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (r |= 1), G(ee, r & 1), t === null) return Il(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (s = i.children, t = i.fallback, o ? (i = e.mode, o = e.child, s = { mode: "hidden", children: s }, !(i & 1) && o !== null ? (o.childLanes = 0, o.pendingProps = s) : o = ws(s, i, 0, null), t = Sn(t, i, n, null), o.return = e, t.return = e, o.sibling = t, e.child = o, e.child.memoizedState = Xl(n), e.memoizedState = Ul, t) : lu(e, s)); if (r = t.memoizedState, r !== null && (l = r.dehydrated, l !== null)) return h0(t, e, s, i, l, r, n); if (o) { o = i.fallback, s = e.mode, r = t.child, l = r.sibling; var a = { mode: "hidden", children: i.children }; return !(s & 1) && e.child !== r ? (i = e.child, i.childLanes = 0, i.pendingProps = a, e.deletions = null) : (i = nn(r, a), i.subtreeFlags = r.subtreeFlags & 14680064), l !== null ? o = nn(l, o) : (o = Sn(o, s, n, null), o.flags |= 2), o.return = e, i.return = e, i.sibling = o, e.child = i, i = o, o = e.child, s = t.child.memoizedState, s = s === null ? Xl(n) : { baseLanes: s.baseLanes | n, cachePool: null, transitions: s.transitions }, o.memoizedState = s, o.childLanes = t.childLanes & ~n, e.memoizedState = Ul, i } return o = t.child, t = o.sibling, i = nn(o, { mode: "visible", children: i.children }), !(e.mode & 1) && (i.lanes = n), i.return = e, i.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [t], e.flags |= 16) : n.push(t)), e.child = i, e.memoizedState = null, i } function lu(t, e) { return e = ws({ mode: "visible", children: e }, t.mode, 0, null), e.return = t, t.child = e } function Xr(t, e, n, i) { return i !== null && Ya(i), di(e, t.child, null, n), t = lu(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t } function h0(t, e, n, i, r, o, s) { if (n) return e.flags & 256 ? (e.flags &= -257, i = Zs(Error(O(422))), Xr(t, e, s, i)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (o = i.fallback, r = e.mode, i = ws({ mode: "visible", children: i.children }, r, 0, null), o = Sn(o, r, s, null), o.flags |= 2, i.return = e, o.return = e, i.sibling = o, e.child = i, e.mode & 1 && di(e, t.child, null, s), e.child.memoizedState = Xl(s), e.memoizedState = Ul, o); if (!(e.mode & 1)) return Xr(t, e, s, null); if (r.data === "$!") { if (i = r.nextSibling && r.nextSibling.dataset, i) var l = i.dgst; return i = l, o = Error(O(419)), i = Zs(o, i, void 0), Xr(t, e, s, i) } if (l = (s & t.childLanes) !== 0, Ne || l) { if (i = pe, i !== null) { switch (s & -s) { case 4: r = 2; break; case 16: r = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: r = 32; break; case 536870912: r = 268435456; break; default: r = 0 }r = r & (i.suspendedLanes | s) ? 0 : r, r !== 0 && r !== o.retryLane && (o.retryLane = r, Lt(t, r), dt(i, t, r, -1)) } return hu(), i = Zs(Error(O(421))), Xr(t, e, s, i) } return r.data === "$?" ? (e.flags |= 128, e.child = t.child, e = C0.bind(null, t), r._reactRetry = e, null) : (t = o.treeContext, Ue = qt(r.nextSibling), Xe = e, J = !0, ut = null, t !== null && (qe[Je++] = Mt, qe[Je++] = Tt, qe[Je++] = Pn, Mt = t.id, Tt = t.overflow, Pn = e), e = lu(e, i.children), e.flags |= 4096, e) } function Ac(t, e, n) { t.lanes |= e; var i = t.alternate; i !== null && (i.lanes |= e), Fl(t.return, e, n) } function qs(t, e, n, i, r) { var o = t.memoizedState; o === null ? t.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: i, tail: n, tailMode: r } : (o.isBackwards = e, o.rendering = null, o.renderingStartTime = 0, o.last = i, o.tail = n, o.tailMode = r) } function Zh(t, e, n) { var i = e.pendingProps, r = i.revealOrder, o = i.tail; if (Pe(t, e, i.children, n), i = ee.current, i & 2) i = i & 1 | 2, e.flags |= 128; else { if (t !== null && t.flags & 128) e: for (t = e.child; t !== null;) { if (t.tag === 13) t.memoizedState !== null && Ac(t, n, e); else if (t.tag === 19) Ac(t, n, e); else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break e; for (; t.sibling === null;) { if (t.return === null || t.return === e) break e; t = t.return } t.sibling.return = t.return, t = t.sibling } i &= 1 } if (G(ee, i), !(e.mode & 1)) e.memoizedState = null; else switch (r) { case "forwards": for (n = e.child, r = null; n !== null;)t = n.alternate, t !== null && Wo(t) === null && (r = n), n = n.sibling; n = r, n === null ? (r = e.child, e.child = null) : (r = n.sibling, n.sibling = null), qs(e, !1, r, n, o); break; case "backwards": for (n = null, r = e.child, e.child = null; r !== null;) { if (t = r.alternate, t !== null && Wo(t) === null) { e.child = r; break } t = r.sibling, r.sibling = n, n = r, r = t } qs(e, !0, n, null, o); break; case "together": qs(e, !1, null, null, void 0); break; default: e.memoizedState = null }return e.child } function yo(t, e) { !(e.mode & 1) && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2) } function Dt(t, e, n) { if (t !== null && (e.dependencies = t.dependencies), Mn |= e.lanes, !(n & e.childLanes)) return null; if (t !== null && e.child !== t.child) throw Error(O(153)); if (e.child !== null) { for (t = e.child, n = nn(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null;)t = t.sibling, n = n.sibling = nn(t, t.pendingProps), n.return = e; n.sibling = null } return e.child } function p0(t, e, n) { switch (e.tag) { case 3: Kh(e), ci(); break; case 5: Sh(e); break; case 1: Ie(e.type) && No(e); break; case 4: Ja(e, e.stateNode.containerInfo); break; case 10: var i = e.type._context, r = e.memoizedProps.value; G(Fo, i._currentValue), i._currentValue = r; break; case 13: if (i = e.memoizedState, i !== null) return i.dehydrated !== null ? (G(ee, ee.current & 1), e.flags |= 128, null) : n & e.child.childLanes ? Gh(t, e, n) : (G(ee, ee.current & 1), t = Dt(t, e, n), t !== null ? t.sibling : null); G(ee, ee.current & 1); break; case 19: if (i = (n & e.childLanes) !== 0, t.flags & 128) { if (i) return Zh(t, e, n); e.flags |= 128 } if (r = e.memoizedState, r !== null && (r.rendering = null, r.tail = null, r.lastEffect = null), G(ee, ee.current), i) break; return null; case 22: case 23: return e.lanes = 0, Yh(t, e, n) }return Dt(t, e, n) } var qh, Yl, Jh, ep; qh = function (t, e) { for (var n = e.child; n !== null;) { if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; Yl = function () { }; Jh = function (t, e, n, i) { var r = t.memoizedProps; if (r !== i) { t = e.stateNode, wn(wt.current); var o = null; switch (n) { case "input": r = gl(t, r), i = gl(t, i), o = []; break; case "select": r = ie({}, r, { value: void 0 }), i = ie({}, i, { value: void 0 }), o = []; break; case "textarea": r = yl(t, r), i = yl(t, i), o = []; break; default: typeof r.onClick != "function" && typeof i.onClick == "function" && (t.onclick = Lo) }_l(n, i); var s; n = null; for (u in r) if (!i.hasOwnProperty(u) && r.hasOwnProperty(u) && r[u] != null) if (u === "style") { var l = r[u]; for (s in l) l.hasOwnProperty(s) && (n || (n = {}), n[s] = "") } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (nr.hasOwnProperty(u) ? o || (o = []) : (o = o || []).push(u, null)); for (u in i) { var a = i[u]; if (l = r != null ? r[u] : void 0, i.hasOwnProperty(u) && a !== l && (a != null || l != null)) if (u === "style") if (l) { for (s in l) !l.hasOwnProperty(s) || a && a.hasOwnProperty(s) || (n || (n = {}), n[s] = ""); for (s in a) a.hasOwnProperty(s) && l[s] !== a[s] && (n || (n = {}), n[s] = a[s]) } else n || (o || (o = []), o.push(u, n)), n = a; else u === "dangerouslySetInnerHTML" ? (a = a ? a.__html : void 0, l = l ? l.__html : void 0, a != null && l !== a && (o = o || []).push(u, a)) : u === "children" ? typeof a != "string" && typeof a != "number" || (o = o || []).push(u, "" + a) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (nr.hasOwnProperty(u) ? (a != null && u === "onScroll" && Z("scroll", t), o || l === a || (o = [])) : (o = o || []).push(u, a)) } n && (o = o || []).push("style", n); var u = o; (e.updateQueue = u) && (e.flags |= 4) } }; ep = function (t, e, n, i) { n !== i && (e.flags |= 4) }; function Pi(t, e) { if (!J) switch (t.tailMode) { case "hidden": e = t.tail; for (var n = null; e !== null;)e.alternate !== null && (n = e), e = e.sibling; n === null ? t.tail = null : n.sibling = null; break; case "collapsed": n = t.tail; for (var i = null; n !== null;)n.alternate !== null && (i = n), n = n.sibling; i === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : i.sibling = null } } function Se(t) { var e = t.alternate !== null && t.alternate.child === t.child, n = 0, i = 0; if (e) for (var r = t.child; r !== null;)n |= r.lanes | r.childLanes, i |= r.subtreeFlags & 14680064, i |= r.flags & 14680064, r.return = t, r = r.sibling; else for (r = t.child; r !== null;)n |= r.lanes | r.childLanes, i |= r.subtreeFlags, i |= r.flags, r.return = t, r = r.sibling; return t.subtreeFlags |= i, t.childLanes = n, e } function g0(t, e, n) { var i = e.pendingProps; switch (Xa(e), e.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Se(e), null; case 1: return Ie(e.type) && Do(), Se(e), null; case 3: return i = e.stateNode, fi(), q(ze), q(Ce), tu(), i.pendingContext && (i.context = i.pendingContext, i.pendingContext = null), (t === null || t.child === null) && ($r(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, ut !== null && (ta(ut), ut = null))), Yl(t, e), Se(e), null; case 5: eu(e); var r = wn(pr.current); if (n = e.type, t !== null && e.stateNode != null) Jh(t, e, n, i, r), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152); else { if (!i) { if (e.stateNode === null) throw Error(O(166)); return Se(e), null } if (t = wn(wt.current), $r(e)) { i = e.stateNode, n = e.type; var o = e.memoizedProps; switch (i[xt] = e, i[fr] = o, t = (e.mode & 1) !== 0, n) { case "dialog": Z("cancel", i), Z("close", i); break; case "iframe": case "object": case "embed": Z("load", i); break; case "video": case "audio": for (r = 0; r < Ii.length; r++)Z(Ii[r], i); break; case "source": Z("error", i); break; case "img": case "image": case "link": Z("error", i), Z("load", i); break; case "details": Z("toggle", i); break; case "input": Hu(i, o), Z("invalid", i); break; case "select": i._wrapperState = { wasMultiple: !!o.multiple }, Z("invalid", i); break; case "textarea": Vu(i, o), Z("invalid", i) }_l(n, o), r = null; for (var s in o) if (o.hasOwnProperty(s)) { var l = o[s]; s === "children" ? typeof l == "string" ? i.textContent !== l && (o.suppressHydrationWarning !== !0 && Vr(i.textContent, l, t), r = ["children", l]) : typeof l == "number" && i.textContent !== "" + l && (o.suppressHydrationWarning !== !0 && Vr(i.textContent, l, t), r = ["children", "" + l]) : nr.hasOwnProperty(s) && l != null && s === "onScroll" && Z("scroll", i) } switch (n) { case "input": Dr(i), Wu(i, o, !0); break; case "textarea": Dr(i), $u(i); break; case "select": case "option": break; default: typeof o.onClick == "function" && (i.onclick = Lo) }i = r, e.updateQueue = i, i !== null && (e.flags |= 4) } else { s = r.nodeType === 9 ? r : r.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = Pf(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = s.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof i.is == "string" ? t = s.createElement(n, { is: i.is }) : (t = s.createElement(n), n === "select" && (s = t, i.multiple ? s.multiple = !0 : i.size && (s.size = i.size))) : t = s.createElementNS(t, n), t[xt] = e, t[fr] = i, qh(t, e, !1, !1), e.stateNode = t; e: { switch (s = wl(n, i), n) { case "dialog": Z("cancel", t), Z("close", t), r = i; break; case "iframe": case "object": case "embed": Z("load", t), r = i; break; case "video": case "audio": for (r = 0; r < Ii.length; r++)Z(Ii[r], t); r = i; break; case "source": Z("error", t), r = i; break; case "img": case "image": case "link": Z("error", t), Z("load", t), r = i; break; case "details": Z("toggle", t), r = i; break; case "input": Hu(t, i), r = gl(t, i), Z("invalid", t); break; case "option": r = i; break; case "select": t._wrapperState = { wasMultiple: !!i.multiple }, r = ie({}, i, { value: void 0 }), Z("invalid", t); break; case "textarea": Vu(t, i), r = yl(t, i), Z("invalid", t); break; default: r = i }_l(n, r), l = r; for (o in l) if (l.hasOwnProperty(o)) { var a = l[o]; o === "style" ? Tf(t, a) : o === "dangerouslySetInnerHTML" ? (a = a ? a.__html : void 0, a != null && Of(t, a)) : o === "children" ? typeof a == "string" ? (n !== "textarea" || a !== "") && ir(t, a) : typeof a == "number" && ir(t, "" + a) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (nr.hasOwnProperty(o) ? a != null && o === "onScroll" && Z("scroll", t) : a != null && Ra(t, o, a, s)) } switch (n) { case "input": Dr(t), Wu(t, i, !1); break; case "textarea": Dr(t), $u(t); break; case "option": i.value != null && t.setAttribute("value", "" + sn(i.value)); break; case "select": t.multiple = !!i.multiple, o = i.value, o != null ? Jn(t, !!i.multiple, o, !1) : i.defaultValue != null && Jn(t, !!i.multiple, i.defaultValue, !0); break; default: typeof r.onClick == "function" && (t.onclick = Lo) }switch (n) { case "button": case "input": case "select": case "textarea": i = !!i.autoFocus; break e; case "img": i = !0; break e; default: i = !1 } } i && (e.flags |= 4) } e.ref !== null && (e.flags |= 512, e.flags |= 2097152) } return Se(e), null; case 6: if (t && e.stateNode != null) ep(t, e, t.memoizedProps, i); else { if (typeof i != "string" && e.stateNode === null) throw Error(O(166)); if (n = wn(pr.current), wn(wt.current), $r(e)) { if (i = e.stateNode, n = e.memoizedProps, i[xt] = e, (o = i.nodeValue !== n) && (t = Xe, t !== null)) switch (t.tag) { case 3: Vr(i.nodeValue, n, (t.mode & 1) !== 0); break; case 5: t.memoizedProps.suppressHydrationWarning !== !0 && Vr(i.nodeValue, n, (t.mode & 1) !== 0) }o && (e.flags |= 4) } else i = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(i), i[xt] = e, e.stateNode = i } return Se(e), null; case 13: if (q(ee), i = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) { if (J && Ue !== null && e.mode & 1 && !(e.flags & 128)) vh(), ci(), e.flags |= 98560, o = !1; else if (o = $r(e), i !== null && i.dehydrated !== null) { if (t === null) { if (!o) throw Error(O(318)); if (o = e.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(O(317)); o[xt] = e } else ci(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4; Se(e), o = !1 } else ut !== null && (ta(ut), ut = null), o = !0; if (!o) return e.flags & 65536 ? e : null } return e.flags & 128 ? (e.lanes = n, e) : (i = i !== null, i !== (t !== null && t.memoizedState !== null) && i && (e.child.flags |= 8192, e.mode & 1 && (t === null || ee.current & 1 ? de === 0 && (de = 3) : hu())), e.updateQueue !== null && (e.flags |= 4), Se(e), null); case 4: return fi(), Yl(t, e), t === null && cr(e.stateNode.containerInfo), Se(e), null; case 10: return Ga(e.type._context), Se(e), null; case 17: return Ie(e.type) && Do(), Se(e), null; case 19: if (q(ee), o = e.memoizedState, o === null) return Se(e), null; if (i = (e.flags & 128) !== 0, s = o.rendering, s === null) if (i) Pi(o, !1); else { if (de !== 0 || t !== null && t.flags & 128) for (t = e.child; t !== null;) { if (s = Wo(t), s !== null) { for (e.flags |= 128, Pi(o, !1), i = s.updateQueue, i !== null && (e.updateQueue = i, e.flags |= 4), e.subtreeFlags = 0, i = n, n = e.child; n !== null;)o = n, t = i, o.flags &= 14680066, s = o.alternate, s === null ? (o.childLanes = 0, o.lanes = t, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = s.childLanes, o.lanes = s.lanes, o.child = s.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = s.memoizedProps, o.memoizedState = s.memoizedState, o.updateQueue = s.updateQueue, o.type = s.type, t = s.dependencies, o.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }), n = n.sibling; return G(ee, ee.current & 1 | 2), e.child } t = t.sibling } o.tail !== null && le() > pi && (e.flags |= 128, i = !0, Pi(o, !1), e.lanes = 4194304) } else { if (!i) if (t = Wo(s), t !== null) { if (e.flags |= 128, i = !0, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), Pi(o, !0), o.tail === null && o.tailMode === "hidden" && !s.alternate && !J) return Se(e), null } else 2 * le() - o.renderingStartTime > pi && n !== 1073741824 && (e.flags |= 128, i = !0, Pi(o, !1), e.lanes = 4194304); o.isBackwards ? (s.sibling = e.child, e.child = s) : (n = o.last, n !== null ? n.sibling = s : e.child = s, o.last = s) } return o.tail !== null ? (e = o.tail, o.rendering = e, o.tail = e.sibling, o.renderingStartTime = le(), e.sibling = null, n = ee.current, G(ee, i ? n & 1 | 2 : n & 1), e) : (Se(e), null); case 22: case 23: return fu(), i = e.memoizedState !== null, t !== null && t.memoizedState !== null !== i && (e.flags |= 8192), i && e.mode & 1 ? $e & 1073741824 && (Se(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Se(e), null; case 24: return null; case 25: return null }throw Error(O(156, e.tag)) } function m0(t, e) { switch (Xa(e), e.tag) { case 1: return Ie(e.type) && Do(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 3: return fi(), q(ze), q(Ce), tu(), t = e.flags, t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128, e) : null; case 5: return eu(e), null; case 13: if (q(ee), t = e.memoizedState, t !== null && t.dehydrated !== null) { if (e.alternate === null) throw Error(O(340)); ci() } return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 19: return q(ee), null; case 4: return fi(), null; case 10: return Ga(e.type._context), null; case 22: case 23: return fu(), null; case 24: return null; default: return null } } var Yr = !1, Ee = !1, v0 = typeof WeakSet == "function" ? WeakSet : Set, A = null; function Gn(t, e) { var n = t.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (i) { re(t, e, i) } else n.current = null } function Ql(t, e, n) { try { n() } catch (i) { re(t, e, i) } } var jc = !1; function y0(t, e) { if (Rl = Ro, t = rh(), $a(t)) { if ("selectionStart" in t) var n = { start: t.selectionStart, end: t.selectionEnd }; else e: { n = (n = t.ownerDocument) && n.defaultView || window; var i = n.getSelection && n.getSelection(); if (i && i.rangeCount !== 0) { n = i.anchorNode; var r = i.anchorOffset, o = i.focusNode; i = i.focusOffset; try { n.nodeType, o.nodeType } catch { n = null; break e } var s = 0, l = -1, a = -1, u = 0, d = 0, f = t, c = null; t: for (; ;) { for (var h; f !== n || r !== 0 && f.nodeType !== 3 || (l = s + r), f !== o || i !== 0 && f.nodeType !== 3 || (a = s + i), f.nodeType === 3 && (s += f.nodeValue.length), (h = f.firstChild) !== null;)c = f, f = h; for (; ;) { if (f === t) break t; if (c === n && ++u === r && (l = s), c === o && ++d === i && (a = s), (h = f.nextSibling) !== null) break; f = c, c = f.parentNode } f = h } n = l === -1 || a === -1 ? null : { start: l, end: a } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (Al = { focusedElem: t, selectionRange: n }, Ro = !1, A = e; A !== null;)if (e = A, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, A = t; else for (; A !== null;) { e = A; try { var g = e.alternate; if (e.flags & 1024) switch (e.tag) { case 0: case 11: case 15: break; case 1: if (g !== null) { var v = g.memoizedProps, _ = g.memoizedState, m = e.stateNode, p = m.getSnapshotBeforeUpdate(e.elementType === e.type ? v : lt(e.type, v), _); m.__reactInternalSnapshotBeforeUpdate = p } break; case 3: var y = e.stateNode.containerInfo; y.nodeType === 1 ? y.textContent = "" : y.nodeType === 9 && y.documentElement && y.removeChild(y.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(O(163)) } } catch (w) { re(e, e.return, w) } if (t = e.sibling, t !== null) { t.return = e.return, A = t; break } A = e.return } return g = jc, jc = !1, g } function Gi(t, e, n) { var i = e.updateQueue; if (i = i !== null ? i.lastEffect : null, i !== null) { var r = i = i.next; do { if ((r.tag & t) === t) { var o = r.destroy; r.destroy = void 0, o !== void 0 && Ql(e, n, o) } r = r.next } while (r !== i) } } function xs(t, e) { if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) { var n = e = e.next; do { if ((n.tag & t) === t) { var i = n.create; n.destroy = i() } n = n.next } while (n !== e) } } function Kl(t) { var e = t.ref; if (e !== null) { var n = t.stateNode; switch (t.tag) { case 5: t = n; break; default: t = n }typeof e == "function" ? e(t) : e.current = t } } function tp(t) { var e = t.alternate; e !== null && (t.alternate = null, tp(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[xt], delete e[fr], delete e[Dl], delete e[e0], delete e[t0])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null } function np(t) { return t.tag === 5 || t.tag === 3 || t.tag === 4 } function Lc(t) { e: for (; ;) { for (; t.sibling === null;) { if (t.return === null || np(t.return)) return null; t = t.return } for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) { if (t.flags & 2 || t.child === null || t.tag === 4) continue e; t.child.return = t, t = t.child } if (!(t.flags & 2)) return t.stateNode } } function Gl(t, e, n) { var i = t.tag; if (i === 5 || i === 6) t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = Lo)); else if (i !== 4 && (t = t.child, t !== null)) for (Gl(t, e, n), t = t.sibling; t !== null;)Gl(t, e, n), t = t.sibling } function Zl(t, e, n) { var i = t.tag; if (i === 5 || i === 6) t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t); else if (i !== 4 && (t = t.child, t !== null)) for (Zl(t, e, n), t = t.sibling; t !== null;)Zl(t, e, n), t = t.sibling } var ge = null, at = !1; function zt(t, e, n) { for (n = n.child; n !== null;)ip(t, e, n), n = n.sibling } function ip(t, e, n) { if (_t && typeof _t.onCommitFiberUnmount == "function") try { _t.onCommitFiberUnmount(ds, n) } catch { } switch (n.tag) { case 5: Ee || Gn(n, e); case 6: var i = ge, r = at; ge = null, zt(t, e, n), ge = i, at = r, ge !== null && (at ? (t = ge, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : ge.removeChild(n.stateNode)); break; case 18: ge !== null && (at ? (t = ge, n = n.stateNode, t.nodeType === 8 ? Us(t.parentNode, n) : t.nodeType === 1 && Us(t, n), lr(t)) : Us(ge, n.stateNode)); break; case 4: i = ge, r = at, ge = n.stateNode.containerInfo, at = !0, zt(t, e, n), ge = i, at = r; break; case 0: case 11: case 14: case 15: if (!Ee && (i = n.updateQueue, i !== null && (i = i.lastEffect, i !== null))) { r = i = i.next; do { var o = r, s = o.destroy; o = o.tag, s !== void 0 && (o & 2 || o & 4) && Ql(n, e, s), r = r.next } while (r !== i) } zt(t, e, n); break; case 1: if (!Ee && (Gn(n, e), i = n.stateNode, typeof i.componentWillUnmount == "function")) try { i.props = n.memoizedProps, i.state = n.memoizedState, i.componentWillUnmount() } catch (l) { re(n, e, l) } zt(t, e, n); break; case 21: zt(t, e, n); break; case 22: n.mode & 1 ? (Ee = (i = Ee) || n.memoizedState !== null, zt(t, e, n), Ee = i) : zt(t, e, n); break; default: zt(t, e, n) } } function Dc(t) { var e = t.updateQueue; if (e !== null) { t.updateQueue = null; var n = t.stateNode; n === null && (n = t.stateNode = new v0), e.forEach(function (i) { var r = P0.bind(null, t, i); n.has(i) || (n.add(i), i.then(r, r)) }) } } function st(t, e) { var n = e.deletions; if (n !== null) for (var i = 0; i < n.length; i++) { var r = n[i]; try { var o = t, s = e, l = s; e: for (; l !== null;) { switch (l.tag) { case 5: ge = l.stateNode, at = !1; break e; case 3: ge = l.stateNode.containerInfo, at = !0; break e; case 4: ge = l.stateNode.containerInfo, at = !0; break e }l = l.return } if (ge === null) throw Error(O(160)); ip(o, s, r), ge = null, at = !1; var a = r.alternate; a !== null && (a.return = null), r.return = null } catch (u) { re(r, e, u) } } if (e.subtreeFlags & 12854) for (e = e.child; e !== null;)rp(e, t), e = e.sibling } function rp(t, e) { var n = t.alternate, i = t.flags; switch (t.tag) { case 0: case 11: case 14: case 15: if (st(e, t), pt(t), i & 4) { try { Gi(3, t, t.return), xs(3, t) } catch (v) { re(t, t.return, v) } try { Gi(5, t, t.return) } catch (v) { re(t, t.return, v) } } break; case 1: st(e, t), pt(t), i & 512 && n !== null && Gn(n, n.return); break; case 5: if (st(e, t), pt(t), i & 512 && n !== null && Gn(n, n.return), t.flags & 32) { var r = t.stateNode; try { ir(r, "") } catch (v) { re(t, t.return, v) } } if (i & 4 && (r = t.stateNode, r != null)) { var o = t.memoizedProps, s = n !== null ? n.memoizedProps : o, l = t.type, a = t.updateQueue; if (t.updateQueue = null, a !== null) try { l === "input" && o.type === "radio" && o.name != null && Ef(r, o), wl(l, s); var u = wl(l, o); for (s = 0; s < a.length; s += 2) { var d = a[s], f = a[s + 1]; d === "style" ? Tf(r, f) : d === "dangerouslySetInnerHTML" ? Of(r, f) : d === "children" ? ir(r, f) : Ra(r, d, f, u) } switch (l) { case "input": ml(r, o); break; case "textarea": Cf(r, o); break; case "select": var c = r._wrapperState.wasMultiple; r._wrapperState.wasMultiple = !!o.multiple; var h = o.value; h != null ? Jn(r, !!o.multiple, h, !1) : c !== !!o.multiple && (o.defaultValue != null ? Jn(r, !!o.multiple, o.defaultValue, !0) : Jn(r, !!o.multiple, o.multiple ? [] : "", !1)) }r[fr] = o } catch (v) { re(t, t.return, v) } } break; case 6: if (st(e, t), pt(t), i & 4) { if (t.stateNode === null) throw Error(O(162)); r = t.stateNode, o = t.memoizedProps; try { r.nodeValue = o } catch (v) { re(t, t.return, v) } } break; case 3: if (st(e, t), pt(t), i & 4 && n !== null && n.memoizedState.isDehydrated) try { lr(e.containerInfo) } catch (v) { re(t, t.return, v) } break; case 4: st(e, t), pt(t); break; case 13: st(e, t), pt(t), r = t.child, r.flags & 8192 && (o = r.memoizedState !== null, r.stateNode.isHidden = o, !o || r.alternate !== null && r.alternate.memoizedState !== null || (cu = le())), i & 4 && Dc(t); break; case 22: if (d = n !== null && n.memoizedState !== null, t.mode & 1 ? (Ee = (u = Ee) || d, st(e, t), Ee = u) : st(e, t), pt(t), i & 8192) { if (u = t.memoizedState !== null, (t.stateNode.isHidden = u) && !d && t.mode & 1) for (A = t, d = t.child; d !== null;) { for (f = A = d; A !== null;) { switch (c = A, h = c.child, c.tag) { case 0: case 11: case 14: case 15: Gi(4, c, c.return); break; case 1: Gn(c, c.return); var g = c.stateNode; if (typeof g.componentWillUnmount == "function") { i = c, n = c.return; try { e = i, g.props = e.memoizedProps, g.state = e.memoizedState, g.componentWillUnmount() } catch (v) { re(i, n, v) } } break; case 5: Gn(c, c.return); break; case 22: if (c.memoizedState !== null) { zc(f); continue } }h !== null ? (h.return = c, A = h) : zc(f) } d = d.sibling } e: for (d = null, f = t; ;) { if (f.tag === 5) { if (d === null) { d = f; try { r = f.stateNode, u ? (o = r.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (l = f.stateNode, a = f.memoizedProps.style, s = a != null && a.hasOwnProperty("display") ? a.display : null, l.style.display = Mf("display", s)) } catch (v) { re(t, t.return, v) } } } else if (f.tag === 6) { if (d === null) try { f.stateNode.nodeValue = u ? "" : f.memoizedProps } catch (v) { re(t, t.return, v) } } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === t) && f.child !== null) { f.child.return = f, f = f.child; continue } if (f === t) break e; for (; f.sibling === null;) { if (f.return === null || f.return === t) break e; d === f && (d = null), f = f.return } d === f && (d = null), f.sibling.return = f.return, f = f.sibling } } break; case 19: st(e, t), pt(t), i & 4 && Dc(t); break; case 21: break; default: st(e, t), pt(t) } } function pt(t) { var e = t.flags; if (e & 2) { try { e: { for (var n = t.return; n !== null;) { if (np(n)) { var i = n; break e } n = n.return } throw Error(O(160)) } switch (i.tag) { case 5: var r = i.stateNode; i.flags & 32 && (ir(r, ""), i.flags &= -33); var o = Lc(t); Zl(t, o, r); break; case 3: case 4: var s = i.stateNode.containerInfo, l = Lc(t); Gl(t, l, s); break; default: throw Error(O(161)) } } catch (a) { re(t, t.return, a) } t.flags &= -3 } e & 4096 && (t.flags &= -4097) } function x0(t, e, n) { A = t, op(t) } function op(t, e, n) { for (var i = (t.mode & 1) !== 0; A !== null;) { var r = A, o = r.child; if (r.tag === 22 && i) { var s = r.memoizedState !== null || Yr; if (!s) { var l = r.alternate, a = l !== null && l.memoizedState !== null || Ee; l = Yr; var u = Ee; if (Yr = s, (Ee = a) && !u) for (A = r; A !== null;)s = A, a = s.child, s.tag === 22 && s.memoizedState !== null ? Ic(r) : a !== null ? (a.return = s, A = a) : Ic(r); for (; o !== null;)A = o, op(o), o = o.sibling; A = r, Yr = l, Ee = u } Nc(t) } else r.subtreeFlags & 8772 && o !== null ? (o.return = r, A = o) : Nc(t) } } function Nc(t) { for (; A !== null;) { var e = A; if (e.flags & 8772) { var n = e.alternate; try { if (e.flags & 8772) switch (e.tag) { case 0: case 11: case 15: Ee || xs(5, e); break; case 1: var i = e.stateNode; if (e.flags & 4 && !Ee) if (n === null) i.componentDidMount(); else { var r = e.elementType === e.type ? n.memoizedProps : lt(e.type, n.memoizedProps); i.componentDidUpdate(r, n.memoizedState, i.__reactInternalSnapshotBeforeUpdate) } var o = e.updateQueue; o !== null && xc(e, o, i); break; case 3: var s = e.updateQueue; if (s !== null) { if (n = null, e.child !== null) switch (e.child.tag) { case 5: n = e.child.stateNode; break; case 1: n = e.child.stateNode }xc(e, s, n) } break; case 5: var l = e.stateNode; if (n === null && e.flags & 4) { n = l; var a = e.memoizedProps; switch (e.type) { case "button": case "input": case "select": case "textarea": a.autoFocus && n.focus(); break; case "img": a.src && (n.src = a.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (e.memoizedState === null) { var u = e.alternate; if (u !== null) { var d = u.memoizedState; if (d !== null) { var f = d.dehydrated; f !== null && lr(f) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(O(163)) }Ee || e.flags & 512 && Kl(e) } catch (c) { re(e, e.return, c) } } if (e === t) { A = null; break } if (n = e.sibling, n !== null) { n.return = e.return, A = n; break } A = e.return } } function zc(t) { for (; A !== null;) { var e = A; if (e === t) { A = null; break } var n = e.sibling; if (n !== null) { n.return = e.return, A = n; break } A = e.return } } function Ic(t) { for (; A !== null;) { var e = A; try { switch (e.tag) { case 0: case 11: case 15: var n = e.return; try { xs(4, e) } catch (a) { re(e, n, a) } break; case 1: var i = e.stateNode; if (typeof i.componentDidMount == "function") { var r = e.return; try { i.componentDidMount() } catch (a) { re(e, r, a) } } var o = e.return; try { Kl(e) } catch (a) { re(e, o, a) } break; case 5: var s = e.return; try { Kl(e) } catch (a) { re(e, s, a) } } } catch (a) { re(e, e.return, a) } if (e === t) { A = null; break } var l = e.sibling; if (l !== null) { l.return = e.return, A = l; break } A = e.return } } var _0 = Math.ceil, Uo = Nt.ReactCurrentDispatcher, au = Nt.ReactCurrentOwner, nt = Nt.ReactCurrentBatchConfig, H = 0, pe = null, ae = null, ye = 0, $e = 0, Zn = cn(0), de = 0, yr = null, Mn = 0, _s = 0, uu = 0, Zi = null, Le = null, cu = 0, pi = 1 / 0, Ct = null, Xo = !1, ql = null, en = null, Qr = !1, $t = null, Yo = 0, qi = 0, Jl = null, xo = -1, _o = 0; function Me() { return H & 6 ? le() : xo !== -1 ? xo : xo = le() } function tn(t) { return t.mode & 1 ? H & 2 && ye !== 0 ? ye & -ye : i0.transition !== null ? (_o === 0 && (_o = Wf()), _o) : (t = X, t !== 0 || (t = window.event, t = t === void 0 ? 16 : Kf(t.type)), t) : 1 } function dt(t, e, n, i) { if (50 < qi) throw qi = 0, Jl = null, Error(O(185)); Sr(t, n, i), (!(H & 2) || t !== pe) && (t === pe && (!(H & 2) && (_s |= n), de === 4 && Wt(t, ye)), Fe(t, i), n === 1 && H === 0 && !(e.mode & 1) && (pi = le() + 500, ms && dn())) } function Fe(t, e) { var n = t.callbackNode; im(t, e); var i = To(t, t === pe ? ye : 0); if (i === 0) n !== null && Yu(n), t.callbackNode = null, t.callbackPriority = 0; else if (e = i & -i, t.callbackPriority !== e) { if (n != null && Yu(n), e === 1) t.tag === 0 ? n0(Fc.bind(null, t)) : ph(Fc.bind(null, t)), qm(function () { !(H & 6) && dn() }), n = null; else { switch (Vf(i)) { case 1: n = Na; break; case 4: n = Bf; break; case 16: n = Mo; break; case 536870912: n = Hf; break; default: n = Mo }n = hp(n, sp.bind(null, t)) } t.callbackPriority = e, t.callbackNode = n } } function sp(t, e) { if (xo = -1, _o = 0, H & 6) throw Error(O(327)); var n = t.callbackNode; if (ri() && t.callbackNode !== n) return null; var i = To(t, t === pe ? ye : 0); if (i === 0) return null; if (i & 30 || i & t.expiredLanes || e) e = Qo(t, i); else { e = i; var r = H; H |= 2; var o = ap(); (pe !== t || ye !== e) && (Ct = null, pi = le() + 500, bn(t, e)); do try { b0(); break } catch (l) { lp(t, l) } while (1); Ka(), Uo.current = o, H = r, ae !== null ? e = 0 : (pe = null, ye = 0, e = de) } if (e !== 0) { if (e === 2 && (r = Cl(t), r !== 0 && (i = r, e = ea(t, r))), e === 1) throw n = yr, bn(t, 0), Wt(t, i), Fe(t, le()), n; if (e === 6) Wt(t, i); else { if (r = t.current.alternate, !(i & 30) && !w0(r) && (e = Qo(t, i), e === 2 && (o = Cl(t), o !== 0 && (i = o, e = ea(t, o))), e === 1)) throw n = yr, bn(t, 0), Wt(t, i), Fe(t, le()), n; switch (t.finishedWork = r, t.finishedLanes = i, e) { case 0: case 1: throw Error(O(345)); case 2: vn(t, Le, Ct); break; case 3: if (Wt(t, i), (i & 130023424) === i && (e = cu + 500 - le(), 10 < e)) { if (To(t, 0) !== 0) break; if (r = t.suspendedLanes, (r & i) !== i) { Me(), t.pingedLanes |= t.suspendedLanes & r; break } t.timeoutHandle = Ll(vn.bind(null, t, Le, Ct), e); break } vn(t, Le, Ct); break; case 4: if (Wt(t, i), (i & 4194240) === i) break; for (e = t.eventTimes, r = -1; 0 < i;) { var s = 31 - ct(i); o = 1 << s, s = e[s], s > r && (r = s), i &= ~o } if (i = r, i = le() - i, i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * _0(i / 1960)) - i, 10 < i) { t.timeoutHandle = Ll(vn.bind(null, t, Le, Ct), i); break } vn(t, Le, Ct); break; case 5: vn(t, Le, Ct); break; default: throw Error(O(329)) } } } return Fe(t, le()), t.callbackNode === n ? sp.bind(null, t) : null } function ea(t, e) { var n = Zi; return t.current.memoizedState.isDehydrated && (bn(t, e).flags |= 256), t = Qo(t, e), t !== 2 && (e = Le, Le = n, e !== null && ta(e)), t } function ta(t) { Le === null ? Le = t : Le.push.apply(Le, t) } function w0(t) { for (var e = t; ;) { if (e.flags & 16384) { var n = e.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var i = 0; i < n.length; i++) { var r = n[i], o = r.getSnapshot; r = r.value; try { if (!ft(o(), r)) return !1 } catch { return !1 } } } if (n = e.child, e.subtreeFlags & 16384 && n !== null) n.return = e, e = n; else { if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return !0; e = e.return } e.sibling.return = e.return, e = e.sibling } } return !0 } function Wt(t, e) { for (e &= ~uu, e &= ~_s, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) { var n = 31 - ct(e), i = 1 << n; t[n] = -1, e &= ~i } } function Fc(t) { if (H & 6) throw Error(O(327)); ri(); var e = To(t, 0); if (!(e & 1)) return Fe(t, le()), null; var n = Qo(t, e); if (t.tag !== 0 && n === 2) { var i = Cl(t); i !== 0 && (e = i, n = ea(t, i)) } if (n === 1) throw n = yr, bn(t, 0), Wt(t, e), Fe(t, le()), n; if (n === 6) throw Error(O(345)); return t.finishedWork = t.current.alternate, t.finishedLanes = e, vn(t, Le, Ct), Fe(t, le()), null } function du(t, e) { var n = H; H |= 1; try { return t(e) } finally { H = n, H === 0 && (pi = le() + 500, ms && dn()) } } function Tn(t) { $t !== null && $t.tag === 0 && !(H & 6) && ri(); var e = H; H |= 1; var n = nt.transition, i = X; try { if (nt.transition = null, X = 1, t) return t() } finally { X = i, nt.transition = n, H = e, !(H & 6) && dn() } } function fu() { $e = Zn.current, q(Zn) } function bn(t, e) { t.finishedWork = null, t.finishedLanes = 0; var n = t.timeoutHandle; if (n !== -1 && (t.timeoutHandle = -1, Zm(n)), ae !== null) for (n = ae.return; n !== null;) { var i = n; switch (Xa(i), i.tag) { case 1: i = i.type.childContextTypes, i != null && Do(); break; case 3: fi(), q(ze), q(Ce), tu(); break; case 5: eu(i); break; case 4: fi(); break; case 13: q(ee); break; case 19: q(ee); break; case 10: Ga(i.type._context); break; case 22: case 23: fu() }n = n.return } if (pe = t, ae = t = nn(t.current, null), ye = $e = e, de = 0, yr = null, uu = _s = Mn = 0, Le = Zi = null, _n !== null) { for (e = 0; e < _n.length; e++)if (n = _n[e], i = n.interleaved, i !== null) { n.interleaved = null; var r = i.next, o = n.pending; if (o !== null) { var s = o.next; o.next = r, i.next = s } n.pending = i } _n = null } return t } function lp(t, e) { do { var n = ae; try { if (Ka(), mo.current = $o, Vo) { for (var i = ne.memoizedState; i !== null;) { var r = i.queue; r !== null && (r.pending = null), i = i.next } Vo = !1 } if (On = 0, fe = ce = ne = null, Ki = !1, gr = 0, au.current = null, n === null || n.return === null) { de = 1, yr = e, ae = null; break } e: { var o = t, s = n.return, l = n, a = e; if (e = ye, l.flags |= 32768, a !== null && typeof a == "object" && typeof a.then == "function") { var u = a, d = l, f = d.tag; if (!(d.mode & 1) && (f === 0 || f === 11 || f === 15)) { var c = d.alternate; c ? (d.updateQueue = c.updateQueue, d.memoizedState = c.memoizedState, d.lanes = c.lanes) : (d.updateQueue = null, d.memoizedState = null) } var h = Cc(s); if (h !== null) { h.flags &= -257, Pc(h, s, l, o, e), h.mode & 1 && Ec(o, u, e), e = h, a = u; var g = e.updateQueue; if (g === null) { var v = new Set; v.add(a), e.updateQueue = v } else g.add(a); break e } else { if (!(e & 1)) { Ec(o, u, e), hu(); break e } a = Error(O(426)) } } else if (J && l.mode & 1) { var _ = Cc(s); if (_ !== null) { !(_.flags & 65536) && (_.flags |= 256), Pc(_, s, l, o, e), Ya(hi(a, l)); break e } } o = a = hi(a, l), de !== 4 && (de = 2), Zi === null ? Zi = [o] : Zi.push(o), o = s; do { switch (o.tag) { case 3: o.flags |= 65536, e &= -e, o.lanes |= e; var m = $h(o, a, e); yc(o, m); break e; case 1: l = a; var p = o.type, y = o.stateNode; if (!(o.flags & 128) && (typeof p.getDerivedStateFromError == "function" || y !== null && typeof y.componentDidCatch == "function" && (en === null || !en.has(y)))) { o.flags |= 65536, e &= -e, o.lanes |= e; var w = Uh(o, l, e); yc(o, w); break e } }o = o.return } while (o !== null) } cp(n) } catch (S) { e = S, ae === n && n !== null && (ae = n = n.return); continue } break } while (1) } function ap() { var t = Uo.current; return Uo.current = $o, t === null ? $o : t } function hu() { (de === 0 || de === 3 || de === 2) && (de = 4), pe === null || !(Mn & 268435455) && !(_s & 268435455) || Wt(pe, ye) } function Qo(t, e) { var n = H; H |= 2; var i = ap(); (pe !== t || ye !== e) && (Ct = null, bn(t, e)); do try { k0(); break } catch (r) { lp(t, r) } while (1); if (Ka(), H = n, Uo.current = i, ae !== null) throw Error(O(261)); return pe = null, ye = 0, de } function k0() { for (; ae !== null;)up(ae) } function b0() { for (; ae !== null && !Qg();)up(ae) } function up(t) { var e = fp(t.alternate, t, $e); t.memoizedProps = t.pendingProps, e === null ? cp(t) : ae = e, au.current = null } function cp(t) { var e = t; do { var n = e.alternate; if (t = e.return, e.flags & 32768) { if (n = m0(n, e), n !== null) { n.flags &= 32767, ae = n; return } if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null; else { de = 6, ae = null; return } } else if (n = g0(n, e, $e), n !== null) { ae = n; return } if (e = e.sibling, e !== null) { ae = e; return } ae = e = t } while (e !== null); de === 0 && (de = 5) } function vn(t, e, n) { var i = X, r = nt.transition; try { nt.transition = null, X = 1, S0(t, e, n, i) } finally { nt.transition = r, X = i } return null } function S0(t, e, n, i) { do ri(); while ($t !== null); if (H & 6) throw Error(O(327)); n = t.finishedWork; var r = t.finishedLanes; if (n === null) return null; if (t.finishedWork = null, t.finishedLanes = 0, n === t.current) throw Error(O(177)); t.callbackNode = null, t.callbackPriority = 0; var o = n.lanes | n.childLanes; if (rm(t, o), t === pe && (ae = pe = null, ye = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Qr || (Qr = !0, hp(Mo, function () { return ri(), null })), o = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || o) { o = nt.transition, nt.transition = null; var s = X; X = 1; var l = H; H |= 4, au.current = null, y0(t, n), rp(n, t), $m(Al), Ro = !!Rl, Al = Rl = null, t.current = n, x0(n), Kg(), H = l, X = s, nt.transition = o } else t.current = n; if (Qr && (Qr = !1, $t = t, Yo = r), o = t.pendingLanes, o === 0 && (en = null), qg(n.stateNode), Fe(t, le()), e !== null) for (i = t.onRecoverableError, n = 0; n < e.length; n++)r = e[n], i(r.value, { componentStack: r.stack, digest: r.digest }); if (Xo) throw Xo = !1, t = ql, ql = null, t; return Yo & 1 && t.tag !== 0 && ri(), o = t.pendingLanes, o & 1 ? t === Jl ? qi++ : (qi = 0, Jl = t) : qi = 0, dn(), null } function ri() { if ($t !== null) { var t = Vf(Yo), e = nt.transition, n = X; try { if (nt.transition = null, X = 16 > t ? 16 : t, $t === null) var i = !1; else { if (t = $t, $t = null, Yo = 0, H & 6) throw Error(O(331)); var r = H; for (H |= 4, A = t.current; A !== null;) { var o = A, s = o.child; if (A.flags & 16) { var l = o.deletions; if (l !== null) { for (var a = 0; a < l.length; a++) { var u = l[a]; for (A = u; A !== null;) { var d = A; switch (d.tag) { case 0: case 11: case 15: Gi(8, d, o) }var f = d.child; if (f !== null) f.return = d, A = f; else for (; A !== null;) { d = A; var c = d.sibling, h = d.return; if (tp(d), d === u) { A = null; break } if (c !== null) { c.return = h, A = c; break } A = h } } } var g = o.alternate; if (g !== null) { var v = g.child; if (v !== null) { g.child = null; do { var _ = v.sibling; v.sibling = null, v = _ } while (v !== null) } } A = o } } if (o.subtreeFlags & 2064 && s !== null) s.return = o, A = s; else e: for (; A !== null;) { if (o = A, o.flags & 2048) switch (o.tag) { case 0: case 11: case 15: Gi(9, o, o.return) }var m = o.sibling; if (m !== null) { m.return = o.return, A = m; break e } A = o.return } } var p = t.current; for (A = p; A !== null;) { s = A; var y = s.child; if (s.subtreeFlags & 2064 && y !== null) y.return = s, A = y; else e: for (s = p; A !== null;) { if (l = A, l.flags & 2048) try { switch (l.tag) { case 0: case 11: case 15: xs(9, l) } } catch (S) { re(l, l.return, S) } if (l === s) { A = null; break e } var w = l.sibling; if (w !== null) { w.return = l.return, A = w; break e } A = l.return } } if (H = r, dn(), _t && typeof _t.onPostCommitFiberRoot == "function") try { _t.onPostCommitFiberRoot(ds, t) } catch { } i = !0 } return i } finally { X = n, nt.transition = e } } return !1 } function Bc(t, e, n) { e = hi(n, e), e = $h(t, e, 1), t = Jt(t, e, 1), e = Me(), t !== null && (Sr(t, 1, e), Fe(t, e)) } function re(t, e, n) { if (t.tag === 3) Bc(t, t, n); else for (; e !== null;) { if (e.tag === 3) { Bc(e, t, n); break } else if (e.tag === 1) { var i = e.stateNode; if (typeof e.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (en === null || !en.has(i))) { t = hi(n, t), t = Uh(e, t, 1), e = Jt(e, t, 1), t = Me(), e !== null && (Sr(e, 1, t), Fe(e, t)); break } } e = e.return } } function E0(t, e, n) { var i = t.pingCache; i !== null && i.delete(e), e = Me(), t.pingedLanes |= t.suspendedLanes & n, pe === t && (ye & n) === n && (de === 4 || de === 3 && (ye & 130023424) === ye && 500 > le() - cu ? bn(t, 0) : uu |= n), Fe(t, e) } function dp(t, e) { e === 0 && (t.mode & 1 ? (e = Ir, Ir <<= 1, !(Ir & 130023424) && (Ir = 4194304)) : e = 1); var n = Me(); t = Lt(t, e), t !== null && (Sr(t, e, n), Fe(t, n)) } function C0(t) { var e = t.memoizedState, n = 0; e !== null && (n = e.retryLane), dp(t, n) } function P0(t, e) { var n = 0; switch (t.tag) { case 13: var i = t.stateNode, r = t.memoizedState; r !== null && (n = r.retryLane); break; case 19: i = t.stateNode; break; default: throw Error(O(314)) }i !== null && i.delete(e), dp(t, n) } var fp; fp = function (t, e, n) { if (t !== null) if (t.memoizedProps !== e.pendingProps || ze.current) Ne = !0; else { if (!(t.lanes & n) && !(e.flags & 128)) return Ne = !1, p0(t, e, n); Ne = !!(t.flags & 131072) } else Ne = !1, J && e.flags & 1048576 && gh(e, Io, e.index); switch (e.lanes = 0, e.tag) { case 2: var i = e.type; yo(t, e), t = e.pendingProps; var r = ui(e, Ce.current); ii(e, n), r = iu(null, e, i, t, r, n); var o = ru(); return e.flags |= 1, typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, Ie(i) ? (o = !0, No(e)) : o = !1, e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, qa(e), r.updater = vs, e.stateNode = r, r._reactInternals = e, Hl(e, i, t, n), e = $l(null, e, i, !0, o, n)) : (e.tag = 0, J && o && Ua(e), Pe(null, e, r, n), e = e.child), e; case 16: i = e.elementType; e: { switch (yo(t, e), t = e.pendingProps, r = i._init, i = r(i._payload), e.type = i, r = e.tag = M0(i), t = lt(i, t), r) { case 0: e = Vl(null, e, i, t, n); break e; case 1: e = Tc(null, e, i, t, n); break e; case 11: e = Oc(null, e, i, t, n); break e; case 14: e = Mc(null, e, i, lt(i.type, t), n); break e }throw Error(O(306, i, "")) } return e; case 0: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : lt(i, r), Vl(t, e, i, r, n); case 1: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : lt(i, r), Tc(t, e, i, r, n); case 3: e: { if (Kh(e), t === null) throw Error(O(387)); i = e.pendingProps, o = e.memoizedState, r = o.element, xh(t, e), Ho(e, i, null, n); var s = e.memoizedState; if (i = s.element, o.isDehydrated) if (o = { element: i, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, e.updateQueue.baseState = o, e.memoizedState = o, e.flags & 256) { r = hi(Error(O(423)), e), e = Rc(t, e, i, n, r); break e } else if (i !== r) { r = hi(Error(O(424)), e), e = Rc(t, e, i, n, r); break e } else for (Ue = qt(e.stateNode.containerInfo.firstChild), Xe = e, J = !0, ut = null, n = bh(e, null, i, n), e.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (ci(), i === r) { e = Dt(t, e, n); break e } Pe(t, e, i, n) } e = e.child } return e; case 5: return Sh(e), t === null && Il(e), i = e.type, r = e.pendingProps, o = t !== null ? t.memoizedProps : null, s = r.children, jl(i, r) ? s = null : o !== null && jl(i, o) && (e.flags |= 32), Qh(t, e), Pe(t, e, s, n), e.child; case 6: return t === null && Il(e), null; case 13: return Gh(t, e, n); case 4: return Ja(e, e.stateNode.containerInfo), i = e.pendingProps, t === null ? e.child = di(e, null, i, n) : Pe(t, e, i, n), e.child; case 11: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : lt(i, r), Oc(t, e, i, r, n); case 7: return Pe(t, e, e.pendingProps, n), e.child; case 8: return Pe(t, e, e.pendingProps.children, n), e.child; case 12: return Pe(t, e, e.pendingProps.children, n), e.child; case 10: e: { if (i = e.type._context, r = e.pendingProps, o = e.memoizedProps, s = r.value, G(Fo, i._currentValue), i._currentValue = s, o !== null) if (ft(o.value, s)) { if (o.children === r.children && !ze.current) { e = Dt(t, e, n); break e } } else for (o = e.child, o !== null && (o.return = e); o !== null;) { var l = o.dependencies; if (l !== null) { s = o.child; for (var a = l.firstContext; a !== null;) { if (a.context === i) { if (o.tag === 1) { a = Rt(-1, n & -n), a.tag = 2; var u = o.updateQueue; if (u !== null) { u = u.shared; var d = u.pending; d === null ? a.next = a : (a.next = d.next, d.next = a), u.pending = a } } o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), Fl(o.return, n, e), l.lanes |= n; break } a = a.next } } else if (o.tag === 10) s = o.type === e.type ? null : o.child; else if (o.tag === 18) { if (s = o.return, s === null) throw Error(O(341)); s.lanes |= n, l = s.alternate, l !== null && (l.lanes |= n), Fl(s, n, e), s = o.sibling } else s = o.child; if (s !== null) s.return = o; else for (s = o; s !== null;) { if (s === e) { s = null; break } if (o = s.sibling, o !== null) { o.return = s.return, s = o; break } s = s.return } o = s } Pe(t, e, r.children, n), e = e.child } return e; case 9: return r = e.type, i = e.pendingProps.children, ii(e, n), r = it(r), i = i(r), e.flags |= 1, Pe(t, e, i, n), e.child; case 14: return i = e.type, r = lt(i, e.pendingProps), r = lt(i.type, r), Mc(t, e, i, r, n); case 15: return Xh(t, e, e.type, e.pendingProps, n); case 17: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : lt(i, r), yo(t, e), e.tag = 1, Ie(i) ? (t = !0, No(e)) : t = !1, ii(e, n), wh(e, i, r), Hl(e, i, r, n), $l(null, e, i, !0, t, n); case 19: return Zh(t, e, n); case 22: return Yh(t, e, n) }throw Error(O(156, e.tag)) }; function hp(t, e) { return Ff(t, e) } function O0(t, e, n, i) { this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function et(t, e, n, i) { return new O0(t, e, n, i) } function pu(t) { return t = t.prototype, !(!t || !t.isReactComponent) } function M0(t) { if (typeof t == "function") return pu(t) ? 1 : 0; if (t != null) { if (t = t.$$typeof, t === ja) return 11; if (t === La) return 14 } return 2 } function nn(t, e) { var n = t.alternate; return n === null ? (n = et(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n } function wo(t, e, n, i, r, o) { var s = 2; if (i = t, typeof t == "function") pu(t) && (s = 1); else if (typeof t == "string") s = 5; else e: switch (t) { case Hn: return Sn(n.children, r, o, e); case Aa: s = 8, r |= 8; break; case dl: return t = et(12, n, e, r | 2), t.elementType = dl, t.lanes = o, t; case fl: return t = et(13, n, e, r), t.elementType = fl, t.lanes = o, t; case hl: return t = et(19, n, e, r), t.elementType = hl, t.lanes = o, t; case kf: return ws(n, r, o, e); default: if (typeof t == "object" && t !== null) switch (t.$$typeof) { case _f: s = 10; break e; case wf: s = 9; break e; case ja: s = 11; break e; case La: s = 14; break e; case It: s = 16, i = null; break e }throw Error(O(130, t == null ? t : typeof t, "")) }return e = et(s, n, e, r), e.elementType = t, e.type = i, e.lanes = o, e } function Sn(t, e, n, i) { return t = et(7, t, i, e), t.lanes = n, t } function ws(t, e, n, i) { return t = et(22, t, i, e), t.elementType = kf, t.lanes = n, t.stateNode = { isHidden: !1 }, t } function Js(t, e, n) { return t = et(6, t, null, e), t.lanes = n, t } function el(t, e, n) { return e = et(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = { containerInfo: t.containerInfo, pendingChildren: null, implementation: t.implementation }, e } function T0(t, e, n, i, r) { this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ls(0), this.expirationTimes = Ls(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ls(0), this.identifierPrefix = i, this.onRecoverableError = r, this.mutableSourceEagerHydrationData = null } function gu(t, e, n, i, r, o, s, l, a) { return t = new T0(t, e, n, l, a), e === 1 ? (e = 1, o === !0 && (e |= 8)) : e = 0, o = et(3, null, null, e), t.current = o, o.stateNode = t, o.memoizedState = { element: i, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, qa(o), t } function R0(t, e, n) { var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Bn, key: i == null ? null : "" + i, children: t, containerInfo: e, implementation: n } } function pp(t) { if (!t) return ln; t = t._reactInternals; e: { if (Dn(t) !== t || t.tag !== 1) throw Error(O(170)); var e = t; do { switch (e.tag) { case 3: e = e.stateNode.context; break e; case 1: if (Ie(e.type)) { e = e.stateNode.__reactInternalMemoizedMergedChildContext; break e } }e = e.return } while (e !== null); throw Error(O(171)) } if (t.tag === 1) { var n = t.type; if (Ie(n)) return hh(t, n, e) } return e } function gp(t, e, n, i, r, o, s, l, a) { return t = gu(n, i, !0, t, r, o, s, l, a), t.context = pp(null), n = t.current, i = Me(), r = tn(n), o = Rt(i, r), o.callback = e ?? null, Jt(n, o, r), t.current.lanes = r, Sr(t, r, i), Fe(t, i), t } function ks(t, e, n, i) { var r = e.current, o = Me(), s = tn(r); return n = pp(n), e.context === null ? e.context = n : e.pendingContext = n, e = Rt(o, s), e.payload = { element: t }, i = i === void 0 ? null : i, i !== null && (e.callback = i), t = Jt(r, e, s), t !== null && (dt(t, r, s, o), go(t, r, s)), s } function Ko(t) { if (t = t.current, !t.child) return null; switch (t.child.tag) { case 5: return t.child.stateNode; default: return t.child.stateNode } } function Hc(t, e) { if (t = t.memoizedState, t !== null && t.dehydrated !== null) { var n = t.retryLane; t.retryLane = n !== 0 && n < e ? n : e } } function mu(t, e) { Hc(t, e), (t = t.alternate) && Hc(t, e) } function A0() { return null } var mp = typeof reportError == "function" ? reportError : function (t) { console.error(t) }; function vu(t) { this._internalRoot = t } bs.prototype.render = vu.prototype.render = function (t) { var e = this._internalRoot; if (e === null) throw Error(O(409)); ks(t, e, null, null) }; bs.prototype.unmount = vu.prototype.unmount = function () { var t = this._internalRoot; if (t !== null) { this._internalRoot = null; var e = t.containerInfo; Tn(function () { ks(null, t, null, null) }), e[jt] = null } }; function bs(t) { this._internalRoot = t } bs.prototype.unstable_scheduleHydration = function (t) { if (t) { var e = Xf(); t = { blockedOn: null, target: t, priority: e }; for (var n = 0; n < Ht.length && e !== 0 && e < Ht[n].priority; n++); Ht.splice(n, 0, t), n === 0 && Qf(t) } }; function yu(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11) } function Ss(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable ")) } function Wc() { } function j0(t, e, n, i, r) { if (r) { if (typeof i == "function") { var o = i; i = function () { var u = Ko(s); o.call(u) } } var s = gp(e, i, t, 0, null, !1, !1, "", Wc); return t._reactRootContainer = s, t[jt] = s.current, cr(t.nodeType === 8 ? t.parentNode : t), Tn(), s } for (; r = t.lastChild;)t.removeChild(r); if (typeof i == "function") { var l = i; i = function () { var u = Ko(a); l.call(u) } } var a = gu(t, 0, !1, null, null, !1, !1, "", Wc); return t._reactRootContainer = a, t[jt] = a.current, cr(t.nodeType === 8 ? t.parentNode : t), Tn(function () { ks(e, a, n, i) }), a } function Es(t, e, n, i, r) { var o = n._reactRootContainer; if (o) { var s = o; if (typeof r == "function") { var l = r; r = function () { var a = Ko(s); l.call(a) } } ks(e, s, t, r) } else s = j0(n, e, t, r, i); return Ko(s) } $f = function (t) { switch (t.tag) { case 3: var e = t.stateNode; if (e.current.memoizedState.isDehydrated) { var n = zi(e.pendingLanes); n !== 0 && (za(e, n | 1), Fe(e, le()), !(H & 6) && (pi = le() + 500, dn())) } break; case 13: Tn(function () { var i = Lt(t, 1); if (i !== null) { var r = Me(); dt(i, t, 1, r) } }), mu(t, 1) } }; Ia = function (t) { if (t.tag === 13) { var e = Lt(t, 134217728); if (e !== null) { var n = Me(); dt(e, t, 134217728, n) } mu(t, 134217728) } }; Uf = function (t) { if (t.tag === 13) { var e = tn(t), n = Lt(t, e); if (n !== null) { var i = Me(); dt(n, t, e, i) } mu(t, e) } }; Xf = function () { return X }; Yf = function (t, e) { var n = X; try { return X = t, e() } finally { X = n } }; bl = function (t, e, n) { switch (e) { case "input": if (ml(t, n), e = n.name, n.type === "radio" && e != null) { for (n = t; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) { var i = n[e]; if (i !== t && i.form === t.form) { var r = gs(i); if (!r) throw Error(O(90)); Sf(i), ml(i, r) } } } break; case "textarea": Cf(t, n); break; case "select": e = n.value, e != null && Jn(t, !!n.multiple, e, !1) } }; jf = du; Lf = Tn; var L0 = { usingClientEntryPoint: !1, Events: [Cr, Un, gs, Rf, Af, du] }, Oi = { findFiberByHostInstance: xn, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, D0 = { bundleType: Oi.bundleType, version: Oi.version, rendererPackageName: Oi.rendererPackageName, rendererConfig: Oi.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Nt.ReactCurrentDispatcher, findHostInstanceByFiber: function (t) { return t = zf(t), t === null ? null : t.stateNode }, findFiberByHostInstance: Oi.findFiberByHostInstance || A0, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Kr = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Kr.isDisabled && Kr.supportsFiber) try { ds = Kr.inject(D0), _t = Kr } catch { } } Qe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = L0; Qe.createPortal = function (t, e) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!yu(e)) throw Error(O(200)); return R0(t, e, null, n) }; Qe.createRoot = function (t, e) { if (!yu(t)) throw Error(O(299)); var n = !1, i = "", r = mp; return e != null && (e.unstable_strictMode === !0 && (n = !0), e.identifierPrefix !== void 0 && (i = e.identifierPrefix), e.onRecoverableError !== void 0 && (r = e.onRecoverableError)), e = gu(t, 1, !1, null, null, n, !1, i, r), t[jt] = e.current, cr(t.nodeType === 8 ? t.parentNode : t), new vu(e) }; Qe.findDOMNode = function (t) { if (t == null) return null; if (t.nodeType === 1) return t; var e = t._reactInternals; if (e === void 0) throw typeof t.render == "function" ? Error(O(188)) : (t = Object.keys(t).join(","), Error(O(268, t))); return t = zf(e), t = t === null ? null : t.stateNode, t }; Qe.flushSync = function (t) { return Tn(t) }; Qe.hydrate = function (t, e, n) { if (!Ss(e)) throw Error(O(200)); return Es(null, t, e, !0, n) }; Qe.hydrateRoot = function (t, e, n) { if (!yu(t)) throw Error(O(405)); var i = n != null && n.hydratedSources || null, r = !1, o = "", s = mp; if (n != null && (n.unstable_strictMode === !0 && (r = !0), n.identifierPrefix !== void 0 && (o = n.identifierPrefix), n.onRecoverableError !== void 0 && (s = n.onRecoverableError)), e = gp(e, null, t, 1, n ?? null, r, !1, o, s), t[jt] = e.current, cr(t), i) for (t = 0; t < i.length; t++)n = i[t], r = n._getVersion, r = r(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, r] : e.mutableSourceEagerHydrationData.push(n, r); return new bs(e) }; Qe.render = function (t, e, n) { if (!Ss(e)) throw Error(O(200)); return Es(null, t, e, !1, n) }; Qe.unmountComponentAtNode = function (t) { if (!Ss(t)) throw Error(O(40)); return t._reactRootContainer ? (Tn(function () { Es(null, null, t, !1, function () { t._reactRootContainer = null, t[jt] = null }) }), !0) : !1 }; Qe.unstable_batchedUpdates = du; Qe.unstable_renderSubtreeIntoContainer = function (t, e, n, i) { if (!Ss(n)) throw Error(O(200)); if (t == null || t._reactInternals === void 0) throw Error(O(38)); return Es(t, e, n, !1, i) }; Qe.version = "18.2.0-next-9e3b772b8-20220608"; function vp() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(vp) } catch (t) { console.error(t) } } vp(), gf.exports = Qe; var N0 = gf.exports, Vc = N0; ul.createRoot = Vc.createRoot, ul.hydrateRoot = Vc.hydrateRoot; var yp = {}, na = { exports: {} }, xp = { exports: {} }, z0 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", I0 = z0, F0 = I0; function _p() { } function wp() { } wp.resetWarningCache = _p; var B0 = function () { function t(i, r, o, s, l, a) { if (a !== F0) { var u = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw u.name = "Invariant Violation", u } } t.isRequired = t; function e() { return t } var n = { array: t, bigint: t, bool: t, func: t, number: t, object: t, string: t, symbol: t, any: t, arrayOf: e, element: t, elementType: t, instanceOf: e, node: t, objectOf: e, oneOf: e, oneOfType: e, shape: e, exact: e, checkPropTypes: wp, resetWarningCache: _p }; return n.PropTypes = n, n }; xp.exports = B0(); var ot = xp.exports, Ge = {}; (function (t) { function e(p) { try { return v.insertRule(p, v.cssRules.length) } catch { console.warn("react-reveal - animation failed") } } function n(p, y, w, S, x) { var k = Math.log(S), b = Math.log(x), C = (b - k) / (w - y); return Math.exp(k + C * (p - y)) } function i(p) { if (!v) return ""; var y = "@keyframes " + (_ + h) + "{" + p + "}", w = g[p]; return w ? "" + _ + w : (v.insertRule(y, v.cssRules.length), g[p] = h, "" + _ + h++) } function r() { f || (t.globalHide = f = !0, window.removeEventListener("scroll", r, !0), e("." + s + " { opacity: 0; }"), window.removeEventListener("orientationchange", r, !0), window.document.removeEventListener("visibilitychange", r)) } function o(p) { var y = p.ssrFadeout; t.fadeOutEnabled = y } Object.defineProperty(t, "__esModule", { value: !0 }), t.insertRule = e, t.cascade = n, t.animation = i, t.hideAll = r, t.default = o; var s = t.namespace = "react-reveal"; t.defaults = { duration: 1e3, delay: 0, count: 1 }; var l = t.ssr = !0, a = t.observerMode = !1, u = t.raf = function (p) { return window.setTimeout(p, 66) }, d = t.disableSsr = function () { return t.ssr = l = !1 }; t.fadeOutEnabled = !1, t.ssrFadeout = function () { var p = arguments.length > 0 && arguments[0] !== void 0 && arguments[0]; return t.fadeOutEnabled = p }; var f = t.globalHide = !1; t.ie10 = !1; var c = t.collapseend = void 0, h = 1, g = {}, v = !1, _ = s + "-" + Math.floor(1e15 * Math.random()) + "-"; if (typeof window < "u" && window.name !== "nodejs" && window.document && typeof navigator < "u") { t.observerMode = a = "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype && /\{\s*\[native code\]\s*\}/.test("" + IntersectionObserver), t.raf = u = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || u, t.ssr = l = window.document.querySelectorAll("div[data-reactroot]").length > 0, navigator.appVersion.indexOf("MSIE 10") !== -1 && (t.ie10 = !0), l && "performance" in window && "timing" in window.performance && "domContentLoadedEventEnd" in window.performance.timing && window.performance.timing.domLoading && Date.now() - window.performance.timing.domLoading < 300 && (t.ssr = l = !1), l && window.setTimeout(d, 1500), a || (t.collapseend = c = document.createEvent("Event"), c.initEvent("collapseend", !0, !0)); var m = document.createElement("style"); document.head.appendChild(m), m.sheet && m.sheet.cssRules && m.sheet.insertRule && (v = m.sheet, window.addEventListener("scroll", r, !0), window.addEventListener("orientationchange", r, !0), window.document.addEventListener("visibilitychange", r)) } })(Ge); var ia = { exports: {} }, ra = { exports: {} }; (function (t, e) { function n(w) { return w && w.__esModule ? w : { default: w } } function i(w, S, x) { return S in w ? Object.defineProperty(w, S, { value: x, enumerable: !0, configurable: !0, writable: !0 }) : w[S] = x, w } function r(w, S) { if (!(w instanceof S)) throw new TypeError("Cannot call a class as a function") } function o(w, S) { if (!w) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !S || typeof S != "object" && typeof S != "function" ? w : S } function s(w, S) { if (typeof S != "function" && S !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof S); w.prototype = Object.create(S && S.prototype, { constructor: { value: w, enumerable: !1, writable: !0, configurable: !0 } }), S && (Object.setPrototypeOf ? Object.setPrototypeOf(w, S) : w.__proto__ = S) } Object.defineProperty(e, "__esModule", { value: !0 }); var l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (w) { return typeof w } : function (w) { return w && typeof Symbol == "function" && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w }, a = function () { function w(S, x) { var k = [], b = !0, C = !1, P = void 0; try { for (var M, T = S[Symbol.iterator](); !(b = (M = T.next()).done) && (k.push(M.value), !x || k.length !== x); b = !0); } catch (L) { C = !0, P = L } finally { try { !b && T.return && T.return() } finally { if (C) throw P } } return k } return function (S, x) { if (Array.isArray(S)) return S; if (Symbol.iterator in Object(S)) return w(S, x); throw new TypeError("Invalid attempt to destructure non-iterable instance") } }(), u = Object.assign || function (w) { for (var S = 1; S < arguments.length; S++) { var x = arguments[S]; for (var k in x) Object.prototype.hasOwnProperty.call(x, k) && (w[k] = x[k]) } return w }, d = function () { function w(S, x) { for (var k = 0; k < x.length; k++) { var b = x[k]; b.enumerable = b.enumerable || !1, b.configurable = !0, "value" in b && (b.writable = !0), Object.defineProperty(S, b.key, b) } } return function (S, x, k) { return x && w(S.prototype, x), k && w(S, k), S } }(), f = Oe, c = n(f), h = ot, g = Ge, v = (0, h.shape)({ make: h.func, duration: h.number.isRequired, delay: h.number.isRequired, forever: h.bool, count: h.number.isRequired, style: h.object.isRequired, reverse: h.bool }), _ = { collapse: h.bool, collapseEl: h.element, cascade: h.bool, wait: h.number, force: h.bool, disabled: h.bool, appear: h.bool, enter: h.bool, exit: h.bool, fraction: h.number, refProp: h.string, innerRef: h.func, onReveal: h.func, unmountOnExit: h.bool, mountOnEnter: h.bool, inEffect: v.isRequired, outEffect: (0, h.oneOfType)([v, (0, h.oneOf)([!1])]).isRequired, ssrReveal: h.bool, collapseOnly: h.bool, ssrFadeout: h.bool }, m = { fraction: .2, refProp: "ref" }, p = { transitionGroup: h.object }, y = function (w) { function S(x, k) { r(this, S); var b = o(this, (S.__proto__ || Object.getPrototypeOf(S)).call(this, x, k)); return b.isOn = x.when === void 0 || !!x.when, b.state = { collapse: x.collapse ? S.getInitialCollapseStyle(x) : void 0, style: { opacity: b.isOn && !x.ssrReveal || !x.outEffect ? void 0 : 0 } }, b.savedChild = !1, b.isShown = !1, g.observerMode ? b.handleObserve = b.handleObserve.bind(b) : (b.revealHandler = b.makeHandler(b.reveal), b.resizeHandler = b.makeHandler(b.resize)), b.saveRef = b.saveRef.bind(b), b } return s(S, w), d(S, [{ key: "saveRef", value: function (x) { this.childRef && this.childRef(x), this.props.innerRef && this.props.innerRef(x), this.el !== x && (this.el = x && "offsetHeight" in x ? x : void 0, this.observe(this.props, !0)) } }, { key: "invisible", value: function () { this && this.el && (this.savedChild = !1, this.isShown || (this.setState({ hasExited: !0, collapse: this.props.collapse ? u({}, this.state.collapse, { visibility: "hidden" }) : null, style: { opacity: 0 } }), !g.observerMode && this.props.collapse && window.document.dispatchEvent(g.collapseend))) } }, { key: "animationEnd", value: function (x, k, b) { var C = this, P = b.forever, M = b.count, T = b.delay, L = b.duration; if (!P) { var I = function () { C && C.el && (C.animationEndTimeout = void 0, x.call(C)) }; this.animationEndTimeout = window.setTimeout(I, T + (L + (k ? L : 0) * M)) } } }, { key: "getDimensionValue", value: function () { return this.el.offsetHeight + parseInt(window.getComputedStyle(this.el, null).getPropertyValue("margin-top"), 10) + parseInt(window.getComputedStyle(this.el, null).getPropertyValue("margin-bottom"), 10) } }, { key: "collapse", value: function (x, k, b) { var C = b.duration + (k.cascade ? b.duration : 0), P = this.isOn ? this.getDimensionValue() : 0, M = void 0, T = void 0; if (k.collapseOnly) M = b.duration / 3, T = b.delay; else { var L = C >> 2, I = L >> 1; M = L, T = b.delay + (this.isOn ? 0 : C - L - I), x.style.animationDuration = C - L + (this.isOn ? I : -I) + "ms", x.style.animationDelay = b.delay + (this.isOn ? L - I : 0) + "ms" } return x.collapse = { height: P, transition: "height " + M + "ms ease " + T + "ms", overflow: k.collapseOnly ? "hidden" : void 0 }, x } }, { key: "animate", value: function (x) { if (this && this.el && (this.unlisten(), this.isShown !== this.isOn)) { this.isShown = this.isOn; var k = !this.isOn && x.outEffect, b = x[k ? "outEffect" : "inEffect"], C = "style" in b && b.style.animationName || void 0, P = void 0; x.collapseOnly ? P = { hasAppeared: !0, hasExited: !1, style: { opacity: 1 } } : ((x.outEffect || this.isOn) && b.make && (C = b.make), P = { hasAppeared: !0, hasExited: !1, collapse: void 0, style: u({}, b.style, { animationDuration: b.duration + "ms", animationDelay: b.delay + "ms", animationIterationCount: b.forever ? "infinite" : b.count, opacity: 1, animationName: C }), className: b.className }), this.setState(x.collapse ? this.collapse(P, x, b) : P), k ? (this.savedChild = c.default.cloneElement(this.getChild()), this.animationEnd(this.invisible, x.cascade, b)) : this.savedChild = !1, this.onReveal(x) } } }, { key: "onReveal", value: function (x) { x.onReveal && this.isOn && (this.onRevealTimeout && (this.onRevealTimeout = window.clearTimeout(this.onRevealTimeout)), x.wait ? this.onRevealTimeout = window.setTimeout(x.onReveal, x.wait) : x.onReveal()) } }, { key: "componentWillUnmount", value: function () { this.unlisten(), g.ssr && (0, g.disableSsr)() } }, { key: "handleObserve", value: function (x, k) { a(x, 1)[0].intersectionRatio > 0 && (k.disconnect(), this.observer = null, this.reveal(this.props, !0)) } }, { key: "observe", value: function (x) { var k = arguments.length > 1 && arguments[1] !== void 0 && arguments[1]; if (this.el && g.observerMode) { if (this.observer) { if (!k) return; this.observer.disconnect() } else if (k) return; this.observer = new IntersectionObserver(this.handleObserve, { threshold: x.fraction }), this.observer.observe(this.el) } } }, { key: "reveal", value: function (x) { var k = this, b = arguments.length > 1 && arguments[1] !== void 0 && arguments[1]; g.globalHide || (0, g.hideAll)(), this && this.el && (x || (x = this.props), g.ssr && (0, g.disableSsr)(), this.isOn && this.isShown && x.spy !== void 0 ? (this.isShown = !1, this.setState({ style: {} }), window.setTimeout(function () { return k.reveal(x) }, 200)) : b || this.inViewport(x) || x.force ? this.animate(x) : g.observerMode ? this.observe(x) : this.listen()) } }, { key: "componentDidMount", value: function () { var x = this; if (this.el && !this.props.disabled) { this.props.collapseOnly || ("make" in this.props.inEffect && this.props.inEffect.make(!1, this.props), this.props.when !== void 0 && this.props.outEffect && "make" in this.props.outEffect && this.props.outEffect.make(!0, this.props)); var k = this.context.transitionGroup, b = k && !k.isMounting ? !("enter" in this.props && this.props.enter === !1) : this.props.appear; return this.isOn && ((this.props.when !== void 0 || this.props.spy !== void 0) && !b || g.ssr && !g.fadeOutEnabled && !this.props.ssrFadeout && this.props.outEffect && !this.props.ssrReveal && S.getTop(this.el) < window.pageYOffset + window.innerHeight) ? (this.isShown = !0, this.setState({ hasAppeared: !0, collapse: this.props.collapse ? { height: this.getDimensionValue() } : this.state.collapse, style: { opacity: 1 } }), void this.onReveal(this.props)) : g.ssr && (g.fadeOutEnabled || this.props.ssrFadeout) && this.props.outEffect && S.getTop(this.el) < window.pageYOffset + window.innerHeight ? (this.setState({ style: { opacity: 0, transition: "opacity 1000ms 1000ms" } }), void window.setTimeout(function () { return x.reveal(x.props, !0) }, 2e3)) : void (this.isOn && (this.props.force ? this.animate(this.props) : this.reveal(this.props))) } } }, { key: "cascade", value: function (x) { var k = this, b = void 0; b = typeof x == "string" ? x.split("").map(function (D, F) { return c.default.createElement("span", { key: F, style: { display: "inline-block", whiteSpace: "pre" } }, D) }) : c.default.Children.toArray(x); var C = this.props[this.isOn || !this.props.outEffect ? "inEffect" : "outEffect"], P = C.duration, M = C.reverse, T = b.length, L = 2 * P; this.props.collapse && (L = parseInt(this.state.style.animationDuration, 10), P = L / 2); var I = M ? T : 0; return b = b.map(function (D) { return (D === void 0 ? "undefined" : l(D)) === "object" && D ? c.default.cloneElement(D, { style: u({}, D.props.style, k.state.style, { animationDuration: Math.round((0, g.cascade)(M ? I-- : I++, 0, T, P, L)) + "ms" }) }) : D }) } }, { key: "componentWillReceiveProps", value: function (x) { if (x.when !== void 0 && (this.isOn = !!x.when), x.fraction !== this.props.fraction && this.observe(x, !0), !this.isOn && x.onExited && "exit" in x && x.exit === !1) return void x.onExited(); x.disabled || (x.collapse && !this.props.collapse && (this.setState({ style: {}, collapse: S.getInitialCollapseStyle(x) }), this.isShown = !1), x.when === this.props.when && x.spy === this.props.spy || this.reveal(x), this.onRevealTimeout && !this.isOn && (this.onRevealTimeout = window.clearTimeout(this.onRevealTimeout))) } }, { key: "getChild", value: function () { if (this.savedChild && !this.props.disabled) return this.savedChild; if (l(this.props.children) === "object") { var x = c.default.Children.only(this.props.children); return "type" in x && typeof x.type == "string" || this.props.refProp !== "ref" ? x : c.default.createElement("div", null, x) } return c.default.createElement("div", null, this.props.children) } }, { key: "render", value: function () { var x = void 0; x = this.state.hasAppeared ? !this.props.unmountOnExit || !this.state.hasExited || this.isOn : !this.props.mountOnEnter || this.isOn; var k = this.getChild(); typeof k.ref == "function" && (this.childRef = k.ref); var b = !1, C = k.props, P = C.style, M = C.className, T = C.children, L = this.props.disabled ? M : (this.props.outEffect ? g.namespace : "") + (this.state.className ? " " + this.state.className : "") + (M ? " " + M : "") || void 0, I = void 0; typeof this.state.style.animationName == "function" && (this.state.style.animationName = this.state.style.animationName(!this.isOn, this.props)), this.props.cascade && !this.props.disabled && T && this.state.style.animationName ? (b = this.cascade(T), I = u({}, P, { opacity: 1 })) : I = this.props.disabled ? P : u({}, P, this.state.style); var D = u({}, this.props.props, i({ className: L, style: I }, this.props.refProp, this.saveRef)), F = c.default.cloneElement(k, D, x ? b || T : void 0); return this.props.collapse !== void 0 ? this.props.collapseEl ? c.default.cloneElement(this.props.collapseEl, { style: u({}, this.props.collapseEl.style, this.props.disabled ? void 0 : this.state.collapse), children: F }) : c.default.createElement("div", { style: this.props.disabled ? void 0 : this.state.collapse, children: F }) : F } }, { key: "makeHandler", value: function (x) { var k = this, b = function () { x.call(k, k.props), k.ticking = !1 }; return function () { k.ticking || ((0, g.raf)(b), k.ticking = !0) } } }, { key: "inViewport", value: function (x) { if (!this.el || window.document.hidden) return !1; var k = this.el.offsetHeight, b = window.pageYOffset - S.getTop(this.el), C = Math.min(k, window.innerHeight) * (g.globalHide ? x.fraction : 0); return b > C - window.innerHeight && b < k - C } }, { key: "resize", value: function (x) { this && this.el && this.isOn && this.inViewport(x) && (this.unlisten(), this.isShown = this.isOn, this.setState({ hasExited: !this.isOn, hasAppeared: !0, collapse: void 0, style: { opacity: this.isOn || !x.outEffect ? 1 : 0 } }), this.onReveal(x)) } }, { key: "listen", value: function () { g.observerMode || this.isListener || (this.isListener = !0, window.addEventListener("scroll", this.revealHandler, { passive: !0 }), window.addEventListener("orientationchange", this.revealHandler, { passive: !0 }), window.document.addEventListener("visibilitychange", this.revealHandler, { passive: !0 }), window.document.addEventListener("collapseend", this.revealHandler, { passive: !0 }), window.addEventListener("resize", this.resizeHandler, { passive: !0 })) } }, { key: "unlisten", value: function () { !g.observerMode && this.isListener && (window.removeEventListener("scroll", this.revealHandler, { passive: !0 }), window.removeEventListener("orientationchange", this.revealHandler, { passive: !0 }), window.document.removeEventListener("visibilitychange", this.revealHandler, { passive: !0 }), window.document.removeEventListener("collapseend", this.revealHandler, { passive: !0 }), window.removeEventListener("resize", this.resizeHandler, { passive: !0 }), this.isListener = !1), this.onRevealTimeout && (this.onRevealTimeout = window.clearTimeout(this.onRevealTimeout)), this.animationEndTimeout && (this.animationEndTimeout = window.clearTimeout(this.animationEndTimeout)) } }], [{ key: "getInitialCollapseStyle", value: function (x) { return { height: 0, visibility: x.when ? void 0 : "hidden" } } }, { key: "getTop", value: function (x) { for (; x.offsetTop === void 0;)x = x.parentNode; for (var k = x.offsetTop; x.offsetParent; k += x.offsetTop)x = x.offsetParent; return k } }]), S }(c.default.Component); y.propTypes = _, y.defaultProps = m, y.contextTypes = p, y.displayName = "RevealBase", e.default = y, t.exports = e.default })(ra, ra.exports); var H0 = ra.exports; (function (t, e) { function n(u) { return u && u.__esModule ? u : { default: u } } function i(u, d, f, c) { return "in" in u && (u.when = u.in), s.default.Children.count(c) < 2 ? s.default.createElement(a.default, r({}, u, { inEffect: d, outEffect: f, children: c })) : (c = s.default.Children.map(c, function (h) { return s.default.createElement(a.default, r({}, u, { inEffect: d, outEffect: f, children: h })) }), "Fragment" in s.default ? s.default.createElement(s.default.Fragment, null, c) : s.default.createElement("span", null, c)) } Object.defineProperty(e, "__esModule", { value: !0 }); var r = Object.assign || function (u) { for (var d = 1; d < arguments.length; d++) { var f = arguments[d]; for (var c in f) Object.prototype.hasOwnProperty.call(f, c) && (u[c] = f[c]) } return u }; e.default = i; var o = Oe, s = n(o), l = H0, a = n(l); t.exports = e.default })(ia, ia.exports); var ht = ia.exports, oa = { exports: {} }; (function (t, e) {
  function n(c) { return c && c.__esModule ? c : { default: c } } function i(c, h) { var g = {}; for (var v in c) h.indexOf(v) >= 0 || Object.prototype.hasOwnProperty.call(c, v) && (g[v] = c[v]); return g } function r(c, h) {
    var g = h.distance, v = h.left, _ = h.right, m = h.up, p = h.down, y = h.top, w = h.bottom, S = h.big, x = h.mirror, k = h.opposite, b = (g ? g.toString() : 0) + ((v ? 1 : 0) | (_ ? 2 : 0) | (y || p ? 4 : 0) | (w || m ? 8 : 0) | (x ? 16 : 0) | (k ? 32 : 0) | (c ? 64 : 0) | (S ? 128 : 0)); if (f.hasOwnProperty(b)) return f[b]; var C = v || _ || m || p || y || w, P = void 0, M = void 0; if (C) { if (!x != !(c && k)) { var T = [_, v, w, y, p, m]; v = T[0], _ = T[1], y = T[2], w = T[3], m = T[4], p = T[5] } var L = g || (S ? "2000px" : "100%"); P = v ? "-" + L : _ ? L : "0", M = p || y ? "-" + L : m || w ? L : "0" } return f[b] = (0, l.animation)((c ? "to" : "from") + " {opacity: 0;" + (C ? " transform: translate3d(" + P + ", " + M + ", 0);" : "") + `}
     `+ (c ? "from" : "to") + " {opacity: 1;transform: none;} "), f[b]
  } function o() { var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : l.defaults, h = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], g = c.children, v = (c.out, c.forever), _ = c.timeout, m = c.duration, p = m === void 0 ? l.defaults.duration : m, y = c.delay, w = y === void 0 ? l.defaults.delay : y, S = c.count, x = S === void 0 ? l.defaults.count : S, k = i(c, ["children", "out", "forever", "timeout", "duration", "delay", "count"]), b = { make: r, duration: _ === void 0 ? p : _, delay: w, forever: v, count: x, style: { animationFillMode: "both" }, reverse: k.left }; return h ? (0, u.default)(k, b, b, g) : b } Object.defineProperty(e, "__esModule", { value: !0 }); var s = ot, l = Ge, a = ht, u = n(a), d = { out: s.bool, left: s.bool, right: s.bool, top: s.bool, bottom: s.bool, big: s.bool, mirror: s.bool, opposite: s.bool, duration: s.number, timeout: s.number, distance: s.string, delay: s.number, count: s.number, forever: s.bool }, f = {}; o.propTypes = d, e.default = o, t.exports = e.default
})(oa, oa.exports); var xu = oa.exports; const me = jn(xu); (function (t, e) { function n(g) { return g && g.__esModule ? g : { default: g } } function i(g, v) { var _ = {}; for (var m in g) v.indexOf(m) >= 0 || Object.prototype.hasOwnProperty.call(g, m) && (_[m] = g[m]); return _ } function r(g) { function v(D) { return D ? M ? { duration: x, delay: k, count: b, forever: C, className: M, style: {} } : L : P ? { duration: m === void 0 ? p : m, delay: y, count: w, forever: S, className: P, style: {} } : T } var _ = g.children, m = g.timeout, p = g.duration, y = g.delay, w = g.count, S = g.forever, x = g.durationOut, k = g.delayOut, b = g.countOut, C = g.foreverOut, P = g.effect, M = g.effectOut, T = g.inEffect, L = g.outEffect, I = i(g, ["children", "timeout", "duration", "delay", "count", "forever", "durationOut", "delayOut", "countOut", "foreverOut", "effect", "effectOut", "inEffect", "outEffect"]); return (0, u.default)(I, v(!1), v(!0), _) } Object.defineProperty(e, "__esModule", { value: !0 }); var o = Object.assign || function (g) { for (var v = 1; v < arguments.length; v++) { var _ = arguments[v]; for (var m in _) Object.prototype.hasOwnProperty.call(_, m) && (g[m] = _[m]) } return g }, s = ot, l = Ge, a = ht, u = n(a), d = xu, f = n(d), c = { in: s.object, out: (0, s.oneOfType)([s.object, (0, s.oneOf)([!1])]), effect: s.string, effectOut: s.string, duration: s.number, timeout: s.number, delay: s.number, count: s.number, forever: s.bool, durationOut: s.number, delayOut: s.number, countOut: s.number, foreverOut: s.bool }, h = o({}, l.defaults, { durationOut: l.defaults.duration, delayOut: l.defaults.delay, countOut: l.defaults.count, foreverOut: l.defaults.forever, inEffect: (0, f.default)(l.defaults), outEffect: (0, f.default)(o({ out: !0 }, l.defaults)) }); r.propTypes = c, r.defaultProps = h, e.default = r, t.exports = e.default })(na, na.exports); var W0 = na.exports, sa = { exports: {} }; (function (t, e) {
  function n(c) { return c && c.__esModule ? c : { default: c } } function i(c, h) { var g = {}; for (var v in c) h.indexOf(v) >= 0 || Object.prototype.hasOwnProperty.call(c, v) && (g[v] = c[v]); return g } function r(c, h) {
    var g = h.left, v = h.right, _ = h.up, m = h.down, p = h.top, y = h.bottom, w = h.mirror, S = h.opposite, x = (g ? 1 : 0) | (v ? 2 : 0) | (p || m ? 4 : 0) | (y || _ ? 8 : 0) | (w ? 16 : 0) | (S ? 32 : 0) | (c ? 64 : 0); if (f.hasOwnProperty(x)) return f[x]; if (!w != !(c && S)) { var k = [v, g, y, p, m, _]; g = k[0], v = k[1], p = k[2], y = k[3], _ = k[4], m = k[5] } var b = g || v, C = p || y || _ || m, P = b || C, M = void 0, T = void 0, L = void 0, I = void 0, D = void 0, F = void 0, Y = void 0, R = void 0, j = void 0, N = void 0, V = void 0, Q = void 0, Be = void 0, ke = void 0; return c ? (I = b ? (v ? "-" : "") + "20px" : 0, D = C ? (_ || y ? "" : "-") + "10px" : "0", F = (m || p ? "" : "-") + "20px", Be = b ? (g ? "-" : "") + "2000px" : "0", ke = C ? (m || p ? "-" : "") + "2000px" : "0") : (T = b ? (g ? "-" : "") + "3000px" : "0", L = C ? (m || p ? "-" : "") + "3000px" : "0", Y = b ? (v ? "-" : "") + "25px" : "0", R = C ? (_ || y ? "-" : "") + "25px" : "0", j = b ? (g ? "-" : "") + "10px" : "0", N = C ? (m || p ? "-" : "") + "10px" : "0", V = b ? (v ? "-" : "") + "5px" : "0", Q = C ? (_ || y ? "-" : "") + "5px" : "0"), M = P ? c ? `
        20% {
          transform: translate3d(`+ I + ", " + D + `, 0);
          }
        `+ (C ? `40%, 45% {
            opacity: 1;
            transform: translate3d(0, `+ F + `, 0);
          }`: "") + `
          to {
            opacity: 0;
            transform: translate3d(`+ Be + ", " + ke + `, 0);
        }
      `: `from, 60%, 75%, 90%, to {
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
      }
      from {
        opacity: 0;
        transform: translate3d(`+ T + ", " + L + `, 0);
      }
      60% {
        opacity: 1;
        transform: translate3d(`+ Y + ", " + R + `, 0);
      }
      75% {
        transform: translate3d(`+ j + ", " + N + `, 0);
      }
      90% {
        transform: translate3d(`+ V + ", " + Q + `, 0);
      }
      to {
        transform: none;
      }`: c ? `20% {
          transform: scale3d(.9, .9, .9);
        }
        50%, 55% {
          opacity: 1;
          transform: scale3d(1.1, 1.1, 1.1);
        }
        to {
          opacity: 0;
          transform: scale3d(.3, .3, .3);
      }`: `from, 20%, 40%, 60%, 80%, to {
        animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
      }
      0% {
        opacity: 0;
        transform: scale3d(.3, .3, .3);
      }
      20% {
        transform: scale3d(1.1, 1.1, 1.1);
      }
      40% {
        transform: scale3d(.9, .9, .9);
      }
      60% {
        opacity: 1;
        transform: scale3d(1.03, 1.03, 1.03);
      }
      80% {
        transform: scale3d(.97, .97, .97);
      }
      to {
        opacity: 1;
        transform: scale3d(1, 1, 1);
      }`, f[x] = (0, u.animation)(M), f[x]
  } function o() { var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : u.defaults, h = c.children, g = (c.out, c.forever), v = c.timeout, _ = c.duration, m = _ === void 0 ? u.defaults.duration : _, p = c.delay, y = p === void 0 ? u.defaults.delay : p, w = c.count, S = w === void 0 ? u.defaults.count : w, x = i(c, ["children", "out", "forever", "timeout", "duration", "delay", "count"]), k = { make: r, duration: v === void 0 ? m : v, delay: y, forever: g, count: S, style: { animationFillMode: "both" }, reverse: x.left }; return (0, a.default)(x, k, k, h) } Object.defineProperty(e, "__esModule", { value: !0 }); var s = ot, l = ht, a = n(l), u = Ge, d = { out: s.bool, left: s.bool, right: s.bool, top: s.bool, bottom: s.bool, mirror: s.bool, opposite: s.bool, duration: s.number, timeout: s.number, delay: s.number, count: s.number, forever: s.bool }, f = {}; o.propTypes = d, e.default = o, t.exports = e.default
})(sa, sa.exports); var V0 = sa.exports, la = { exports: {} }; (function (t, e) {
  function n(c) { return c && c.__esModule ? c : { default: c } } function i(c, h) { var g = {}; for (var v in c) h.indexOf(v) >= 0 || Object.prototype.hasOwnProperty.call(c, v) && (g[v] = c[v]); return g } function r(c, h) {
    var g = h.left, v = h.right, _ = h.up, m = h.down, p = h.top, y = h.bottom, w = h.big, S = h.mirror, x = h.opposite, k = (g ? 1 : 0) | (v ? 2 : 0) | (p || m ? 4 : 0) | (y || _ ? 8 : 0) | (S ? 16 : 0) | (x ? 32 : 0) | (c ? 64 : 0) | (w ? 128 : 0); if (f.hasOwnProperty(k)) return f[k]; if (!S != !(c && x)) { var b = [v, g, y, p, m, _]; g = b[0], v = b[1], p = b[2], y = b[3], _ = b[4], m = b[5] } var C = w ? "2000px" : "100%", P = g ? "-" + C : v ? C : "0", M = m || p ? "-" + C : _ || y ? C : "0"; return f[k] = (0, u.animation)(`
    `+ (c ? "to" : "from") + " {opacity: 0;transform: translate3d(" + P + ", " + M + `, 0) rotate3d(0, 0, 1, -120deg);}
	  `+ (c ? "from" : "to") + ` {opacity: 1;transform: none}
  `), f[k]
  } function o() { var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : u.defaults, h = c.children, g = (c.out, c.forever), v = c.timeout, _ = c.duration, m = _ === void 0 ? u.defaults.duration : _, p = c.delay, y = p === void 0 ? u.defaults.delay : p, w = c.count, S = w === void 0 ? u.defaults.count : w, x = i(c, ["children", "out", "forever", "timeout", "duration", "delay", "count"]), k = { make: r, duration: v === void 0 ? m : v, delay: y, forever: g, count: S, style: { animationFillMode: "both" } }; return (0, l.default)(x, k, k, h) } Object.defineProperty(e, "__esModule", { value: !0 }); var s = ht, l = n(s), a = ot, u = Ge, d = { out: a.bool, left: a.bool, right: a.bool, top: a.bool, bottom: a.bool, big: a.bool, mirror: a.bool, opposite: a.bool, duration: a.number, timeout: a.number, delay: a.number, count: a.number, forever: a.bool }, f = {}; o.propTypes = d, e.default = o, t.exports = e.default
})(la, la.exports); var kp = la.exports; const $0 = jn(kp); var aa = { exports: {} }; (function (t, e) {
  function n(c) { return c && c.__esModule ? c : { default: c } } function i(c, h) { var g = {}; for (var v in c) h.indexOf(v) >= 0 || Object.prototype.hasOwnProperty.call(c, v) && (g[v] = c[v]); return g } function r(c, h) {
    var g = h.left, v = h.right, _ = h.up, m = h.down, p = h.top, y = h.bottom, w = h.big, S = h.mirror, x = h.opposite, k = (g ? 1 : 0) | (v ? 2 : 0) | (p || m ? 4 : 0) | (y || _ ? 8 : 0) | (S ? 16 : 0) | (x ? 32 : 0) | (c ? 64 : 0) | (w ? 128 : 0); if (f.hasOwnProperty(k)) return f[k]; var b = g || v || _ || m || p || y, C = void 0, P = void 0; if (b) { if (!S != !(c && x)) { var M = [v, g, y, p, m, _]; g = M[0], v = M[1], p = M[2], y = M[3], _ = M[4], m = M[5] } var T = w ? "2000px" : "100%"; C = g ? "-" + T : v ? T : "0", P = m || p ? "-" + T : _ || y ? T : "0" } return f[k] = (0, u.animation)((c ? "to" : "from") + " {" + (b ? " transform: translate3d(" + C + ", " + P + ", 0);" : "") + `}
     `+ (c ? "from" : "to") + " {transform: none;} "), f[k]
  } function o() { var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : u.defaults, h = c.children, g = (c.out, c.forever), v = c.timeout, _ = c.duration, m = _ === void 0 ? u.defaults.duration : _, p = c.delay, y = p === void 0 ? u.defaults.delay : p, w = c.count, S = w === void 0 ? u.defaults.count : w, x = i(c, ["children", "out", "forever", "timeout", "duration", "delay", "count"]), k = { make: r, duration: v === void 0 ? m : v, delay: y, forever: g, count: S, style: { animationFillMode: "both" }, reverse: x.left }; return (0, a.default)(x, k, k, h) } Object.defineProperty(e, "__esModule", { value: !0 }); var s = ot, l = ht, a = n(l), u = Ge, d = { out: s.bool, left: s.bool, right: s.bool, top: s.bool, bottom: s.bool, big: s.bool, mirror: s.bool, opposite: s.bool, duration: s.number, timeout: s.number, delay: s.number, count: s.number, forever: s.bool }, f = {}; o.propTypes = d, e.default = o, t.exports = e.default
})(aa, aa.exports); var U0 = aa.exports, ua = { exports: {} }; (function (t, e) {
  function n(c) { return c && c.__esModule ? c : { default: c } } function i(c, h) { var g = {}; for (var v in c) h.indexOf(v) >= 0 || Object.prototype.hasOwnProperty.call(c, v) && (g[v] = c[v]); return g } function r(c, h) {
    var g = h.left, v = h.right, _ = h.top, m = h.bottom, p = h.x, y = h.y, w = h.mirror, S = h.opposite, x = (g ? 1 : 0) | (v || y ? 2 : 0) | (_ || p ? 4 : 0) | (m ? 8 : 0) | (w ? 16 : 0) | (S ? 32 : 0) | (c ? 64 : 0); if (f.hasOwnProperty(x)) return f[x]; if (!w != !(c && S)) { var k = [v, g, m, _, y, p]; g = k[0], v = k[1], _ = k[2], m = k[3], p = k[4], y = k[5] } var b = void 0; if (p || y || g || v || _ || m) {
      var C = p || _ || m ? (m ? "-" : "") + "1" : "0", P = y || v || g ? (g ? "-" : "") + "1" : "0"; b = c ? `from {
          transform: perspective(400px);
        }
        30% {
          transform: perspective(400px) rotate3d(`+ C + ", " + P + `, 0, -15deg);
          opacity: 1;
        }
        to {
          transform: perspective(400px) rotate3d(`+ C + ", " + P + `, 0, 90deg);
          opacity: 0;
        }`: `from {
          transform: perspective(400px) rotate3d(`+ C + ", " + P + `, 0, 90deg);
          animation-timing-function: ease-in;
          opacity: 0;
        }
        40% {
          transform: perspective(400px) rotate3d(`+ C + ", " + P + `, 0, -20deg);
          animation-timing-function: ease-in;
        }
        60% {
          transform: perspective(400px) rotate3d(`+ C + ", " + P + `, 0, 10deg);
          opacity: 1;
        }
        80% {
          transform: perspective(400px) rotate3d(`+ C + ", " + P + `, 0, -5deg);
        }
        to {
          transform: perspective(400px);
        }`} else b = `from {
          transform: perspective(400px) rotate3d(0, 1, 0, -360deg);
          animation-timing-function: ease-out;
          opacity: `+ (c ? "1" : "0") + `;
        }
        40% {
          transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg);
          animation-timing-function: ease-out;
        }
        50% {
          transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg);
          animation-timing-function: ease-in;
        }
        to {
          transform: perspective(400px);
          animation-timing-function: ease-in;
          opacity: `+ (c ? "0" : "1") + `;
        }`; return f[x] = (0, u.animation)(b), f[x]
  } function o() { var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : u.defaults, h = c.children, g = (c.out, c.forever), v = c.timeout, _ = c.duration, m = _ === void 0 ? u.defaults.duration : _, p = c.delay, y = p === void 0 ? u.defaults.delay : p, w = c.count, S = w === void 0 ? u.defaults.count : w, x = i(c, ["children", "out", "forever", "timeout", "duration", "delay", "count"]), k = { make: r, duration: v === void 0 ? m : v, delay: y, forever: g, count: S, style: { animationFillMode: "both", backfaceVisibility: "visible" } }; return (0, a.default)(x, k, k, h) } Object.defineProperty(e, "__esModule", { value: !0 }); var s = ot, l = ht, a = n(l), u = Ge, d = { out: s.bool, left: s.bool, right: s.bool, top: s.bool, bottom: s.bool, mirror: s.bool, opposite: s.bool, duration: s.number, timeout: s.number, delay: s.number, count: s.number, forever: s.bool }, f = {}; o.propTypes = d, e.default = o, t.exports = e.default
})(ua, ua.exports); var bp = ua.exports; const Or = jn(bp); var ca = { exports: {} }; (function (t, e) {
  function n(c) { return c && c.__esModule ? c : { default: c } } function i(c, h) { var g = {}; for (var v in c) h.indexOf(v) >= 0 || Object.prototype.hasOwnProperty.call(c, v) && (g[v] = c[v]); return g } function r(c, h) {
    var g = h.left, v = h.right, _ = h.up, m = h.down, p = h.top, y = h.bottom, w = h.mirror, S = h.opposite, x = (g ? 1 : 0) | (v ? 2 : 0) | (p || m ? 4 : 0) | (y || _ ? 8 : 0) | (w ? 16 : 0) | (S ? 32 : 0) | (c ? 64 : 0); if (f.hasOwnProperty(x)) return f[x]; if (!w != !(c && S)) { var k = [v, g, y, p, m, _]; g = k[0], v = k[1], p = k[2], y = k[3], _ = k[4], m = k[5] } var b = "-200deg", C = "center"; return (m || p) && g && (b = "-45deg"), ((m || p) && v || (_ || y) && g) && (b = "45deg"), (_ || y) && v && (b = "-90deg"), (g || v) && (C = (g ? "left" : "right") + " bottom"), f[x] = (0, u.animation)(`
    `+ (c ? "to" : "from") + " { opacity: 0; transform-origin: " + C + "; transform: rotate3d(0, 0, 1, " + b + `);}
    `+ (c ? "from" : "to") + " { opacity: 1; transform-origin: " + C + `; transform: none;}
  `), f[x]
  } function o() { var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : u.defaults, h = c.children, g = (c.out, c.forever), v = c.timeout, _ = c.duration, m = _ === void 0 ? u.defaults.duration : _, p = c.delay, y = p === void 0 ? u.defaults.delay : p, w = c.count, S = w === void 0 ? u.defaults.count : w, x = i(c, ["children", "out", "forever", "timeout", "duration", "delay", "count"]), k = { make: r, duration: v === void 0 ? m : v, delay: y, forever: g, count: S, style: { animationFillMode: "both" } }; return (0, a.default)(x, k, k, h) } Object.defineProperty(e, "__esModule", { value: !0 }); var s = ot, l = ht, a = n(l), u = Ge, d = { out: s.bool, left: s.bool, right: s.bool, top: s.bool, bottom: s.bool, mirror: s.bool, opposite: s.bool, duration: s.number, timeout: s.number, delay: s.number, count: s.number, forever: s.bool }, f = {}; o.propTypes = d, e.default = o, t.exports = e.default
})(ca, ca.exports); var X0 = ca.exports, da = { exports: {} }; (function (t, e) {
  function n(c) { return c && c.__esModule ? c : { default: c } } function i(c, h) { var g = {}; for (var v in c) h.indexOf(v) >= 0 || Object.prototype.hasOwnProperty.call(c, v) && (g[v] = c[v]); return g } function r(c, h) {
    var g = h.left, v = h.right, _ = h.mirror, m = h.opposite, p = (g ? 1 : 0) | (v ? 2 : 0) | (_ ? 16 : 0) | (m ? 32 : 0) | (c ? 64 : 0); if (f.hasOwnProperty(p)) return f[p]; if (!_ != !(c && m)) { var y = [v, g]; g = y[0], v = y[1] } var w = g ? "-100%" : v ? "100%" : "0", S = c ? `from {
        opacity: 1;
      }
      to {
        transform: translate3d(`+ w + `, 0, 0) skewX(30deg);
        opacity: 0;
      }
    `: `from {
        transform: translate3d(`+ w + `, 0, 0) skewX(-30deg);
        opacity: 0;
      }
      60% {
        transform: skewX(20deg);
        opacity: 1;
      }
      80% {
        transform: skewX(-5deg);
        opacity: 1;
      }
      to {
        transform: none;
        opacity: 1;
      }`; return f[p] = (0, u.animation)(S), f[p]
  } function o() { var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : u.defaults, h = c.children, g = (c.out, c.forever), v = c.timeout, _ = c.duration, m = _ === void 0 ? u.defaults.duration : _, p = c.delay, y = p === void 0 ? u.defaults.delay : p, w = c.count, S = w === void 0 ? u.defaults.count : w, x = i(c, ["children", "out", "forever", "timeout", "duration", "delay", "count"]), k = { make: r, duration: v === void 0 ? m : v, delay: y, forever: g, count: S, style: { animationFillMode: "both" } }; return x.left, x.right, x.mirror, x.opposite, (0, l.default)(x, k, k, h) } Object.defineProperty(e, "__esModule", { value: !0 }); var s = ht, l = n(s), a = ot, u = Ge, d = { out: a.bool, left: a.bool, right: a.bool, mirror: a.bool, opposite: a.bool, duration: a.number, timeout: a.number, delay: a.number, count: a.number, forever: a.bool }, f = {}; o.propTypes = d, e.default = o, t.exports = e.default
})(da, da.exports); var Y0 = da.exports, fa = { exports: {} }; (function (t, e) {
  function n(c) { return c && c.__esModule ? c : { default: c } } function i(c, h) { var g = {}; for (var v in c) h.indexOf(v) >= 0 || Object.prototype.hasOwnProperty.call(c, v) && (g[v] = c[v]); return g } function r(c, h) {
    var g = h.left, v = h.right, _ = h.up, m = h.down, p = h.top, y = h.bottom, w = h.mirror, S = h.opposite, x = (g ? 1 : 0) | (v ? 2 : 0) | (p || m ? 4 : 0) | (y || _ ? 8 : 0) | (w ? 16 : 0) | (S ? 32 : 0) | (c ? 64 : 0); if (f.hasOwnProperty(x)) return f[x]; if (!w != !(c && S)) { var k = [v, g, y, p, m, _]; g = k[0], v = k[1], p = k[2], y = k[3], _ = k[4], m = k[5] } var b = g || v, C = p || y || _ || m, P = b || C, M = void 0, T = void 0, L = void 0, I = void 0, D = void 0; return P ? c ? (T = b ? (g ? "" : "-") + "42px" : "0", L = C ? (m || p ? "-" : "") + "60px" : "0", I = b ? (v ? "" : "-") + "2000px" : "0", D = C ? (_ || y ? "" : "-") + "2000px" : "0", M = `40% {
          opacity: 1;
          transform: scale3d(.475, .475, .475) translate3d(`+ T + ", " + L + `, 0);
        }
        to {
          opacity: 0;
          transform: scale(.1) translate3d(`+ I + ", " + D + `, 0);
          transform-origin: `+ (C ? "center bottom" : (g ? "left" : "right") + " center") + `;
        }`) : (T = b ? (g ? "-" : "") + "1000px" : "0", L = C ? (m || p ? "-" : "") + "1000px" : "0", I = b ? (v ? "-" : "") + "10px" : "0", D = C ? (_ || y ? "-" : "") + "60px" : "0", M = `from {
          opacity: 0;
          transform: scale3d(.1, .1, .1) translate3d(`+ T + ", " + L + `, 0);
          animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
        }
        60% {
          opacity: 1;
          transform: scale3d(.475, .475, .475) translate3d(`+ I + ", " + D + `, 0);
          animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
        }`) : M = (c ? "to" : "from") + " {opacity: 0; transform: scale3d(.1, .1, .1);} " + (c ? "from" : "to") + " { opacity: 1; transform: none;}", f[x] = (0, u.animation)(M), f[x]
  } function o() { var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : u.defaults, h = c.children, g = (c.out, c.forever), v = c.timeout, _ = c.duration, m = _ === void 0 ? u.defaults.duration : _, p = c.delay, y = p === void 0 ? u.defaults.delay : p, w = c.count, S = w === void 0 ? u.defaults.count : w, x = i(c, ["children", "out", "forever", "timeout", "duration", "delay", "count"]), k = { make: r, duration: v === void 0 ? m : v, delay: y, forever: g, count: S, style: { animationFillMode: "both" }, reverse: x.left }; return (0, a.default)(x, k, k, h) } Object.defineProperty(e, "__esModule", { value: !0 }); var s = ot, l = ht, a = n(l), u = Ge, d = { out: s.bool, left: s.bool, right: s.bool, top: s.bool, bottom: s.bool, mirror: s.bool, opposite: s.bool, duration: s.number, timeout: s.number, delay: s.number, count: s.number, forever: s.bool }, f = {}; o.propTypes = d, e.default = o, t.exports = e.default
})(fa, fa.exports); var Q0 = fa.exports; (function (t) { function e(f) { return f && f.__esModule ? f : { default: f } } Object.defineProperty(t, "__esModule", { value: !0 }); var n = W0; Object.defineProperty(t, "default", { enumerable: !0, get: function () { return e(n).default } }); var i = xu; Object.defineProperty(t, "Fade", { enumerable: !0, get: function () { return e(i).default } }); var r = V0; Object.defineProperty(t, "Bounce", { enumerable: !0, get: function () { return e(r).default } }); var o = kp; Object.defineProperty(t, "Roll", { enumerable: !0, get: function () { return e(o).default } }); var s = U0; Object.defineProperty(t, "Slide", { enumerable: !0, get: function () { return e(s).default } }); var l = bp; Object.defineProperty(t, "Flip", { enumerable: !0, get: function () { return e(l).default } }), Object.defineProperty(t, "Reveal", { enumerable: !0, get: function () { return e(n).default } }); var a = X0; Object.defineProperty(t, "Rotate", { enumerable: !0, get: function () { return e(a).default } }); var u = Y0; Object.defineProperty(t, "LightSpeed", { enumerable: !0, get: function () { return e(u).default } }); var d = Q0; Object.defineProperty(t, "Zoom", { enumerable: !0, get: function () { return e(d).default } }) })(yp); const oi = jn(yp); var Sp = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, $c = kn.createContext && kn.createContext(Sp), rn = globalThis && globalThis.__assign || function () { return rn = Object.assign || function (t) { for (var e, n = 1, i = arguments.length; n < i; n++) { e = arguments[n]; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]) } return t }, rn.apply(this, arguments) }, K0 = globalThis && globalThis.__rest || function (t, e) { var n = {}; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]); return n }; function Ep(t) { return t && t.map(function (e, n) { return kn.createElement(e.tag, rn({ key: n }, e.attr), Ep(e.child)) }) } function Cp(t) { return function (e) { return kn.createElement(G0, rn({ attr: rn({}, t.attr) }, e), Ep(t.child)) } } function G0(t) { var e = function (n) { var i = t.attr, r = t.size, o = t.title, s = K0(t, ["attr", "size", "title"]), l = r || n.size || "1em", a; return n.className && (a = n.className), t.className && (a = (a ? a + " " : "") + t.className), kn.createElement("svg", rn({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, n.attr, i, s, { className: a, style: rn(rn({ color: t.color || n.color }, n.style), t.style), height: l, width: l, xmlns: "http://www.w3.org/2000/svg" }), o && kn.createElement("title", null, o), t.children) }; return $c !== void 0 ? kn.createElement($c.Consumer, null, function (n) { return e(n) }) : e(Sp) } function Pp(t) { return Cp({ tag: "svg", attr: { role: "img", viewBox: "0 0 24 24" }, child: [{ tag: "title", attr: {}, child: [] }, { tag: "path", attr: { d: "M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z" } }] })(t) } function Op(t) { return Cp({ tag: "svg", attr: { viewBox: "0 0 24 24" }, child: [{ tag: "g", attr: { id: "Twitter" }, child: [{ tag: "path", attr: { d: "M19.913,5.322a1.034,1.034,0,0,1,.837,1.629L19.708,8.432c-.064,5.086-1.765,8.539-5.056,10.264A10.917,10.917,0,0,1,9.6,19.835a12.233,12.233,0,0,1-6.2-1.524.76.76,0,0,1-.317-.8.768.768,0,0,1,.63-.6,20.6,20.6,0,0,0,3.745-.886C2,13.5,3.19,7.824,3.71,6.081a1.028,1.028,0,0,1,1.729-.422,9.931,9.931,0,0,0,5.995,2.95A4.188,4.188,0,0,1,12.725,5.3a4.125,4.125,0,0,1,5.7.02ZM4.521,17.794c1.862.872,6.226,1.819,9.667.016,2.955-1.549,4.476-4.732,4.521-9.461a.771.771,0,0,1,.142-.436l1.081-1.538-.041-.053c-.518-.007-1.029-.014-1.55,0a.835.835,0,0,1-.547-.221,3.13,3.13,0,0,0-4.383-.072,3.174,3.174,0,0,0-.935,2.87.646.646,0,0,1-.154.545.591.591,0,0,1-.516.205A10.924,10.924,0,0,1,4.722,6.354c-.67,2.078-1.52,7.094,3.869,9.065a.632.632,0,0,1,.416.538.625.625,0,0,1-.3.6A13.178,13.178,0,0,1,4.521,17.794ZM11.875,8.65h0Zm7.793-.161,0,0Z" } }] }] })(t) } const Z0 = () => E.jsxs("div", { className: "footer", children: [E.jsx("div", { className: "container", children: E.jsxs("div", { className: "ft1", children: [E.jsx(oi, { bottom: !0, duration: 800, delay: 800, children: E.jsx("h2", { children: "Join the community!" }) }), E.jsx(oi, { duration: 800, delay: 800, children: E.jsxs("div", { children: [E.jsx("a", { href: "https://t.me/XAIAMOON", target: "_blank", children: E.jsx(Pp, {}) }), E.jsx("a", { href: " https://twitter.com/Xx_erc20", target: "_blank", children: E.jsx(Op, {}) })] }) })] }) }), E.jsx("div", { className: "copyright_wrap", children: E.jsx(oi, { top: !0, duration: 800, delay: 800, children: E.jsx("p", { children: "COPYRIGHT 2023. AI. ALL RIGHTS RESERVED." }) }) })] }); var ha = { exports: {} }; (function (t, e) {
  function n(h) { return h && h.__esModule ? h : { default: h } } function i(h, g) { var v = {}; for (var _ in h) g.indexOf(_) >= 0 || Object.prototype.hasOwnProperty.call(h, _) && (v[_] = h[_]); return v } function r() { return c || (c = (0, u.animation)(f)) } function o() { var h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : u.defaults, g = h.children, v = (h.out, h.timeout), _ = h.duration, m = _ === void 0 ? u.defaults.duration : _, p = h.delay, y = p === void 0 ? u.defaults.delay : p, w = h.count, S = w === void 0 ? u.defaults.count : w, x = h.forever, k = i(h, ["children", "out", "timeout", "duration", "delay", "count", "forever"]), b = { make: r, duration: v === void 0 ? m : v, delay: y, forever: x, count: S, style: { animationFillMode: "both" } }; return (0, a.default)(k, b, !1, g, !0) } Object.defineProperty(e, "__esModule", { value: !0 }); var s = ot, l = ht, a = n(l), u = Ge, d = { duration: s.number, timeout: s.number, delay: s.number, count: s.number, forever: s.bool }, f = `
 from, 20%, 53%, 80%, to {
    animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    transform: translate3d(0,0,0);
  }

  40%, 43% {
    animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
    transform: translate3d(0, -30px, 0);
  }

  70% {
    animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
    transform: translate3d(0, -15px, 0);
  }

  90% {
    transform: translate3d(0, -4px, 0);
}
`, c = !1; o.propTypes = d, e.default = o, t.exports = e.default
})(ha, ha.exports); var q0 = ha.exports; const Uc = jn(q0), J0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAEAQAAABQ8GUWAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QAAKqNIzIAAAAJcEhZcwAAAGAAAABgAPBrQs8AAAAHdElNRQflCBwOKhNBqSOLAAABaElEQVR42u3aLU7EUBTF8XObCpIyMwkMmo5CjUaMriLBsIXa6WpQKNCtIhi6AFIkOEzpBvgoVCDIOwgIS+gVPb8V/G+eeu8+MBwckFXFMAycijAMZFkyLJdGVhVwdoYpYlka2ffAfO7d4qPvI7BtvTPcsG0joCiAtzfvlvG9vsK2WwMAcm8POD4Gd3e9s0ZhwwA0jdkUD15ERERERESAv+vwZgNkGbCz4x00jq8voK7N7u6MIc9hFxeAmXfWuEggz43sOuDw0DvHR9dFYJJ4Z/hJkgi4uvLOcMPLS2OIY1hRgCcnsMXCu2mcwd/fYTc34Pm5d4qIiIiIiIh4+H8GI/f3gYlch9H3Zi8vf4OvVuT9vfffxfE/SzYNmabGUNewLPM+Ex+3t0Z+fACzmXeKj8/PCHh89M7w8/BgDOs17PoaSFPvnHE9P4Onp7+boRDHsKOjSW2G+PRk0fe3d4mIiIiIiIiIyOh+AGcSXehVlzN5AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA4LTI4VDE0OjQyOjE5KzAwOjAwBZJ9LQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wOC0yOFQxNDo0MjoxOSswMDowMHTPxZEAAAAASUVORK5CYII=", ev = () => { const [t, e] = Oe.useState(!1); return E.jsxs("div", { className: "header", children: [E.jsx("div", { onClick: () => { e(!1) }, className: "overlay", style: { display: t ? "block" : "none", zIndex: t ? "100" : "-1" } }), E.jsxs("div", { className: "container", children: [E.jsx("a", { href: "#home", children: E.jsx("div", { className: "logo_brand", children: E.jsx("img", { src: "https://raw.githubusercontent.com/WebSiteLaunchPad/xerc20/main/logo.png", alt: "AI" }) }) }), E.jsxs("div", { className: `menu_wrap ${t ? "show_sidebar" : "close_sidebar"}`, children: [E.jsx("a", { onClick: () => { e(!1) }, href: "#home", children: "Home" }), E.jsx("a", { onClick: () => { e(!1) }, href: "#vision", children: "About" }), E.jsx("a", { onClick: () => { e(!1) }, href: "#tokenomics", children: "Tokenomics" }), E.jsx("a", { onClick: () => { e(!1) }, href: "#roadmap", children: "Roadmap" }), E.jsxs("div", { className: "social", children: [E.jsx(Uc, { duration: 1e3, delay: 100, children: E.jsx("a", { onClick: () => { e(!1) }, className: "twitter", href: " https://twitter.com/Xx_erc20", target: "_blank", children: E.jsx(Op, {}) }) }), E.jsx(Uc, { duration: 1e3, delay: 100, children: E.jsx("a", { onClick: () => { e(!1) }, className: "telegram", href: "https://t.me/XAIAMOON", target: "_blank", children: E.jsx(Pp, {}) }) })] })] }), E.jsx("button", { onClick: () => { e(!t) }, className: "menu_btn", children: E.jsx("img", { src: J0, alt: "" }) })] })] }) }; const tv = () => E.jsx(E.Fragment, { children: E.jsx("a", { class: "fancy", href: "https://app.uniswap.org/#/swap", target: "blank", children: E.jsx("span", { class: "text", children: "BUYTOKEN Link" }) }) }), nv = () => E.jsx("div", { id: "home", className: "banner_bg parallax_bg banner_section", children: E.jsx("div", { className: "overlay", children: E.jsx("div", { className: "cta_wrap", children: E.jsx(tv, {}) }) }) }); var pa = { exports: {} }; (function (t, e) {
  function n(h) { return h && h.__esModule ? h : { default: h } } function i(h, g) { var v = {}; for (var _ in h) g.indexOf(_) >= 0 || Object.prototype.hasOwnProperty.call(h, _) && (v[_] = h[_]); return v } function r() { return c || (c = (0, u.animation)(f)) } function o() { var h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : u.defaults, g = h.children, v = (h.out, h.timeout), _ = h.duration, m = _ === void 0 ? u.defaults.duration : _, p = h.delay, y = p === void 0 ? u.defaults.delay : p, w = h.count, S = w === void 0 ? u.defaults.count : w, x = h.forever, k = i(h, ["children", "out", "timeout", "duration", "delay", "count", "forever"]), b = { make: r, duration: v === void 0 ? m : v, delay: y, forever: x, count: S, style: { animationFillMode: "both" } }; return (0, a.default)(k, b, !1, g, !0) } Object.defineProperty(e, "__esModule", { value: !0 }); var s = ot, l = ht, a = n(l), u = Ge, d = { duration: s.number, timeout: s.number, delay: s.number, count: s.number, forever: s.bool }, f = `
	from {
    transform: scale3d(1, 1, 1);
  }

  50% {
    transform: scale3d(1.05, 1.05, 1.05);
  }

  to {
    transform: scale3d(1, 1, 1);
}
`, c = !1; o.propTypes = d, e.default = o, t.exports = e.default
})(pa, pa.exports); var iv = pa.exports; const Mr = jn(iv), rv = () => E.jsx("div", { className: "our_vision ourvision_bg parallax_bg", id: "vision", children: E.jsxs("div", { className: "container", children: [E.jsx("div", { className: "our_vision_content", children: E.jsx("div", { className: "our_vision_heading", children: E.jsxs("div", { className: "token_heading", children: [E.jsx(Mr, { duration: 1e3, delay: 800, children: E.jsx("div", {}) }), E.jsx(Or, { top: !0, duration: 800, delay: 800, children: E.jsx("h1", { children: "About" }) })] }) }) }), E.jsx("div", { className: "our_vision_details", children: E.jsx(oi, { top: !0, duration: 800, delay: 800, children: E.jsx("p", { children: "Embrace the AI experience and join our vibrant community as we embark on a thrilling journey in the ever-evolving world of crypto meme tokens. Get ready to discover, grow, and prosper with AI!" }) }) })] }) }), Mi = ({ color: t }) => E.jsx("div", { className: "page_divider", style: { backgroundColor: t === "green" ? "#61ce70" : "" } });/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */function Tr(t) { return t + .5 | 0 } const Ut = (t, e, n) => Math.max(Math.min(t, n), e); function Fi(t) { return Ut(Tr(t * 2.55), 0, 255) } function on(t) { return Ut(Tr(t * 255), 0, 255) } function Ot(t) { return Ut(Tr(t / 2.55) / 100, 0, 1) } function Xc(t) { return Ut(Tr(t * 100), 0, 100) } const Ze = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, ga = [..."0123456789ABCDEF"], ov = t => ga[t & 15], sv = t => ga[(t & 240) >> 4] + ga[t & 15], Gr = t => (t & 240) >> 4 === (t & 15), lv = t => Gr(t.r) && Gr(t.g) && Gr(t.b) && Gr(t.a); function av(t) { var e = t.length, n; return t[0] === "#" && (e === 4 || e === 5 ? n = { r: 255 & Ze[t[1]] * 17, g: 255 & Ze[t[2]] * 17, b: 255 & Ze[t[3]] * 17, a: e === 5 ? Ze[t[4]] * 17 : 255 } : (e === 7 || e === 9) && (n = { r: Ze[t[1]] << 4 | Ze[t[2]], g: Ze[t[3]] << 4 | Ze[t[4]], b: Ze[t[5]] << 4 | Ze[t[6]], a: e === 9 ? Ze[t[7]] << 4 | Ze[t[8]] : 255 })), n } const uv = (t, e) => t < 255 ? e(t) : ""; function cv(t) { var e = lv(t) ? ov : sv; return t ? "#" + e(t.r) + e(t.g) + e(t.b) + uv(t.a, e) : void 0 } const dv = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/; function Mp(t, e, n) { const i = e * Math.min(n, 1 - n), r = (o, s = (o + t / 30) % 12) => n - i * Math.max(Math.min(s - 3, 9 - s, 1), -1); return [r(0), r(8), r(4)] } function fv(t, e, n) { const i = (r, o = (r + t / 60) % 6) => n - n * e * Math.max(Math.min(o, 4 - o, 1), 0); return [i(5), i(3), i(1)] } function hv(t, e, n) { const i = Mp(t, 1, .5); let r; for (e + n > 1 && (r = 1 / (e + n), e *= r, n *= r), r = 0; r < 3; r++)i[r] *= 1 - e - n, i[r] += e; return i } function pv(t, e, n, i, r) { return t === r ? (e - n) / i + (e < n ? 6 : 0) : e === r ? (n - t) / i + 2 : (t - e) / i + 4 } function _u(t) { const n = t.r / 255, i = t.g / 255, r = t.b / 255, o = Math.max(n, i, r), s = Math.min(n, i, r), l = (o + s) / 2; let a, u, d; return o !== s && (d = o - s, u = l > .5 ? d / (2 - o - s) : d / (o + s), a = pv(n, i, r, d, o), a = a * 60 + .5), [a | 0, u || 0, l] } function wu(t, e, n, i) { return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, n, i)).map(on) } function ku(t, e, n) { return wu(Mp, t, e, n) } function gv(t, e, n) { return wu(hv, t, e, n) } function mv(t, e, n) { return wu(fv, t, e, n) } function Tp(t) { return (t % 360 + 360) % 360 } function vv(t) { const e = dv.exec(t); let n = 255, i; if (!e) return; e[5] !== i && (n = e[6] ? Fi(+e[5]) : on(+e[5])); const r = Tp(+e[2]), o = +e[3] / 100, s = +e[4] / 100; return e[1] === "hwb" ? i = gv(r, o, s) : e[1] === "hsv" ? i = mv(r, o, s) : i = ku(r, o, s), { r: i[0], g: i[1], b: i[2], a: n } } function yv(t, e) { var n = _u(t); n[0] = Tp(n[0] + e), n = ku(n), t.r = n[0], t.g = n[1], t.b = n[2] } function xv(t) { if (!t) return; const e = _u(t), n = e[0], i = Xc(e[1]), r = Xc(e[2]); return t.a < 255 ? `hsla(${n}, ${i}%, ${r}%, ${Ot(t.a)})` : `hsl(${n}, ${i}%, ${r}%)` } const Yc = { x: "dark", Z: "light", Y: "re", X: "blu", W: "gr", V: "medium", U: "slate", A: "ee", T: "ol", S: "or", B: "ra", C: "lateg", D: "ights", R: "in", Q: "turquois", E: "hi", P: "ro", O: "al", N: "le", M: "de", L: "yello", F: "en", K: "ch", G: "arks", H: "ea", I: "ightg", J: "wh" }, Qc = { OiceXe: "f0f8ff", antiquewEte: "faebd7", aqua: "ffff", aquamarRe: "7fffd4", azuY: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "0", blanKedOmond: "ffebcd", Xe: "ff", XeviTet: "8a2be2", bPwn: "a52a2a", burlywood: "deb887", caMtXe: "5f9ea0", KartYuse: "7fff00", KocTate: "d2691e", cSO: "ff7f50", cSnflowerXe: "6495ed", cSnsilk: "fff8dc", crimson: "dc143c", cyan: "ffff", xXe: "8b", xcyan: "8b8b", xgTMnPd: "b8860b", xWay: "a9a9a9", xgYF: "6400", xgYy: "a9a9a9", xkhaki: "bdb76b", xmagFta: "8b008b", xTivegYF: "556b2f", xSange: "ff8c00", xScEd: "9932cc", xYd: "8b0000", xsOmon: "e9967a", xsHgYF: "8fbc8f", xUXe: "483d8b", xUWay: "2f4f4f", xUgYy: "2f4f4f", xQe: "ced1", xviTet: "9400d3", dAppRk: "ff1493", dApskyXe: "bfff", dimWay: "696969", dimgYy: "696969", dodgerXe: "1e90ff", fiYbrick: "b22222", flSOwEte: "fffaf0", foYstWAn: "228b22", fuKsia: "ff00ff", gaRsbSo: "dcdcdc", ghostwEte: "f8f8ff", gTd: "ffd700", gTMnPd: "daa520", Way: "808080", gYF: "8000", gYFLw: "adff2f", gYy: "808080", honeyMw: "f0fff0", hotpRk: "ff69b4", RdianYd: "cd5c5c", Rdigo: "4b0082", ivSy: "fffff0", khaki: "f0e68c", lavFMr: "e6e6fa", lavFMrXsh: "fff0f5", lawngYF: "7cfc00", NmoncEffon: "fffacd", ZXe: "add8e6", ZcSO: "f08080", Zcyan: "e0ffff", ZgTMnPdLw: "fafad2", ZWay: "d3d3d3", ZgYF: "90ee90", ZgYy: "d3d3d3", ZpRk: "ffb6c1", ZsOmon: "ffa07a", ZsHgYF: "20b2aa", ZskyXe: "87cefa", ZUWay: "778899", ZUgYy: "778899", ZstAlXe: "b0c4de", ZLw: "ffffe0", lime: "ff00", limegYF: "32cd32", lRF: "faf0e6", magFta: "ff00ff", maPon: "800000", VaquamarRe: "66cdaa", VXe: "cd", VScEd: "ba55d3", VpurpN: "9370db", VsHgYF: "3cb371", VUXe: "7b68ee", VsprRggYF: "fa9a", VQe: "48d1cc", VviTetYd: "c71585", midnightXe: "191970", mRtcYam: "f5fffa", mistyPse: "ffe4e1", moccasR: "ffe4b5", navajowEte: "ffdead", navy: "80", Tdlace: "fdf5e6", Tive: "808000", TivedBb: "6b8e23", Sange: "ffa500", SangeYd: "ff4500", ScEd: "da70d6", pOegTMnPd: "eee8aa", pOegYF: "98fb98", pOeQe: "afeeee", pOeviTetYd: "db7093", papayawEp: "ffefd5", pHKpuff: "ffdab9", peru: "cd853f", pRk: "ffc0cb", plum: "dda0dd", powMrXe: "b0e0e6", purpN: "800080", YbeccapurpN: "663399", Yd: "ff0000", Psybrown: "bc8f8f", PyOXe: "4169e1", saddNbPwn: "8b4513", sOmon: "fa8072", sandybPwn: "f4a460", sHgYF: "2e8b57", sHshell: "fff5ee", siFna: "a0522d", silver: "c0c0c0", skyXe: "87ceeb", UXe: "6a5acd", UWay: "708090", UgYy: "708090", snow: "fffafa", sprRggYF: "ff7f", stAlXe: "4682b4", tan: "d2b48c", teO: "8080", tEstN: "d8bfd8", tomato: "ff6347", Qe: "40e0d0", viTet: "ee82ee", JHt: "f5deb3", wEte: "ffffff", wEtesmoke: "f5f5f5", Lw: "ffff00", LwgYF: "9acd32" }; function _v() { const t = {}, e = Object.keys(Qc), n = Object.keys(Yc); let i, r, o, s, l; for (i = 0; i < e.length; i++) { for (s = l = e[i], r = 0; r < n.length; r++)o = n[r], l = l.replace(o, Yc[o]); o = parseInt(Qc[s], 16), t[l] = [o >> 16 & 255, o >> 8 & 255, o & 255] } return t } let Zr; function wv(t) { Zr || (Zr = _v(), Zr.transparent = [0, 0, 0, 0]); const e = Zr[t.toLowerCase()]; return e && { r: e[0], g: e[1], b: e[2], a: e.length === 4 ? e[3] : 255 } } const kv = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/; function bv(t) { const e = kv.exec(t); let n = 255, i, r, o; if (e) { if (e[7] !== i) { const s = +e[7]; n = e[8] ? Fi(s) : Ut(s * 255, 0, 255) } return i = +e[1], r = +e[3], o = +e[5], i = 255 & (e[2] ? Fi(i) : Ut(i, 0, 255)), r = 255 & (e[4] ? Fi(r) : Ut(r, 0, 255)), o = 255 & (e[6] ? Fi(o) : Ut(o, 0, 255)), { r: i, g: r, b: o, a: n } } } function Sv(t) { return t && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${Ot(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) } const tl = t => t <= .0031308 ? t * 12.92 : Math.pow(t, 1 / 2.4) * 1.055 - .055, In = t => t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4); function Ev(t, e, n) { const i = In(Ot(t.r)), r = In(Ot(t.g)), o = In(Ot(t.b)); return { r: on(tl(i + n * (In(Ot(e.r)) - i))), g: on(tl(r + n * (In(Ot(e.g)) - r))), b: on(tl(o + n * (In(Ot(e.b)) - o))), a: t.a + n * (e.a - t.a) } } function qr(t, e, n) { if (t) { let i = _u(t); i[e] = Math.max(0, Math.min(i[e] + i[e] * n, e === 0 ? 360 : 1)), i = ku(i), t.r = i[0], t.g = i[1], t.b = i[2] } } function Rp(t, e) { return t && Object.assign(e || {}, t) } function Kc(t) { var e = { r: 0, g: 0, b: 0, a: 255 }; return Array.isArray(t) ? t.length >= 3 && (e = { r: t[0], g: t[1], b: t[2], a: 255 }, t.length > 3 && (e.a = on(t[3]))) : (e = Rp(t, { r: 0, g: 0, b: 0, a: 1 }), e.a = on(e.a)), e } function Cv(t) { return t.charAt(0) === "r" ? bv(t) : vv(t) } class xr { constructor(e) { if (e instanceof xr) return e; const n = typeof e; let i; n === "object" ? i = Kc(e) : n === "string" && (i = av(e) || wv(e) || Cv(e)), this._rgb = i, this._valid = !!i } get valid() { return this._valid } get rgb() { var e = Rp(this._rgb); return e && (e.a = Ot(e.a)), e } set rgb(e) { this._rgb = Kc(e) } rgbString() { return this._valid ? Sv(this._rgb) : void 0 } hexString() { return this._valid ? cv(this._rgb) : void 0 } hslString() { return this._valid ? xv(this._rgb) : void 0 } mix(e, n) { if (e) { const i = this.rgb, r = e.rgb; let o; const s = n === o ? .5 : n, l = 2 * s - 1, a = i.a - r.a, u = ((l * a === -1 ? l : (l + a) / (1 + l * a)) + 1) / 2; o = 1 - u, i.r = 255 & u * i.r + o * r.r + .5, i.g = 255 & u * i.g + o * r.g + .5, i.b = 255 & u * i.b + o * r.b + .5, i.a = s * i.a + (1 - s) * r.a, this.rgb = i } return this } interpolate(e, n) { return e && (this._rgb = Ev(this._rgb, e._rgb, n)), this } clone() { return new xr(this.rgb) } alpha(e) { return this._rgb.a = on(e), this } clearer(e) { const n = this._rgb; return n.a *= 1 - e, this } greyscale() { const e = this._rgb, n = Tr(e.r * .3 + e.g * .59 + e.b * .11); return e.r = e.g = e.b = n, this } opaquer(e) { const n = this._rgb; return n.a *= 1 + e, this } negate() { const e = this._rgb; return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this } lighten(e) { return qr(this._rgb, 2, e), this } darken(e) { return qr(this._rgb, 2, -e), this } saturate(e) { return qr(this._rgb, 1, e), this } desaturate(e) { return qr(this._rgb, 1, -e), this } rotate(e) { return yv(this._rgb, e), this } }/*!
 * Chart.js v4.3.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */function bt() { } const Pv = (() => { let t = 0; return () => t++ })(); function te(t) { return t === null || typeof t > "u" } function oe(t) { if (Array.isArray && Array.isArray(t)) return !0; const e = Object.prototype.toString.call(t); return e.slice(0, 7) === "[object" && e.slice(-6) === "Array]" } function W(t) { return t !== null && Object.prototype.toString.call(t) === "[object Object]" } function he(t) { return (typeof t == "number" || t instanceof Number) && isFinite(+t) } function Ve(t, e) { return he(t) ? t : e } function U(t, e) { return typeof t > "u" ? e : t } const Ov = (t, e) => typeof t == "string" && t.endsWith("%") ? parseFloat(t) / 100 * e : +t; function K(t, e, n) { if (t && typeof t.call == "function") return t.apply(n, e) } function $(t, e, n, i) { let r, o, s; if (oe(t)) if (o = t.length, i) for (r = o - 1; r >= 0; r--)e.call(n, t[r], r); else for (r = 0; r < o; r++)e.call(n, t[r], r); else if (W(t)) for (s = Object.keys(t), o = s.length, r = 0; r < o; r++)e.call(n, t[s[r]], s[r]) } function Go(t, e) { let n, i, r, o; if (!t || !e || t.length !== e.length) return !1; for (n = 0, i = t.length; n < i; ++n)if (r = t[n], o = e[n], r.datasetIndex !== o.datasetIndex || r.index !== o.index) return !1; return !0 } function Zo(t) { if (oe(t)) return t.map(Zo); if (W(t)) { const e = Object.create(null), n = Object.keys(t), i = n.length; let r = 0; for (; r < i; ++r)e[n[r]] = Zo(t[n[r]]); return e } return t } function Ap(t) { return ["__proto__", "prototype", "constructor"].indexOf(t) === -1 } function Mv(t, e, n, i) { if (!Ap(t)) return; const r = e[t], o = n[t]; W(r) && W(o) ? _r(r, o, i) : e[t] = Zo(o) } function _r(t, e, n) { const i = oe(e) ? e : [e], r = i.length; if (!W(t)) return t; n = n || {}; const o = n.merger || Mv; let s; for (let l = 0; l < r; ++l) { if (s = i[l], !W(s)) continue; const a = Object.keys(s); for (let u = 0, d = a.length; u < d; ++u)o(a[u], t, s, n) } return t } function Ji(t, e) { return _r(t, e, { merger: Tv }) } function Tv(t, e, n) { if (!Ap(t)) return; const i = e[t], r = n[t]; W(i) && W(r) ? Ji(i, r) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = Zo(r)) } const Gc = { "": t => t, x: t => t.x, y: t => t.y }; function Rv(t) { const e = t.split("."), n = []; let i = ""; for (const r of e) i += r, i.endsWith("\\") ? i = i.slice(0, -1) + "." : (n.push(i), i = ""); return n } function Av(t) { const e = Rv(t); return n => { for (const i of e) { if (i === "") break; n = n && n[i] } return n } } function qo(t, e) { return (Gc[e] || (Gc[e] = Av(e)))(t) } function bu(t) { return t.charAt(0).toUpperCase() + t.slice(1) } const Jo = t => typeof t < "u", an = t => typeof t == "function", Zc = (t, e) => { if (t.size !== e.size) return !1; for (const n of t) if (!e.has(n)) return !1; return !0 }; function jv(t) { return t.type === "mouseup" || t.type === "click" || t.type === "contextmenu" } const we = Math.PI, xe = 2 * we, es = Number.POSITIVE_INFINITY, Lv = we / 180, ue = we / 2, fn = we / 4, qc = we * 2 / 3, Xt = Math.log10, ts = Math.sign; function ko(t, e, n) { return Math.abs(t - e) < n } function Jc(t) { const e = Math.round(t); t = ko(t, e, t / 1e3) ? e : t; const n = Math.pow(10, Math.floor(Xt(t))), i = t / n; return (i <= 1 ? 1 : i <= 2 ? 2 : i <= 5 ? 5 : 10) * n } function Dv(t) { const e = [], n = Math.sqrt(t); let i; for (i = 1; i < n; i++)t % i === 0 && (e.push(i), e.push(t / i)); return n === (n | 0) && e.push(n), e.sort((r, o) => r - o).pop(), e } function ns(t) { return !isNaN(parseFloat(t)) && isFinite(t) } function Nv(t, e) { const n = Math.round(t); return n - e <= t && n + e >= t } function jp(t, e, n) { let i, r, o; for (i = 0, r = t.length; i < r; i++)o = t[i][n], isNaN(o) || (e.min = Math.min(e.min, o), e.max = Math.max(e.max, o)) } function Yt(t) { return t * (we / 180) } function Su(t) { return t * (180 / we) } function ed(t) { if (!he(t)) return; let e = 1, n = 0; for (; Math.round(t * e) / e !== t;)e *= 10, n++; return n } function Lp(t, e) { const n = e.x - t.x, i = e.y - t.y, r = Math.sqrt(n * n + i * i); let o = Math.atan2(i, n); return o < -.5 * we && (o += xe), { angle: o, distance: r } } function zv(t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) } function yt(t) { return (t % xe + xe) % xe } function Dp(t, e, n, i) { const r = yt(t), o = yt(e), s = yt(n), l = yt(o - r), a = yt(s - r), u = yt(r - o), d = yt(r - s); return r === o || r === s || i && o === s || l > a && u < d } function tt(t, e, n) { return Math.max(e, Math.min(n, t)) } function Iv(t) { return tt(t, -32768, 32767) } function Bi(t, e, n, i = 1e-6) { return t >= Math.min(e, n) - i && t <= Math.max(e, n) + i } function Eu(t, e, n) { n = n || (s => t[s] < e); let i = t.length - 1, r = 0, o; for (; i - r > 1;)o = r + i >> 1, n(o) ? r = o : i = o; return { lo: r, hi: i } } const ma = (t, e, n, i) => Eu(t, n, i ? r => { const o = t[r][e]; return o < n || o === n && t[r + 1][e] === n } : r => t[r][e] < n), Fv = (t, e, n) => Eu(t, n, i => t[i][e] >= n); function Bv(t, e, n) { let i = 0, r = t.length; for (; i < r && t[i] < e;)i++; for (; r > i && t[r - 1] > n;)r--; return i > 0 || r < t.length ? t.slice(i, r) : t } const Np = ["push", "pop", "shift", "splice", "unshift"]; function Hv(t, e) { if (t._chartjs) { t._chartjs.listeners.push(e); return } Object.defineProperty(t, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [e] } }), Np.forEach(n => { const i = "_onData" + bu(n), r = t[n]; Object.defineProperty(t, n, { configurable: !0, enumerable: !1, value(...o) { const s = r.apply(this, o); return t._chartjs.listeners.forEach(l => { typeof l[i] == "function" && l[i](...o) }), s } }) }) } function td(t, e) { const n = t._chartjs; if (!n) return; const i = n.listeners, r = i.indexOf(e); r !== -1 && i.splice(r, 1), !(i.length > 0) && (Np.forEach(o => { delete t[o] }), delete t._chartjs) } function Wv(t) { const e = new Set(t); return e.size === t.length ? t : Array.from(e) } const zp = function () { return typeof window > "u" ? function (t) { return t() } : window.requestAnimationFrame }(); function Ip(t, e) { let n = [], i = !1; return function (...r) { n = r, i || (i = !0, zp.call(window, () => { i = !1, t.apply(e, n) })) } } function Vv(t, e) { let n; return function (...i) { return e ? (clearTimeout(n), n = setTimeout(t, e, i)) : t.apply(this, i), e } } const Fp = t => t === "start" ? "left" : t === "end" ? "right" : "center", We = (t, e, n) => t === "start" ? e : t === "end" ? n : (e + n) / 2, $v = (t, e, n, i) => t === (i ? "left" : "right") ? n : t === "center" ? (e + n) / 2 : e, Jr = t => t === 0 || t === 1, nd = (t, e, n) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * xe / n)), id = (t, e, n) => Math.pow(2, -10 * t) * Math.sin((t - e) * xe / n) + 1, er = { linear: t => t, easeInQuad: t => t * t, easeOutQuad: t => -t * (t - 2), easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1), easeInCubic: t => t * t * t, easeOutCubic: t => (t -= 1) * t * t + 1, easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2), easeInQuart: t => t * t * t * t, easeOutQuart: t => -((t -= 1) * t * t * t - 1), easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2), easeInQuint: t => t * t * t * t * t, easeOutQuint: t => (t -= 1) * t * t * t * t + 1, easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2), easeInSine: t => -Math.cos(t * ue) + 1, easeOutSine: t => Math.sin(t * ue), easeInOutSine: t => -.5 * (Math.cos(we * t) - 1), easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)), easeOutExpo: t => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1, easeInOutExpo: t => Jr(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (t * 2 - 1)) : .5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2), easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1), easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t), easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1), easeInElastic: t => Jr(t) ? t : nd(t, .075, .3), easeOutElastic: t => Jr(t) ? t : id(t, .075, .3), easeInOutElastic(t) { return Jr(t) ? t : t < .5 ? .5 * nd(t * 2, .1125, .45) : .5 + .5 * id(t * 2 - 1, .1125, .45) }, easeInBack(t) { return t * t * ((1.70158 + 1) * t - 1.70158) }, easeOutBack(t) { return (t -= 1) * t * ((1.70158 + 1) * t + 1.70158) + 1 }, easeInOutBack(t) { let e = 1.70158; return (t /= .5) < 1 ? .5 * (t * t * (((e *= 1.525) + 1) * t - e)) : .5 * ((t -= 2) * t * (((e *= 1.525) + 1) * t + e) + 2) }, easeInBounce: t => 1 - er.easeOutBounce(1 - t), easeOutBounce(t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }, easeInOutBounce: t => t < .5 ? er.easeInBounce(t * 2) * .5 : er.easeOutBounce(t * 2 - 1) * .5 + .5 }; function Bp(t) { if (t && typeof t == "object") { const e = t.toString(); return e === "[object CanvasPattern]" || e === "[object CanvasGradient]" } return !1 } function rd(t) { return Bp(t) ? t : new xr(t) } function nl(t) { return Bp(t) ? t : new xr(t).saturate(.5).darken(.1).hexString() } const Uv = ["x", "y", "borderWidth", "radius", "tension"], Xv = ["color", "borderColor", "backgroundColor"]; function Yv(t) { t.set("animation", { delay: void 0, duration: 1e3, easing: "easeOutQuart", fn: void 0, from: void 0, loop: void 0, to: void 0, type: void 0 }), t.describe("animation", { _fallback: !1, _indexable: !1, _scriptable: e => e !== "onProgress" && e !== "onComplete" && e !== "fn" }), t.set("animations", { colors: { type: "color", properties: Xv }, numbers: { type: "number", properties: Uv } }), t.describe("animations", { _fallback: "animation" }), t.set("transitions", { active: { animation: { duration: 400 } }, resize: { animation: { duration: 0 } }, show: { animations: { colors: { from: "transparent" }, visible: { type: "boolean", duration: 0 } } }, hide: { animations: { colors: { to: "transparent" }, visible: { type: "boolean", easing: "linear", fn: e => e | 0 } } } }) } function Qv(t) { t.set("layout", { autoPadding: !0, padding: { top: 0, right: 0, bottom: 0, left: 0 } }) } const od = new Map; function Kv(t, e) { e = e || {}; const n = t + JSON.stringify(e); let i = od.get(n); return i || (i = new Intl.NumberFormat(t, e), od.set(n, i)), i } function Cu(t, e, n) { return Kv(e, n).format(t) } const Hp = { values(t) { return oe(t) ? t : "" + t }, numeric(t, e, n) { if (t === 0) return "0"; const i = this.chart.options.locale; let r, o = t; if (n.length > 1) { const u = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value)); (u < 1e-4 || u > 1e15) && (r = "scientific"), o = Gv(t, n) } const s = Xt(Math.abs(o)), l = isNaN(s) ? 1 : Math.max(Math.min(-1 * Math.floor(s), 20), 0), a = { notation: r, minimumFractionDigits: l, maximumFractionDigits: l }; return Object.assign(a, this.options.ticks.format), Cu(t, i, a) }, logarithmic(t, e, n) { if (t === 0) return "0"; const i = n[e].significand || t / Math.pow(10, Math.floor(Xt(t))); return [1, 2, 3, 5, 10, 15].includes(i) || e > .8 * n.length ? Hp.numeric.call(this, t, e, n) : "" } }; function Gv(t, e) { let n = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value; return Math.abs(n) >= 1 && t !== Math.floor(t) && (n = t - Math.floor(t)), n } var Cs = { formatters: Hp }; function Zv(t) { t.set("scale", { display: !0, offset: !1, reverse: !1, beginAtZero: !1, bounds: "ticks", grace: 0, grid: { display: !0, lineWidth: 1, drawOnChartArea: !0, drawTicks: !0, tickLength: 8, tickWidth: (e, n) => n.lineWidth, tickColor: (e, n) => n.color, offset: !1 }, border: { display: !0, dash: [], dashOffset: 0, width: 1 }, title: { display: !1, text: "", padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: !1, textStrokeWidth: 0, textStrokeColor: "", padding: 3, display: !0, autoSkip: !0, autoSkipPadding: 3, labelOffset: 0, callback: Cs.formatters.values, minor: {}, major: {}, align: "center", crossAlign: "near", showLabelBackdrop: !1, backdropColor: "rgba(255, 255, 255, 0.75)", backdropPadding: 2 } }), t.route("scale.ticks", "color", "", "color"), t.route("scale.grid", "color", "", "borderColor"), t.route("scale.border", "color", "", "borderColor"), t.route("scale.title", "color", "", "color"), t.describe("scale", { _fallback: !1, _scriptable: e => !e.startsWith("before") && !e.startsWith("after") && e !== "callback" && e !== "parser", _indexable: e => e !== "borderDash" && e !== "tickBorderDash" && e !== "dash" }), t.describe("scales", { _fallback: "scale" }), t.describe("scale.ticks", { _scriptable: e => e !== "backdropPadding" && e !== "callback", _indexable: e => e !== "backdropPadding" }) } const Rn = Object.create(null), va = Object.create(null); function tr(t, e) { if (!e) return t; const n = e.split("."); for (let i = 0, r = n.length; i < r; ++i) { const o = n[i]; t = t[o] || (t[o] = Object.create(null)) } return t } function il(t, e, n) { return typeof e == "string" ? _r(tr(t, e), n) : _r(tr(t, ""), e) } class qv { constructor(e, n) { this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = i => i.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = { family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: "normal", lineHeight: 1.2, weight: null }, this.hover = {}, this.hoverBackgroundColor = (i, r) => nl(r.backgroundColor), this.hoverBorderColor = (i, r) => nl(r.borderColor), this.hoverColor = (i, r) => nl(r.color), this.indexAxis = "x", this.interaction = { mode: "nearest", intersect: !0, includeInvisible: !1 }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(e), this.apply(n) } set(e, n) { return il(this, e, n) } get(e) { return tr(this, e) } describe(e, n) { return il(va, e, n) } override(e, n) { return il(Rn, e, n) } route(e, n, i, r) { const o = tr(this, e), s = tr(this, i), l = "_" + n; Object.defineProperties(o, { [l]: { value: o[n], writable: !0 }, [n]: { enumerable: !0, get() { const a = this[l], u = s[r]; return W(a) ? Object.assign({}, u, a) : U(a, u) }, set(a) { this[l] = a } } }) } apply(e) { e.forEach(n => n(this)) } } var se = new qv({ _scriptable: t => !t.startsWith("on"), _indexable: t => t !== "events", hover: { _fallback: "interaction" }, interaction: { _scriptable: !1, _indexable: !1 } }, [Yv, Qv, Zv]); function Jv(t) { return !t || te(t.size) || te(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family } function is(t, e, n, i, r) { let o = e[r]; return o || (o = e[r] = t.measureText(r).width, n.push(r)), o > i && (i = o), i } function ey(t, e, n, i) { i = i || {}; let r = i.data = i.data || {}, o = i.garbageCollect = i.garbageCollect || []; i.font !== e && (r = i.data = {}, o = i.garbageCollect = [], i.font = e), t.save(), t.font = e; let s = 0; const l = n.length; let a, u, d, f, c; for (a = 0; a < l; a++)if (f = n[a], f != null && !oe(f)) s = is(t, r, o, s, f); else if (oe(f)) for (u = 0, d = f.length; u < d; u++)c = f[u], c != null && !oe(c) && (s = is(t, r, o, s, c)); t.restore(); const h = o.length / 2; if (h > n.length) { for (a = 0; a < h; a++)delete r[o[a]]; o.splice(0, h) } return s } function hn(t, e, n) { const i = t.currentDevicePixelRatio, r = n !== 0 ? Math.max(n / 2, .5) : 0; return Math.round((e - r) * i) / i + r } function sd(t, e) { e = e || t.getContext("2d"), e.save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore() } function ld(t, e, n, i) { Wp(t, e, n, i, null) } function Wp(t, e, n, i, r) { let o, s, l, a, u, d, f, c; const h = e.pointStyle, g = e.rotation, v = e.radius; let _ = (g || 0) * Lv; if (h && typeof h == "object" && (o = h.toString(), o === "[object HTMLImageElement]" || o === "[object HTMLCanvasElement]")) { t.save(), t.translate(n, i), t.rotate(_), t.drawImage(h, -h.width / 2, -h.height / 2, h.width, h.height), t.restore(); return } if (!(isNaN(v) || v <= 0)) { switch (t.beginPath(), h) { default: r ? t.ellipse(n, i, r / 2, v, 0, 0, xe) : t.arc(n, i, v, 0, xe), t.closePath(); break; case "triangle": d = r ? r / 2 : v, t.moveTo(n + Math.sin(_) * d, i - Math.cos(_) * v), _ += qc, t.lineTo(n + Math.sin(_) * d, i - Math.cos(_) * v), _ += qc, t.lineTo(n + Math.sin(_) * d, i - Math.cos(_) * v), t.closePath(); break; case "rectRounded": u = v * .516, a = v - u, s = Math.cos(_ + fn) * a, f = Math.cos(_ + fn) * (r ? r / 2 - u : a), l = Math.sin(_ + fn) * a, c = Math.sin(_ + fn) * (r ? r / 2 - u : a), t.arc(n - f, i - l, u, _ - we, _ - ue), t.arc(n + c, i - s, u, _ - ue, _), t.arc(n + f, i + l, u, _, _ + ue), t.arc(n - c, i + s, u, _ + ue, _ + we), t.closePath(); break; case "rect": if (!g) { a = Math.SQRT1_2 * v, d = r ? r / 2 : a, t.rect(n - d, i - a, 2 * d, 2 * a); break } _ += fn; case "rectRot": f = Math.cos(_) * (r ? r / 2 : v), s = Math.cos(_) * v, l = Math.sin(_) * v, c = Math.sin(_) * (r ? r / 2 : v), t.moveTo(n - f, i - l), t.lineTo(n + c, i - s), t.lineTo(n + f, i + l), t.lineTo(n - c, i + s), t.closePath(); break; case "crossRot": _ += fn; case "cross": f = Math.cos(_) * (r ? r / 2 : v), s = Math.cos(_) * v, l = Math.sin(_) * v, c = Math.sin(_) * (r ? r / 2 : v), t.moveTo(n - f, i - l), t.lineTo(n + f, i + l), t.moveTo(n + c, i - s), t.lineTo(n - c, i + s); break; case "star": f = Math.cos(_) * (r ? r / 2 : v), s = Math.cos(_) * v, l = Math.sin(_) * v, c = Math.sin(_) * (r ? r / 2 : v), t.moveTo(n - f, i - l), t.lineTo(n + f, i + l), t.moveTo(n + c, i - s), t.lineTo(n - c, i + s), _ += fn, f = Math.cos(_) * (r ? r / 2 : v), s = Math.cos(_) * v, l = Math.sin(_) * v, c = Math.sin(_) * (r ? r / 2 : v), t.moveTo(n - f, i - l), t.lineTo(n + f, i + l), t.moveTo(n + c, i - s), t.lineTo(n - c, i + s); break; case "line": s = r ? r / 2 : Math.cos(_) * v, l = Math.sin(_) * v, t.moveTo(n - s, i - l), t.lineTo(n + s, i + l); break; case "dash": t.moveTo(n, i), t.lineTo(n + Math.cos(_) * (r ? r / 2 : v), i + Math.sin(_) * v); break; case !1: t.closePath(); break }t.fill(), e.borderWidth > 0 && t.stroke() } } function qn(t, e, n) { return n = n || .5, !e || t && t.x > e.left - n && t.x < e.right + n && t.y > e.top - n && t.y < e.bottom + n } function Pu(t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip() } function Ou(t) { t.restore() } function ty(t, e) { e.translation && t.translate(e.translation[0], e.translation[1]), te(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline) } function ny(t, e, n, i, r) { if (r.strikethrough || r.underline) { const o = t.measureText(i), s = e - o.actualBoundingBoxLeft, l = e + o.actualBoundingBoxRight, a = n - o.actualBoundingBoxAscent, u = n + o.actualBoundingBoxDescent, d = r.strikethrough ? (a + u) / 2 : u; t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = r.decorationWidth || 2, t.moveTo(s, d), t.lineTo(l, d), t.stroke() } } function iy(t, e) { const n = t.fillStyle; t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = n } function gi(t, e, n, i, r, o = {}) { const s = oe(e) ? e : [e], l = o.strokeWidth > 0 && o.strokeColor !== ""; let a, u; for (t.save(), t.font = r.string, ty(t, o), a = 0; a < s.length; ++a)u = s[a], o.backdrop && iy(t, o.backdrop), l && (o.strokeColor && (t.strokeStyle = o.strokeColor), te(o.strokeWidth) || (t.lineWidth = o.strokeWidth), t.strokeText(u, n, i, o.maxWidth)), t.fillText(u, n, i, o.maxWidth), ny(t, n, i, u, o), i += Number(r.lineHeight); t.restore() } function rs(t, e) { const { x: n, y: i, w: r, h: o, radius: s } = e; t.arc(n + s.topLeft, i + s.topLeft, s.topLeft, -ue, we, !0), t.lineTo(n, i + o - s.bottomLeft), t.arc(n + s.bottomLeft, i + o - s.bottomLeft, s.bottomLeft, we, ue, !0), t.lineTo(n + r - s.bottomRight, i + o), t.arc(n + r - s.bottomRight, i + o - s.bottomRight, s.bottomRight, ue, 0, !0), t.lineTo(n + r, i + s.topRight), t.arc(n + r - s.topRight, i + s.topRight, s.topRight, 0, -ue, !0), t.lineTo(n + s.topLeft, i) } const ry = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, oy = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/; function sy(t, e) { const n = ("" + t).match(ry); if (!n || n[1] === "normal") return e * 1.2; switch (t = +n[2], n[3]) { case "px": return t; case "%": t /= 100; break }return e * t } const ly = t => +t || 0; function Mu(t, e) { const n = {}, i = W(e), r = i ? Object.keys(e) : e, o = W(t) ? i ? s => U(t[s], t[e[s]]) : s => t[s] : () => t; for (const s of r) n[s] = ly(o(s)); return n } function ay(t) { return Mu(t, { top: "y", right: "x", bottom: "y", left: "x" }) } function si(t) { return Mu(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"]) } function Te(t) { const e = ay(t); return e.width = e.left + e.right, e.height = e.top + e.bottom, e } function ve(t, e) { t = t || {}, e = e || se.font; let n = U(t.size, e.size); typeof n == "string" && (n = parseInt(n, 10)); let i = U(t.style, e.style); i && !("" + i).match(oy) && (console.warn('Invalid font style specified: "' + i + '"'), i = void 0); const r = { family: U(t.family, e.family), lineHeight: sy(U(t.lineHeight, e.lineHeight), n), size: n, style: i, weight: U(t.weight, e.weight), string: "" }; return r.string = Jv(r), r } function eo(t, e, n, i) { let r = !0, o, s, l; for (o = 0, s = t.length; o < s; ++o)if (l = t[o], l !== void 0 && (e !== void 0 && typeof l == "function" && (l = l(e), r = !1), n !== void 0 && oe(l) && (l = l[n % l.length], r = !1), l !== void 0)) return i && !r && (i.cacheable = !1), l } function uy(t, e, n) { const { min: i, max: r } = t, o = Ov(e, (r - i) / 2), s = (l, a) => n && l === 0 ? 0 : l + a; return { min: s(i, -Math.abs(o)), max: s(r, o) } } function Nn(t, e) { return Object.assign(Object.create(t), e) } function Tu(t, e = [""], n, i, r = () => t[0]) { const o = n || t; typeof i > "u" && (i = Xp("_fallback", t)); const s = { [Symbol.toStringTag]: "Object", _cacheable: !0, _scopes: t, _rootScopes: o, _fallback: i, _getTarget: r, override: l => Tu([l, ...t], e, o, i) }; return new Proxy(s, { deleteProperty(l, a) { return delete l[a], delete l._keys, delete t[0][a], !0 }, get(l, a) { return $p(l, a, () => vy(a, e, t, l)) }, getOwnPropertyDescriptor(l, a) { return Reflect.getOwnPropertyDescriptor(l._scopes[0], a) }, getPrototypeOf() { return Reflect.getPrototypeOf(t[0]) }, has(l, a) { return ud(l).includes(a) }, ownKeys(l) { return ud(l) }, set(l, a, u) { const d = l._storage || (l._storage = r()); return l[a] = d[a] = u, delete l._keys, !0 } }) } function mi(t, e, n, i) { const r = { _cacheable: !1, _proxy: t, _context: e, _subProxy: n, _stack: new Set, _descriptors: Vp(t, i), setContext: o => mi(t, o, n, i), override: o => mi(t.override(o), e, n, i) }; return new Proxy(r, { deleteProperty(o, s) { return delete o[s], delete t[s], !0 }, get(o, s, l) { return $p(o, s, () => dy(o, s, l)) }, getOwnPropertyDescriptor(o, s) { return o._descriptors.allKeys ? Reflect.has(t, s) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(t, s) }, getPrototypeOf() { return Reflect.getPrototypeOf(t) }, has(o, s) { return Reflect.has(t, s) }, ownKeys() { return Reflect.ownKeys(t) }, set(o, s, l) { return t[s] = l, delete o[s], !0 } }) } function Vp(t, e = { scriptable: !0, indexable: !0 }) { const { _scriptable: n = e.scriptable, _indexable: i = e.indexable, _allKeys: r = e.allKeys } = t; return { allKeys: r, scriptable: n, indexable: i, isScriptable: an(n) ? n : () => n, isIndexable: an(i) ? i : () => i } } const cy = (t, e) => t ? t + bu(e) : e, Ru = (t, e) => W(e) && t !== "adapters" && (Object.getPrototypeOf(e) === null || e.constructor === Object); function $p(t, e, n) { if (Object.prototype.hasOwnProperty.call(t, e)) return t[e]; const i = n(); return t[e] = i, i } function dy(t, e, n) { const { _proxy: i, _context: r, _subProxy: o, _descriptors: s } = t; let l = i[e]; return an(l) && s.isScriptable(e) && (l = fy(e, l, t, n)), oe(l) && l.length && (l = hy(e, l, t, s.isIndexable)), Ru(e, l) && (l = mi(l, r, o && o[e], s)), l } function fy(t, e, n, i) { const { _proxy: r, _context: o, _subProxy: s, _stack: l } = n; if (l.has(t)) throw new Error("Recursion detected: " + Array.from(l).join("->") + "->" + t); l.add(t); let a = e(o, s || i); return l.delete(t), Ru(t, a) && (a = Au(r._scopes, r, t, a)), a } function hy(t, e, n, i) { const { _proxy: r, _context: o, _subProxy: s, _descriptors: l } = n; if (typeof o.index < "u" && i(t)) return e[o.index % e.length]; if (W(e[0])) { const a = e, u = r._scopes.filter(d => d !== a); e = []; for (const d of a) { const f = Au(u, r, t, d); e.push(mi(f, o, s && s[t], l)) } } return e } function Up(t, e, n) { return an(t) ? t(e, n) : t } const py = (t, e) => t === !0 ? e : typeof t == "string" ? qo(e, t) : void 0; function gy(t, e, n, i, r) { for (const o of e) { const s = py(n, o); if (s) { t.add(s); const l = Up(s._fallback, n, r); if (typeof l < "u" && l !== n && l !== i) return l } else if (s === !1 && typeof i < "u" && n !== i) return null } return !1 } function Au(t, e, n, i) { const r = e._rootScopes, o = Up(e._fallback, n, i), s = [...t, ...r], l = new Set; l.add(i); let a = ad(l, s, n, o || n, i); return a === null || typeof o < "u" && o !== n && (a = ad(l, s, o, a, i), a === null) ? !1 : Tu(Array.from(l), [""], r, o, () => my(e, n, i)) } function ad(t, e, n, i, r) { for (; n;)n = gy(t, e, n, i, r); return n } function my(t, e, n) { const i = t._getTarget(); e in i || (i[e] = {}); const r = i[e]; return oe(r) && W(n) ? n : r || {} } function vy(t, e, n, i) { let r; for (const o of e) if (r = Xp(cy(o, t), n), typeof r < "u") return Ru(t, r) ? Au(n, i, t, r) : r } function Xp(t, e) { for (const n of e) { if (!n) continue; const i = n[t]; if (typeof i < "u") return i } } function ud(t) { let e = t._keys; return e || (e = t._keys = yy(t._scopes)), e } function yy(t) { const e = new Set; for (const n of t) for (const i of Object.keys(n).filter(r => !r.startsWith("_"))) e.add(i); return Array.from(e) } function Yp() { return typeof window < "u" && typeof document < "u" } function ju(t) { let e = t.parentNode; return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e } function os(t, e, n) { let i; return typeof t == "string" ? (i = parseInt(t, 10), t.indexOf("%") !== -1 && (i = i / 100 * e.parentNode[n])) : i = t, i } const Ps = t => t.ownerDocument.defaultView.getComputedStyle(t, null); function xy(t, e) { return Ps(t).getPropertyValue(e) } const _y = ["top", "right", "bottom", "left"]; function En(t, e, n) { const i = {}; n = n ? "-" + n : ""; for (let r = 0; r < 4; r++) { const o = _y[r]; i[o] = parseFloat(t[e + "-" + o + n]) || 0 } return i.width = i.left + i.right, i.height = i.top + i.bottom, i } const wy = (t, e, n) => (t > 0 || e > 0) && (!n || !n.shadowRoot); function ky(t, e) { const n = t.touches, i = n && n.length ? n[0] : t, { offsetX: r, offsetY: o } = i; let s = !1, l, a; if (wy(r, o, t.target)) l = r, a = o; else { const u = e.getBoundingClientRect(); l = i.clientX - u.left, a = i.clientY - u.top, s = !0 } return { x: l, y: a, box: s } } function yn(t, e) { if ("native" in t) return t; const { canvas: n, currentDevicePixelRatio: i } = e, r = Ps(n), o = r.boxSizing === "border-box", s = En(r, "padding"), l = En(r, "border", "width"), { x: a, y: u, box: d } = ky(t, n), f = s.left + (d && l.left), c = s.top + (d && l.top); let { width: h, height: g } = e; return o && (h -= s.width + l.width, g -= s.height + l.height), { x: Math.round((a - f) / h * n.width / i), y: Math.round((u - c) / g * n.height / i) } } function by(t, e, n) { let i, r; if (e === void 0 || n === void 0) { const o = ju(t); if (!o) e = t.clientWidth, n = t.clientHeight; else { const s = o.getBoundingClientRect(), l = Ps(o), a = En(l, "border", "width"), u = En(l, "padding"); e = s.width - u.width - a.width, n = s.height - u.height - a.height, i = os(l.maxWidth, o, "clientWidth"), r = os(l.maxHeight, o, "clientHeight") } } return { width: e, height: n, maxWidth: i || es, maxHeight: r || es } } const to = t => Math.round(t * 10) / 10; function Sy(t, e, n, i) { const r = Ps(t), o = En(r, "margin"), s = os(r.maxWidth, t, "clientWidth") || es, l = os(r.maxHeight, t, "clientHeight") || es, a = by(t, e, n); let { width: u, height: d } = a; if (r.boxSizing === "content-box") { const c = En(r, "border", "width"), h = En(r, "padding"); u -= h.width + c.width, d -= h.height + c.height } return u = Math.max(0, u - o.width), d = Math.max(0, i ? u / i : d - o.height), u = to(Math.min(u, s, a.maxWidth)), d = to(Math.min(d, l, a.maxHeight)), u && !d && (d = to(u / 2)), (e !== void 0 || n !== void 0) && i && a.height && d > a.height && (d = a.height, u = to(Math.floor(d * i))), { width: u, height: d } } function cd(t, e, n) { const i = e || 1, r = Math.floor(t.height * i), o = Math.floor(t.width * i); t.height = Math.floor(t.height), t.width = Math.floor(t.width); const s = t.canvas; return s.style && (n || !s.style.height && !s.style.width) && (s.style.height = `${t.height}px`, s.style.width = `${t.width}px`), t.currentDevicePixelRatio !== i || s.height !== r || s.width !== o ? (t.currentDevicePixelRatio = i, s.height = r, s.width = o, t.ctx.setTransform(i, 0, 0, i, 0, 0), !0) : !1 } const Ey = function () { let t = !1; try { const e = { get passive() { return t = !0, !1 } }; window.addEventListener("test", null, e), window.removeEventListener("test", null, e) } catch { } return t }(); function dd(t, e) { const n = xy(t, e), i = n && n.match(/^(\d+)(\.\d+)?px$/); return i ? +i[1] : void 0 } const Cy = function (t, e) { return { x(n) { return t + t + e - n }, setWidth(n) { e = n }, textAlign(n) { return n === "center" ? n : n === "right" ? "left" : "right" }, xPlus(n, i) { return n - i }, leftForLtr(n, i) { return n - i } } }, Py = function () { return { x(t) { return t }, setWidth(t) { }, textAlign(t) { return t }, xPlus(t, e) { return t + e }, leftForLtr(t, e) { return t } } }; function li(t, e, n) { return t ? Cy(e, n) : Py() } function Qp(t, e) { let n, i; (e === "ltr" || e === "rtl") && (n = t.canvas.style, i = [n.getPropertyValue("direction"), n.getPropertyPriority("direction")], n.setProperty("direction", e, "important"), t.prevTextDirection = i) } function Kp(t, e) { e !== void 0 && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1])) }/*!
 * Chart.js v4.3.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */class Oy { constructor() { this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0 } _notify(e, n, i, r) { const o = n.listeners[r], s = n.duration; o.forEach(l => l({ chart: e, initial: n.initial, numSteps: s, currentStep: Math.min(i - n.start, s) })) } _refresh() { this._request || (this._running = !0, this._request = zp.call(window, () => { this._update(), this._request = null, this._running && this._refresh() })) } _update(e = Date.now()) { let n = 0; this._charts.forEach((i, r) => { if (!i.running || !i.items.length) return; const o = i.items; let s = o.length - 1, l = !1, a; for (; s >= 0; --s)a = o[s], a._active ? (a._total > i.duration && (i.duration = a._total), a.tick(e), l = !0) : (o[s] = o[o.length - 1], o.pop()); l && (r.draw(), this._notify(r, i, e, "progress")), o.length || (i.running = !1, this._notify(r, i, e, "complete"), i.initial = !1), n += o.length }), this._lastDate = e, n === 0 && (this._running = !1) } _getAnims(e) { const n = this._charts; let i = n.get(e); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, n.set(e, i)), i } listen(e, n, i) { this._getAnims(e).listeners[n].push(i) } add(e, n) { !n || !n.length || this._getAnims(e).items.push(...n) } has(e) { return this._getAnims(e).items.length > 0 } start(e) { const n = this._charts.get(e); n && (n.running = !0, n.start = Date.now(), n.duration = n.items.reduce((i, r) => Math.max(i, r._duration), 0), this._refresh()) } running(e) { if (!this._running) return !1; const n = this._charts.get(e); return !(!n || !n.running || !n.items.length) } stop(e) { const n = this._charts.get(e); if (!n || !n.items.length) return; const i = n.items; let r = i.length - 1; for (; r >= 0; --r)i[r].cancel(); n.items = [], this._notify(e, n, Date.now(), "complete") } remove(e) { return this._charts.delete(e) } } var St = new Oy; const fd = "transparent", My = { boolean(t, e, n) { return n > .5 ? e : t }, color(t, e, n) { const i = rd(t || fd), r = i.valid && rd(e || fd); return r && r.valid ? r.mix(i, n).hexString() : e }, number(t, e, n) { return t + (e - t) * n } }; class Ty { constructor(e, n, i, r) { const o = n[i]; r = eo([e.to, r, o, e.from]); const s = eo([e.from, o, r]); this._active = !0, this._fn = e.fn || My[e.type || typeof s], this._easing = er[e.easing] || er.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = n, this._prop = i, this._from = s, this._to = r, this._promises = void 0 } active() { return this._active } update(e, n, i) { if (this._active) { this._notify(!1); const r = this._target[this._prop], o = i - this._start, s = this._duration - o; this._start = i, this._duration = Math.floor(Math.max(s, e.duration)), this._total += o, this._loop = !!e.loop, this._to = eo([e.to, n, r, e.from]), this._from = eo([e.from, r, n]) } } cancel() { this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1)) } tick(e) { const n = e - this._start, i = this._duration, r = this._prop, o = this._from, s = this._loop, l = this._to; let a; if (this._active = o !== l && (s || n < i), !this._active) { this._target[r] = l, this._notify(!0); return } if (n < 0) { this._target[r] = o; return } a = n / i % 2, a = s && a > 1 ? 2 - a : a, a = this._easing(Math.min(1, Math.max(0, a))), this._target[r] = this._fn(o, l, a) } wait() { const e = this._promises || (this._promises = []); return new Promise((n, i) => { e.push({ res: n, rej: i }) }) } _notify(e) { const n = e ? "res" : "rej", i = this._promises || []; for (let r = 0; r < i.length; r++)i[r][n]() } } class Gp { constructor(e, n) { this._chart = e, this._properties = new Map, this.configure(n) } configure(e) { if (!W(e)) return; const n = Object.keys(se.animation), i = this._properties; Object.getOwnPropertyNames(e).forEach(r => { const o = e[r]; if (!W(o)) return; const s = {}; for (const l of n) s[l] = o[l]; (oe(o.properties) && o.properties || [r]).forEach(l => { (l === r || !i.has(l)) && i.set(l, s) }) }) } _animateOptions(e, n) { const i = n.options, r = Ay(e, i); if (!r) return []; const o = this._createAnimations(r, i); return i.$shared && Ry(e.options.$animations, i).then(() => { e.options = i }, () => { }), o } _createAnimations(e, n) { const i = this._properties, r = [], o = e.$animations || (e.$animations = {}), s = Object.keys(n), l = Date.now(); let a; for (a = s.length - 1; a >= 0; --a) { const u = s[a]; if (u.charAt(0) === "$") continue; if (u === "options") { r.push(...this._animateOptions(e, n)); continue } const d = n[u]; let f = o[u]; const c = i.get(u); if (f) if (c && f.active()) { f.update(c, d, l); continue } else f.cancel(); if (!c || !c.duration) { e[u] = d; continue } o[u] = f = new Ty(c, e, u, d), r.push(f) } return r } update(e, n) { if (this._properties.size === 0) { Object.assign(e, n); return } const i = this._createAnimations(e, n); if (i.length) return St.add(this._chart, i), !0 } } function Ry(t, e) { const n = [], i = Object.keys(e); for (let r = 0; r < i.length; r++) { const o = t[i[r]]; o && o.active() && n.push(o.wait()) } return Promise.all(n) } function Ay(t, e) { if (!e) return; let n = t.options; if (!n) { t.options = e; return } return n.$shared && (t.options = n = Object.assign({}, n, { $shared: !1, $animations: {} })), n } function hd(t, e) { const n = t && t.options || {}, i = n.reverse, r = n.min === void 0 ? e : 0, o = n.max === void 0 ? e : 0; return { start: i ? o : r, end: i ? r : o } } function jy(t, e, n) { if (n === !1) return !1; const i = hd(t, n), r = hd(e, n); return { top: r.end, right: i.end, bottom: r.start, left: i.start } } function Ly(t) { let e, n, i, r; return W(t) ? (e = t.top, n = t.right, i = t.bottom, r = t.left) : e = n = i = r = t, { top: e, right: n, bottom: i, left: r, disabled: t === !1 } } function Zp(t, e) { const n = [], i = t._getSortedDatasetMetas(e); let r, o; for (r = 0, o = i.length; r < o; ++r)n.push(i[r].index); return n } function pd(t, e, n, i = {}) { const r = t.keys, o = i.mode === "single"; let s, l, a, u; if (e !== null) { for (s = 0, l = r.length; s < l; ++s) { if (a = +r[s], a === n) { if (i.all) continue; break } u = t.values[a], he(u) && (o || e === 0 || ts(e) === ts(u)) && (e += u) } return e } } function Dy(t) { const e = Object.keys(t), n = new Array(e.length); let i, r, o; for (i = 0, r = e.length; i < r; ++i)o = e[i], n[i] = { x: o, y: t[o] }; return n } function gd(t, e) { const n = t && t.options.stacked; return n || n === void 0 && e.stack !== void 0 } function Ny(t, e, n) { return `${t.id}.${e.id}.${n.stack || n.type}` } function zy(t) { const { min: e, max: n, minDefined: i, maxDefined: r } = t.getUserBounds(); return { min: i ? e : Number.NEGATIVE_INFINITY, max: r ? n : Number.POSITIVE_INFINITY } } function Iy(t, e, n) { const i = t[e] || (t[e] = {}); return i[n] || (i[n] = {}) } function md(t, e, n, i) { for (const r of e.getMatchingVisibleMetas(i).reverse()) { const o = t[r.index]; if (n && o > 0 || !n && o < 0) return r.index } return null } function vd(t, e) { const { chart: n, _cachedMeta: i } = t, r = n._stacks || (n._stacks = {}), { iScale: o, vScale: s, index: l } = i, a = o.axis, u = s.axis, d = Ny(o, s, i), f = e.length; let c; for (let h = 0; h < f; ++h) { const g = e[h], { [a]: v, [u]: _ } = g, m = g._stacks || (g._stacks = {}); c = m[u] = Iy(r, d, v), c[l] = _, c._top = md(c, s, !0, i.type), c._bottom = md(c, s, !1, i.type); const p = c._visualValues || (c._visualValues = {}); p[l] = _ } } function rl(t, e) { const n = t.scales; return Object.keys(n).filter(i => n[i].axis === e).shift() } function Fy(t, e) { return Nn(t, { active: !1, dataset: void 0, datasetIndex: e, index: e, mode: "default", type: "dataset" }) } function By(t, e, n) { return Nn(t, { active: !1, dataIndex: e, parsed: void 0, raw: void 0, element: n, index: e, mode: "default", type: "data" }) } function Ti(t, e) { const n = t.controller.index, i = t.vScale && t.vScale.axis; if (i) { e = e || t._parsed; for (const r of e) { const o = r._stacks; if (!o || o[i] === void 0 || o[i][n] === void 0) return; delete o[i][n], o[i]._visualValues !== void 0 && o[i]._visualValues[n] !== void 0 && delete o[i]._visualValues[n] } } } const ol = t => t === "reset" || t === "none", yd = (t, e) => e ? t : Object.assign({}, t), Hy = (t, e, n) => t && !e.hidden && e._stacked && { keys: Zp(n, !0), values: null }; class bo { constructor(e, n) { this.chart = e, this._ctx = e.ctx, this.index = n, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize() } initialize() { const e = this._cachedMeta; this.configure(), this.linkScales(), e._stacked = gd(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options") } updateIndex(e) { this.index !== e && Ti(this._cachedMeta), this.index = e } linkScales() { const e = this.chart, n = this._cachedMeta, i = this.getDataset(), r = (f, c, h, g) => f === "x" ? c : f === "r" ? g : h, o = n.xAxisID = U(i.xAxisID, rl(e, "x")), s = n.yAxisID = U(i.yAxisID, rl(e, "y")), l = n.rAxisID = U(i.rAxisID, rl(e, "r")), a = n.indexAxis, u = n.iAxisID = r(a, o, s, l), d = n.vAxisID = r(a, s, o, l); n.xScale = this.getScaleForId(o), n.yScale = this.getScaleForId(s), n.rScale = this.getScaleForId(l), n.iScale = this.getScaleForId(u), n.vScale = this.getScaleForId(d) } getDataset() { return this.chart.data.datasets[this.index] } getMeta() { return this.chart.getDatasetMeta(this.index) } getScaleForId(e) { return this.chart.scales[e] } _getOtherScale(e) { const n = this._cachedMeta; return e === n.iScale ? n.vScale : n.iScale } reset() { this._update("reset") } _destroy() { const e = this._cachedMeta; this._data && td(this._data, this), e._stacked && Ti(e) } _dataCheck() { const e = this.getDataset(), n = e.data || (e.data = []), i = this._data; if (W(n)) this._data = Dy(n); else if (i !== n) { if (i) { td(i, this); const r = this._cachedMeta; Ti(r), r._parsed = [] } n && Object.isExtensible(n) && Hv(n, this), this._syncList = [], this._data = n } } addElements() { const e = this._cachedMeta; this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType) } buildOrUpdateElements(e) { const n = this._cachedMeta, i = this.getDataset(); let r = !1; this._dataCheck(); const o = n._stacked; n._stacked = gd(n.vScale, n), n.stack !== i.stack && (r = !0, Ti(n), n.stack = i.stack), this._resyncElements(e), (r || o !== n._stacked) && vd(this, n._parsed) } configure() { const e = this.chart.config, n = e.datasetScopeKeys(this._type), i = e.getOptionScopes(this.getDataset(), n, !0); this.options = e.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {} } parse(e, n) { const { _cachedMeta: i, _data: r } = this, { iScale: o, _stacked: s } = i, l = o.axis; let a = e === 0 && n === r.length ? !0 : i._sorted, u = e > 0 && i._parsed[e - 1], d, f, c; if (this._parsing === !1) i._parsed = r, i._sorted = !0, c = r; else { oe(r[e]) ? c = this.parseArrayData(i, r, e, n) : W(r[e]) ? c = this.parseObjectData(i, r, e, n) : c = this.parsePrimitiveData(i, r, e, n); const h = () => f[l] === null || u && f[l] < u[l]; for (d = 0; d < n; ++d)i._parsed[d + e] = f = c[d], a && (h() && (a = !1), u = f); i._sorted = a } s && vd(this, c) } parsePrimitiveData(e, n, i, r) { const { iScale: o, vScale: s } = e, l = o.axis, a = s.axis, u = o.getLabels(), d = o === s, f = new Array(r); let c, h, g; for (c = 0, h = r; c < h; ++c)g = c + i, f[c] = { [l]: d || o.parse(u[g], g), [a]: s.parse(n[g], g) }; return f } parseArrayData(e, n, i, r) { const { xScale: o, yScale: s } = e, l = new Array(r); let a, u, d, f; for (a = 0, u = r; a < u; ++a)d = a + i, f = n[d], l[a] = { x: o.parse(f[0], d), y: s.parse(f[1], d) }; return l } parseObjectData(e, n, i, r) { const { xScale: o, yScale: s } = e, { xAxisKey: l = "x", yAxisKey: a = "y" } = this._parsing, u = new Array(r); let d, f, c, h; for (d = 0, f = r; d < f; ++d)c = d + i, h = n[c], u[d] = { x: o.parse(qo(h, l), c), y: s.parse(qo(h, a), c) }; return u } getParsed(e) { return this._cachedMeta._parsed[e] } getDataElement(e) { return this._cachedMeta.data[e] } applyStack(e, n, i) { const r = this.chart, o = this._cachedMeta, s = n[e.axis], l = { keys: Zp(r, !0), values: n._stacks[e.axis]._visualValues }; return pd(l, s, o.index, { mode: i }) } updateRangeFromParsed(e, n, i, r) { const o = i[n.axis]; let s = o === null ? NaN : o; const l = r && i._stacks[n.axis]; r && l && (r.values = l, s = pd(r, o, this._cachedMeta.index)), e.min = Math.min(e.min, s), e.max = Math.max(e.max, s) } getMinMax(e, n) { const i = this._cachedMeta, r = i._parsed, o = i._sorted && e === i.iScale, s = r.length, l = this._getOtherScale(e), a = Hy(n, i, this.chart), u = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: d, max: f } = zy(l); let c, h; function g() { h = r[c]; const v = h[l.axis]; return !he(h[e.axis]) || d > v || f < v } for (c = 0; c < s && !(!g() && (this.updateRangeFromParsed(u, e, h, a), o)); ++c); if (o) { for (c = s - 1; c >= 0; --c)if (!g()) { this.updateRangeFromParsed(u, e, h, a); break } } return u } getAllParsedValues(e) { const n = this._cachedMeta._parsed, i = []; let r, o, s; for (r = 0, o = n.length; r < o; ++r)s = n[r][e.axis], he(s) && i.push(s); return i } getMaxOverflow() { return !1 } getLabelAndValue(e) { const n = this._cachedMeta, i = n.iScale, r = n.vScale, o = this.getParsed(e); return { label: i ? "" + i.getLabelForValue(o[i.axis]) : "", value: r ? "" + r.getLabelForValue(o[r.axis]) : "" } } _update(e) { const n = this._cachedMeta; this.update(e || "default"), n._clip = Ly(U(this.options.clip, jy(n.xScale, n.yScale, this.getMaxOverflow()))) } update(e) { } draw() { const e = this._ctx, n = this.chart, i = this._cachedMeta, r = i.data || [], o = n.chartArea, s = [], l = this._drawStart || 0, a = this._drawCount || r.length - l, u = this.options.drawActiveElementsOnTop; let d; for (i.dataset && i.dataset.draw(e, o, l, a), d = l; d < l + a; ++d) { const f = r[d]; f.hidden || (f.active && u ? s.push(f) : f.draw(e, o)) } for (d = 0; d < s.length; ++d)s[d].draw(e, o) } getStyle(e, n) { const i = n ? "active" : "default"; return e === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(e || 0, i) } getContext(e, n, i) { const r = this.getDataset(); let o; if (e >= 0 && e < this._cachedMeta.data.length) { const s = this._cachedMeta.data[e]; o = s.$context || (s.$context = By(this.getContext(), e, s)), o.parsed = this.getParsed(e), o.raw = r.data[e], o.index = o.dataIndex = e } else o = this.$context || (this.$context = Fy(this.chart.getContext(), this.index)), o.dataset = r, o.index = o.datasetIndex = this.index; return o.active = !!n, o.mode = i, o } resolveDatasetElementOptions(e) { return this._resolveElementOptions(this.datasetElementType.id, e) } resolveDataElementOptions(e, n) { return this._resolveElementOptions(this.dataElementType.id, n, e) } _resolveElementOptions(e, n = "default", i) { const r = n === "active", o = this._cachedDataOpts, s = e + "-" + n, l = o[s], a = this.enableOptionSharing && Jo(i); if (l) return yd(l, a); const u = this.chart.config, d = u.datasetElementScopeKeys(this._type, e), f = r ? [`${e}Hover`, "hover", e, ""] : [e, ""], c = u.getOptionScopes(this.getDataset(), d), h = Object.keys(se.elements[e]), g = () => this.getContext(i, r, n), v = u.resolveNamedOptions(c, h, g, f); return v.$shared && (v.$shared = a, o[s] = Object.freeze(yd(v, a))), v } _resolveAnimations(e, n, i) { const r = this.chart, o = this._cachedDataOpts, s = `animation-${n}`, l = o[s]; if (l) return l; let a; if (r.options.animation !== !1) { const d = this.chart.config, f = d.datasetAnimationScopeKeys(this._type, n), c = d.getOptionScopes(this.getDataset(), f); a = d.createResolver(c, this.getContext(e, i, n)) } const u = new Gp(r, a && a.animations); return a && a._cacheable && (o[s] = Object.freeze(u)), u } getSharedOptions(e) { if (e.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, e)) } includeOptions(e, n) { return !n || ol(e) || this.chart._animationsDisabled } _getSharedOptions(e, n) { const i = this.resolveDataElementOptions(e, n), r = this._sharedOptions, o = this.getSharedOptions(i), s = this.includeOptions(n, o) || o !== r; return this.updateSharedOptions(o, n, i), { sharedOptions: o, includeOptions: s } } updateElement(e, n, i, r) { ol(r) ? Object.assign(e, i) : this._resolveAnimations(n, r).update(e, i) } updateSharedOptions(e, n, i) { e && !ol(n) && this._resolveAnimations(void 0, n).update(e, i) } _setStyle(e, n, i, r) { e.active = r; const o = this.getStyle(n, r); this._resolveAnimations(n, i, r).update(e, { options: !r && this.getSharedOptions(o) || o }) } removeHoverStyle(e, n, i) { this._setStyle(e, i, "active", !1) } setHoverStyle(e, n, i) { this._setStyle(e, i, "active", !0) } _removeDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !1) } _setDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !0) } _resyncElements(e) { const n = this._data, i = this._cachedMeta.data; for (const [l, a, u] of this._syncList) this[l](a, u); this._syncList = []; const r = i.length, o = n.length, s = Math.min(o, r); s && this.parse(0, s), o > r ? this._insertElements(r, o - r, e) : o < r && this._removeElements(o, r - o) } _insertElements(e, n, i = !0) { const r = this._cachedMeta, o = r.data, s = e + n; let l; const a = u => { for (u.length += n, l = u.length - 1; l >= s; l--)u[l] = u[l - n] }; for (a(o), l = e; l < s; ++l)o[l] = new this.dataElementType; this._parsing && a(r._parsed), this.parse(e, n), i && this.updateElements(o, e, n, "reset") } updateElements(e, n, i, r) { } _removeElements(e, n) { const i = this._cachedMeta; if (this._parsing) { const r = i._parsed.splice(e, n); i._stacked && Ti(i, r) } i.data.splice(e, n) } _sync(e) { if (this._parsing) this._syncList.push(e); else { const [n, i, r] = e; this[n](i, r) } this.chart._dataChanges.push([this.index, ...e]) } _onDataPush() { const e = arguments.length; this._sync(["_insertElements", this.getDataset().data.length - e, e]) } _onDataPop() { this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]) } _onDataShift() { this._sync(["_removeElements", 0, 1]) } _onDataSplice(e, n) { n && this._sync(["_removeElements", e, n]); const i = arguments.length - 2; i && this._sync(["_insertElements", e, i]) } _onDataUnshift() { this._sync(["_insertElements", 0, arguments.length]) } } z(bo, "defaults", {}), z(bo, "datasetElementType", null), z(bo, "dataElementType", null); function pn() { throw new Error("This method is not implemented: Check that a complete date adapter is provided.") } class Lu { constructor(e) { z(this, "options"); this.options = e || {} } static override(e) { Object.assign(Lu.prototype, e) } init() { } formats() { return pn() } parse() { return pn() } format() { return pn() } add() { return pn() } diff() { return pn() } startOf() { return pn() } endOf() { return pn() } } var Wy = { _date: Lu }; function Vy(t, e, n, i) { const { controller: r, data: o, _sorted: s } = t, l = r._cachedMeta.iScale; if (l && e === l.axis && e !== "r" && s && o.length) { const a = l._reversePixels ? Fv : ma; if (i) { if (r._sharedOptions) { const u = o[0], d = typeof u.getRange == "function" && u.getRange(e); if (d) { const f = a(o, e, n - d), c = a(o, e, n + d); return { lo: f.lo, hi: c.hi } } } } else return a(o, e, n) } return { lo: 0, hi: o.length - 1 } } function Rr(t, e, n, i, r) { const o = t.getSortedVisibleDatasetMetas(), s = n[e]; for (let l = 0, a = o.length; l < a; ++l) { const { index: u, data: d } = o[l], { lo: f, hi: c } = Vy(o[l], e, s, r); for (let h = f; h <= c; ++h) { const g = d[h]; g.skip || i(g, u, h) } } } function $y(t) { const e = t.indexOf("x") !== -1, n = t.indexOf("y") !== -1; return function (i, r) { const o = e ? Math.abs(i.x - r.x) : 0, s = n ? Math.abs(i.y - r.y) : 0; return Math.sqrt(Math.pow(o, 2) + Math.pow(s, 2)) } } function sl(t, e, n, i, r) { const o = []; return !r && !t.isPointInArea(e) || Rr(t, n, e, function (l, a, u) { !r && !qn(l, t.chartArea, 0) || l.inRange(e.x, e.y, i) && o.push({ element: l, datasetIndex: a, index: u }) }, !0), o } function Uy(t, e, n, i) { let r = []; function o(s, l, a) { const { startAngle: u, endAngle: d } = s.getProps(["startAngle", "endAngle"], i), { angle: f } = Lp(s, { x: e.x, y: e.y }); Dp(f, u, d) && r.push({ element: s, datasetIndex: l, index: a }) } return Rr(t, n, e, o), r } function Xy(t, e, n, i, r, o) { let s = []; const l = $y(n); let a = Number.POSITIVE_INFINITY; function u(d, f, c) { const h = d.inRange(e.x, e.y, r); if (i && !h) return; const g = d.getCenterPoint(r); if (!(!!o || t.isPointInArea(g)) && !h) return; const _ = l(e, g); _ < a ? (s = [{ element: d, datasetIndex: f, index: c }], a = _) : _ === a && s.push({ element: d, datasetIndex: f, index: c }) } return Rr(t, n, e, u), s } function ll(t, e, n, i, r, o) { return !o && !t.isPointInArea(e) ? [] : n === "r" && !i ? Uy(t, e, n, r) : Xy(t, e, n, i, r, o) } function xd(t, e, n, i, r) { const o = [], s = n === "x" ? "inXRange" : "inYRange"; let l = !1; return Rr(t, n, e, (a, u, d) => { a[s](e[n], r) && (o.push({ element: a, datasetIndex: u, index: d }), l = l || a.inRange(e.x, e.y, r)) }), i && !l ? [] : o } var Yy = { evaluateInteractionItems: Rr, modes: { index(t, e, n, i) { const r = yn(e, t), o = n.axis || "x", s = n.includeInvisible || !1, l = n.intersect ? sl(t, r, o, i, s) : ll(t, r, o, !1, i, s), a = []; return l.length ? (t.getSortedVisibleDatasetMetas().forEach(u => { const d = l[0].index, f = u.data[d]; f && !f.skip && a.push({ element: f, datasetIndex: u.index, index: d }) }), a) : [] }, dataset(t, e, n, i) { const r = yn(e, t), o = n.axis || "xy", s = n.includeInvisible || !1; let l = n.intersect ? sl(t, r, o, i, s) : ll(t, r, o, !1, i, s); if (l.length > 0) { const a = l[0].datasetIndex, u = t.getDatasetMeta(a).data; l = []; for (let d = 0; d < u.length; ++d)l.push({ element: u[d], datasetIndex: a, index: d }) } return l }, point(t, e, n, i) { const r = yn(e, t), o = n.axis || "xy", s = n.includeInvisible || !1; return sl(t, r, o, i, s) }, nearest(t, e, n, i) { const r = yn(e, t), o = n.axis || "xy", s = n.includeInvisible || !1; return ll(t, r, o, n.intersect, i, s) }, x(t, e, n, i) { const r = yn(e, t); return xd(t, r, "x", n.intersect, i) }, y(t, e, n, i) { const r = yn(e, t); return xd(t, r, "y", n.intersect, i) } } }; const qp = ["left", "top", "right", "bottom"]; function Ri(t, e) { return t.filter(n => n.pos === e) } function _d(t, e) { return t.filter(n => qp.indexOf(n.pos) === -1 && n.box.axis === e) } function Ai(t, e) { return t.sort((n, i) => { const r = e ? i : n, o = e ? n : i; return r.weight === o.weight ? r.index - o.index : r.weight - o.weight }) } function Qy(t) { const e = []; let n, i, r, o, s, l; for (n = 0, i = (t || []).length; n < i; ++n)r = t[n], { position: o, options: { stack: s, stackWeight: l = 1 } } = r, e.push({ index: n, box: r, pos: o, horizontal: r.isHorizontal(), weight: r.weight, stack: s && o + s, stackWeight: l }); return e } function Ky(t) { const e = {}; for (const n of t) { const { stack: i, pos: r, stackWeight: o } = n; if (!i || !qp.includes(r)) continue; const s = e[i] || (e[i] = { count: 0, placed: 0, weight: 0, size: 0 }); s.count++, s.weight += o } return e } function Gy(t, e) { const n = Ky(t), { vBoxMaxWidth: i, hBoxMaxHeight: r } = e; let o, s, l; for (o = 0, s = t.length; o < s; ++o) { l = t[o]; const { fullSize: a } = l.box, u = n[l.stack], d = u && l.stackWeight / u.weight; l.horizontal ? (l.width = d ? d * i : a && e.availableWidth, l.height = r) : (l.width = i, l.height = d ? d * r : a && e.availableHeight) } return n } function Zy(t) { const e = Qy(t), n = Ai(e.filter(u => u.box.fullSize), !0), i = Ai(Ri(e, "left"), !0), r = Ai(Ri(e, "right")), o = Ai(Ri(e, "top"), !0), s = Ai(Ri(e, "bottom")), l = _d(e, "x"), a = _d(e, "y"); return { fullSize: n, leftAndTop: i.concat(o), rightAndBottom: r.concat(a).concat(s).concat(l), chartArea: Ri(e, "chartArea"), vertical: i.concat(r).concat(a), horizontal: o.concat(s).concat(l) } } function wd(t, e, n, i) { return Math.max(t[n], e[n]) + Math.max(t[i], e[i]) } function Jp(t, e) { t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right) } function qy(t, e, n, i) { const { pos: r, box: o } = n, s = t.maxPadding; if (!W(r)) { n.size && (t[r] -= n.size); const f = i[n.stack] || { size: 0, count: 1 }; f.size = Math.max(f.size, n.horizontal ? o.height : o.width), n.size = f.size / f.count, t[r] += n.size } o.getPadding && Jp(s, o.getPadding()); const l = Math.max(0, e.outerWidth - wd(s, t, "left", "right")), a = Math.max(0, e.outerHeight - wd(s, t, "top", "bottom")), u = l !== t.w, d = a !== t.h; return t.w = l, t.h = a, n.horizontal ? { same: u, other: d } : { same: d, other: u } } function Jy(t) { const e = t.maxPadding; function n(i) { const r = Math.max(e[i] - t[i], 0); return t[i] += r, r } t.y += n("top"), t.x += n("left"), n("right"), n("bottom") } function e1(t, e) { const n = e.maxPadding; function i(r) { const o = { left: 0, top: 0, right: 0, bottom: 0 }; return r.forEach(s => { o[s] = Math.max(e[s], n[s]) }), o } return i(t ? ["left", "right"] : ["top", "bottom"]) } function Hi(t, e, n, i) { const r = []; let o, s, l, a, u, d; for (o = 0, s = t.length, u = 0; o < s; ++o) { l = t[o], a = l.box, a.update(l.width || e.w, l.height || e.h, e1(l.horizontal, e)); const { same: f, other: c } = qy(e, n, l, i); u |= f && r.length, d = d || c, a.fullSize || r.push(l) } return u && Hi(r, e, n, i) || d } function no(t, e, n, i, r) { t.top = n, t.left = e, t.right = e + i, t.bottom = n + r, t.width = i, t.height = r } function kd(t, e, n, i) { const r = n.padding; let { x: o, y: s } = e; for (const l of t) { const a = l.box, u = i[l.stack] || { count: 1, placed: 0, weight: 1 }, d = l.stackWeight / u.weight || 1; if (l.horizontal) { const f = e.w * d, c = u.size || a.height; Jo(u.start) && (s = u.start), a.fullSize ? no(a, r.left, s, n.outerWidth - r.right - r.left, c) : no(a, e.left + u.placed, s, f, c), u.start = s, u.placed += f, s = a.bottom } else { const f = e.h * d, c = u.size || a.width; Jo(u.start) && (o = u.start), a.fullSize ? no(a, o, r.top, c, n.outerHeight - r.bottom - r.top) : no(a, o, e.top + u.placed, c, f), u.start = o, u.placed += f, o = a.right } } e.x = o, e.y = s } var Qt = { addBox(t, e) { t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function () { return [{ z: 0, draw(n) { e.draw(n) } }] }, t.boxes.push(e) }, removeBox(t, e) { const n = t.boxes ? t.boxes.indexOf(e) : -1; n !== -1 && t.boxes.splice(n, 1) }, configure(t, e, n) { e.fullSize = n.fullSize, e.position = n.position, e.weight = n.weight }, update(t, e, n, i) { if (!t) return; const r = Te(t.options.layout.padding), o = Math.max(e - r.width, 0), s = Math.max(n - r.height, 0), l = Zy(t.boxes), a = l.vertical, u = l.horizontal; $(t.boxes, v => { typeof v.beforeLayout == "function" && v.beforeLayout() }); const d = a.reduce((v, _) => _.box.options && _.box.options.display === !1 ? v : v + 1, 0) || 1, f = Object.freeze({ outerWidth: e, outerHeight: n, padding: r, availableWidth: o, availableHeight: s, vBoxMaxWidth: o / 2 / d, hBoxMaxHeight: s / 2 }), c = Object.assign({}, r); Jp(c, Te(i)); const h = Object.assign({ maxPadding: c, w: o, h: s, x: r.left, y: r.top }, r), g = Gy(a.concat(u), f); Hi(l.fullSize, h, f, g), Hi(a, h, f, g), Hi(u, h, f, g) && Hi(a, h, f, g), Jy(h), kd(l.leftAndTop, h, f, g), h.x += h.w, h.y += h.h, kd(l.rightAndBottom, h, f, g), t.chartArea = { left: h.left, top: h.top, right: h.left + h.w, bottom: h.top + h.h, height: h.h, width: h.w }, $(l.chartArea, v => { const _ = v.box; Object.assign(_, t.chartArea), _.update(h.w, h.h, { left: 0, top: 0, right: 0, bottom: 0 }) }) } }; class eg { acquireContext(e, n) { } releaseContext(e) { return !1 } addEventListener(e, n, i) { } removeEventListener(e, n, i) { } getDevicePixelRatio() { return 1 } getMaximumSize(e, n, i, r) { return n = Math.max(0, n || e.width), i = i || e.height, { width: n, height: Math.max(0, r ? Math.floor(n / r) : i) } } isAttached(e) { return !0 } updateConfig(e) { } } class t1 extends eg { acquireContext(e) { return e && e.getContext && e.getContext("2d") || null } updateConfig(e) { e.options.animation = !1 } } const So = "$chartjs", n1 = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }, bd = t => t === null || t === ""; function i1(t, e) { const n = t.style, i = t.getAttribute("height"), r = t.getAttribute("width"); if (t[So] = { initial: { height: i, width: r, style: { display: n.display, height: n.height, width: n.width } } }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", bd(r)) { const o = dd(t, "width"); o !== void 0 && (t.width = o) } if (bd(i)) if (t.style.height === "") t.height = t.width / (e || 2); else { const o = dd(t, "height"); o !== void 0 && (t.height = o) } return t } const tg = Ey ? { passive: !0 } : !1; function r1(t, e, n) { t.addEventListener(e, n, tg) } function o1(t, e, n) { t.canvas.removeEventListener(e, n, tg) } function s1(t, e) { const n = n1[t.type] || t.type, { x: i, y: r } = yn(t, e); return { type: n, chart: e, native: t, x: i !== void 0 ? i : null, y: r !== void 0 ? r : null } } function ss(t, e) { for (const n of t) if (n === e || n.contains(e)) return !0 } function l1(t, e, n) { const i = t.canvas, r = new MutationObserver(o => { let s = !1; for (const l of o) s = s || ss(l.addedNodes, i), s = s && !ss(l.removedNodes, i); s && n() }); return r.observe(document, { childList: !0, subtree: !0 }), r } function a1(t, e, n) { const i = t.canvas, r = new MutationObserver(o => { let s = !1; for (const l of o) s = s || ss(l.removedNodes, i), s = s && !ss(l.addedNodes, i); s && n() }); return r.observe(document, { childList: !0, subtree: !0 }), r } const wr = new Map; let Sd = 0; function ng() { const t = window.devicePixelRatio; t !== Sd && (Sd = t, wr.forEach((e, n) => { n.currentDevicePixelRatio !== t && e() })) } function u1(t, e) { wr.size || window.addEventListener("resize", ng), wr.set(t, e) } function c1(t) { wr.delete(t), wr.size || window.removeEventListener("resize", ng) } function d1(t, e, n) { const i = t.canvas, r = i && ju(i); if (!r) return; const o = Ip((l, a) => { const u = r.clientWidth; n(l, a), u < r.clientWidth && n() }, window), s = new ResizeObserver(l => { const a = l[0], u = a.contentRect.width, d = a.contentRect.height; u === 0 && d === 0 || o(u, d) }); return s.observe(r), u1(t, o), s } function al(t, e, n) { n && n.disconnect(), e === "resize" && c1(t) } function f1(t, e, n) { const i = t.canvas, r = Ip(o => { t.ctx !== null && n(s1(o, t)) }, t); return r1(i, e, r), r } class h1 extends eg { acquireContext(e, n) { const i = e && e.getContext && e.getContext("2d"); return i && i.canvas === e ? (i1(e, n), i) : null } releaseContext(e) { const n = e.canvas; if (!n[So]) return !1; const i = n[So].initial;["height", "width"].forEach(o => { const s = i[o]; te(s) ? n.removeAttribute(o) : n.setAttribute(o, s) }); const r = i.style || {}; return Object.keys(r).forEach(o => { n.style[o] = r[o] }), n.width = n.width, delete n[So], !0 } addEventListener(e, n, i) { this.removeEventListener(e, n); const r = e.$proxies || (e.$proxies = {}), s = { attach: l1, detach: a1, resize: d1 }[n] || f1; r[n] = s(e, n, i) } removeEventListener(e, n) { const i = e.$proxies || (e.$proxies = {}), r = i[n]; if (!r) return; ({ attach: al, detach: al, resize: al }[n] || o1)(e, n, r), i[n] = void 0 } getDevicePixelRatio() { return window.devicePixelRatio } getMaximumSize(e, n, i, r) { return Sy(e, n, i, r) } isAttached(e) { const n = ju(e); return !!(n && n.isConnected) } } function p1(t) { return !Yp() || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas ? t1 : h1 } class An { constructor() { z(this, "x"); z(this, "y"); z(this, "active", !1); z(this, "options"); z(this, "$animations") } tooltipPosition(e) { const { x: n, y: i } = this.getProps(["x", "y"], e); return { x: n, y: i } } hasValue() { return ns(this.x) && ns(this.y) } getProps(e, n) { const i = this.$animations; if (!n || !i) return this; const r = {}; return e.forEach(o => { r[o] = i[o] && i[o].active() ? i[o]._to : this[o] }), r } } z(An, "defaults", {}), z(An, "defaultRoutes"); function g1(t, e) { const n = t.options.ticks, i = m1(t), r = Math.min(n.maxTicksLimit || i, i), o = n.major.enabled ? y1(e) : [], s = o.length, l = o[0], a = o[s - 1], u = []; if (s > r) return x1(e, u, o, s / r), u; const d = v1(o, e, r); if (s > 0) { let f, c; const h = s > 1 ? Math.round((a - l) / (s - 1)) : null; for (io(e, u, d, te(h) ? 0 : l - h, l), f = 0, c = s - 1; f < c; f++)io(e, u, d, o[f], o[f + 1]); return io(e, u, d, a, te(h) ? e.length : a + h), u } return io(e, u, d), u } function m1(t) { const e = t.options.offset, n = t._tickSize(), i = t._length / n + (e ? 0 : 1), r = t._maxLength / n; return Math.floor(Math.min(i, r)) } function v1(t, e, n) { const i = _1(t), r = e.length / n; if (!i) return Math.max(r, 1); const o = Dv(i); for (let s = 0, l = o.length - 1; s < l; s++) { const a = o[s]; if (a > r) return a } return Math.max(r, 1) } function y1(t) { const e = []; let n, i; for (n = 0, i = t.length; n < i; n++)t[n].major && e.push(n); return e } function x1(t, e, n, i) { let r = 0, o = n[0], s; for (i = Math.ceil(i), s = 0; s < t.length; s++)s === o && (e.push(t[s]), r++, o = n[r * i]) } function io(t, e, n, i, r) { const o = U(i, 0), s = Math.min(U(r, t.length), t.length); let l = 0, a, u, d; for (n = Math.ceil(n), r && (a = r - i, n = a / Math.floor(a / n)), d = o; d < 0;)l++, d = Math.round(o + l * n); for (u = Math.max(o, 0); u < s; u++)u === d && (e.push(t[u]), l++, d = Math.round(o + l * n)) } function _1(t) { const e = t.length; let n, i; if (e < 2) return !1; for (i = t[0], n = 1; n < e; ++n)if (t[n] - t[n - 1] !== i) return !1; return i } const w1 = t => t === "left" ? "right" : t === "right" ? "left" : t, Ed = (t, e, n) => e === "top" || e === "left" ? t[e] + n : t[e] - n, Cd = (t, e) => Math.min(e || t, t); function Pd(t, e) { const n = [], i = t.length / e, r = t.length; let o = 0; for (; o < r; o += i)n.push(t[Math.floor(o)]); return n } function k1(t, e, n) { const i = t.ticks.length, r = Math.min(e, i - 1), o = t._startPixel, s = t._endPixel, l = 1e-6; let a = t.getPixelForTick(r), u; if (!(n && (i === 1 ? u = Math.max(a - o, s - a) : e === 0 ? u = (t.getPixelForTick(1) - a) / 2 : u = (a - t.getPixelForTick(r - 1)) / 2, a += r < e ? u : -u, a < o - l || a > s + l))) return a } function b1(t, e) { $(t, n => { const i = n.gc, r = i.length / 2; let o; if (r > e) { for (o = 0; o < r; ++o)delete n.data[i[o]]; i.splice(0, r) } }) } function ji(t) { return t.drawTicks ? t.tickLength : 0 } function Od(t, e) { if (!t.display) return 0; const n = ve(t.font, e), i = Te(t.padding); return (oe(t.text) ? t.text.length : 1) * n.lineHeight + i.height } function S1(t, e) { return Nn(t, { scale: e, type: "scale" }) } function E1(t, e, n) { return Nn(t, { tick: n, index: e, type: "tick" }) } function C1(t, e, n) { let i = Fp(t); return (n && e !== "right" || !n && e === "right") && (i = w1(i)), i } function P1(t, e, n, i) { const { top: r, left: o, bottom: s, right: l, chart: a } = t, { chartArea: u, scales: d } = a; let f = 0, c, h, g; const v = s - r, _ = l - o; if (t.isHorizontal()) { if (h = We(i, o, l), W(n)) { const m = Object.keys(n)[0], p = n[m]; g = d[m].getPixelForValue(p) + v - e } else n === "center" ? g = (u.bottom + u.top) / 2 + v - e : g = Ed(t, n, e); c = l - o } else { if (W(n)) { const m = Object.keys(n)[0], p = n[m]; h = d[m].getPixelForValue(p) - _ + e } else n === "center" ? h = (u.left + u.right) / 2 - _ + e : h = Ed(t, n, e); g = We(i, s, r), f = n === "left" ? -ue : ue } return { titleX: h, titleY: g, maxWidth: c, rotation: f } } class _i extends An { constructor(e) { super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = { left: 0, right: 0, top: 0, bottom: 0 }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0 } init(e) { this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax) } parse(e, n) { return e } getUserBounds() { let { _userMin: e, _userMax: n, _suggestedMin: i, _suggestedMax: r } = this; return e = Ve(e, Number.POSITIVE_INFINITY), n = Ve(n, Number.NEGATIVE_INFINITY), i = Ve(i, Number.POSITIVE_INFINITY), r = Ve(r, Number.NEGATIVE_INFINITY), { min: Ve(e, i), max: Ve(n, r), minDefined: he(e), maxDefined: he(n) } } getMinMax(e) { let { min: n, max: i, minDefined: r, maxDefined: o } = this.getUserBounds(), s; if (r && o) return { min: n, max: i }; const l = this.getMatchingVisibleMetas(); for (let a = 0, u = l.length; a < u; ++a)s = l[a].controller.getMinMax(this, e), r || (n = Math.min(n, s.min)), o || (i = Math.max(i, s.max)); return n = o && n > i ? i : n, i = r && n > i ? n : i, { min: Ve(n, Ve(i, n)), max: Ve(i, Ve(n, i)) } } getPadding() { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } } getTicks() { return this.ticks } getLabels() { const e = this.chart.data; return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [] } getLabelItems(e = this.chart.chartArea) { return this._labelItems || (this._labelItems = this._computeLabelItems(e)) } beforeLayout() { this._cache = {}, this._dataLimitsCached = !1 } beforeUpdate() { K(this.options.beforeUpdate, [this]) } update(e, n, i) { const { beginAtZero: r, grace: o, ticks: s } = this.options, l = s.sampleSize; this.beforeUpdate(), this.maxWidth = e, this.maxHeight = n, this._margins = i = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = uy(this, o, r), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks(); const a = l < this.ticks.length; this._convertTicksToLabels(a ? Pd(this.ticks, l) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), s.display && (s.autoSkip || s.source === "auto") && (this.ticks = g1(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), a && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate() } configure() { let e = this.options.reverse, n, i; this.isHorizontal() ? (n = this.left, i = this.right) : (n = this.top, i = this.bottom, e = !e), this._startPixel = n, this._endPixel = i, this._reversePixels = e, this._length = i - n, this._alignToPixels = this.options.alignToPixels } afterUpdate() { K(this.options.afterUpdate, [this]) } beforeSetDimensions() { K(this.options.beforeSetDimensions, [this]) } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0 } afterSetDimensions() { K(this.options.afterSetDimensions, [this]) } _callHooks(e) { this.chart.notifyPlugins(e, this.getContext()), K(this.options[e], [this]) } beforeDataLimits() { this._callHooks("beforeDataLimits") } determineDataLimits() { } afterDataLimits() { this._callHooks("afterDataLimits") } beforeBuildTicks() { this._callHooks("beforeBuildTicks") } buildTicks() { return [] } afterBuildTicks() { this._callHooks("afterBuildTicks") } beforeTickToLabelConversion() { K(this.options.beforeTickToLabelConversion, [this]) } generateTickLabels(e) { const n = this.options.ticks; let i, r, o; for (i = 0, r = e.length; i < r; i++)o = e[i], o.label = K(n.callback, [o.value, i, e], this) } afterTickToLabelConversion() { K(this.options.afterTickToLabelConversion, [this]) } beforeCalculateLabelRotation() { K(this.options.beforeCalculateLabelRotation, [this]) } calculateLabelRotation() { const e = this.options, n = e.ticks, i = Cd(this.ticks.length, e.ticks.maxTicksLimit), r = n.minRotation || 0, o = n.maxRotation; let s = r, l, a, u; if (!this._isVisible() || !n.display || r >= o || i <= 1 || !this.isHorizontal()) { this.labelRotation = r; return } const d = this._getLabelSizes(), f = d.widest.width, c = d.highest.height, h = tt(this.chart.width - f, 0, this.maxWidth); l = e.offset ? this.maxWidth / i : h / (i - 1), f + 6 > l && (l = h / (i - (e.offset ? .5 : 1)), a = this.maxHeight - ji(e.grid) - n.padding - Od(e.title, this.chart.options.font), u = Math.sqrt(f * f + c * c), s = Su(Math.min(Math.asin(tt((d.highest.height + 6) / l, -1, 1)), Math.asin(tt(a / u, -1, 1)) - Math.asin(tt(c / u, -1, 1)))), s = Math.max(r, Math.min(o, s))), this.labelRotation = s } afterCalculateLabelRotation() { K(this.options.afterCalculateLabelRotation, [this]) } afterAutoSkip() { } beforeFit() { K(this.options.beforeFit, [this]) } fit() { const e = { width: 0, height: 0 }, { chart: n, options: { ticks: i, title: r, grid: o } } = this, s = this._isVisible(), l = this.isHorizontal(); if (s) { const a = Od(r, n.options.font); if (l ? (e.width = this.maxWidth, e.height = ji(o) + a) : (e.height = this.maxHeight, e.width = ji(o) + a), i.display && this.ticks.length) { const { first: u, last: d, widest: f, highest: c } = this._getLabelSizes(), h = i.padding * 2, g = Yt(this.labelRotation), v = Math.cos(g), _ = Math.sin(g); if (l) { const m = i.mirror ? 0 : _ * f.width + v * c.height; e.height = Math.min(this.maxHeight, e.height + m + h) } else { const m = i.mirror ? 0 : v * f.width + _ * c.height; e.width = Math.min(this.maxWidth, e.width + m + h) } this._calculatePadding(u, d, _, v) } } this._handleMargins(), l ? (this.width = this._length = n.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = n.height - this._margins.top - this._margins.bottom) } _calculatePadding(e, n, i, r) { const { ticks: { align: o, padding: s }, position: l } = this.options, a = this.labelRotation !== 0, u = l !== "top" && this.axis === "x"; if (this.isHorizontal()) { const d = this.getPixelForTick(0) - this.left, f = this.right - this.getPixelForTick(this.ticks.length - 1); let c = 0, h = 0; a ? u ? (c = r * e.width, h = i * n.height) : (c = i * e.height, h = r * n.width) : o === "start" ? h = n.width : o === "end" ? c = e.width : o !== "inner" && (c = e.width / 2, h = n.width / 2), this.paddingLeft = Math.max((c - d + s) * this.width / (this.width - d), 0), this.paddingRight = Math.max((h - f + s) * this.width / (this.width - f), 0) } else { let d = n.height / 2, f = e.height / 2; o === "start" ? (d = 0, f = e.height) : o === "end" && (d = n.height, f = 0), this.paddingTop = d + s, this.paddingBottom = f + s } } _handleMargins() { this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)) } afterFit() { K(this.options.afterFit, [this]) } isHorizontal() { const { axis: e, position: n } = this.options; return n === "top" || n === "bottom" || e === "x" } isFullSize() { return this.options.fullSize } _convertTicksToLabels(e) { this.beforeTickToLabelConversion(), this.generateTickLabels(e); let n, i; for (n = 0, i = e.length; n < i; n++)te(e[n].label) && (e.splice(n, 1), i--, n--); this.afterTickToLabelConversion() } _getLabelSizes() { let e = this._labelSizes; if (!e) { const n = this.options.ticks.sampleSize; let i = this.ticks; n < i.length && (i = Pd(i, n)), this._labelSizes = e = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit) } return e } _computeLabelSizes(e, n, i) { const { ctx: r, _longestTextCache: o } = this, s = [], l = [], a = Math.floor(n / Cd(n, i)); let u = 0, d = 0, f, c, h, g, v, _, m, p, y, w, S; for (f = 0; f < n; f += a) { if (g = e[f].label, v = this._resolveTickFontOptions(f), r.font = _ = v.string, m = o[_] = o[_] || { data: {}, gc: [] }, p = v.lineHeight, y = w = 0, !te(g) && !oe(g)) y = is(r, m.data, m.gc, y, g), w = p; else if (oe(g)) for (c = 0, h = g.length; c < h; ++c)S = g[c], !te(S) && !oe(S) && (y = is(r, m.data, m.gc, y, S), w += p); s.push(y), l.push(w), u = Math.max(y, u), d = Math.max(w, d) } b1(o, n); const x = s.indexOf(u), k = l.indexOf(d), b = C => ({ width: s[C] || 0, height: l[C] || 0 }); return { first: b(0), last: b(n - 1), widest: b(x), highest: b(k), widths: s, heights: l } } getLabelForValue(e) { return e } getPixelForValue(e, n) { return NaN } getValueForPixel(e) { } getPixelForTick(e) { const n = this.ticks; return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value) } getPixelForDecimal(e) { this._reversePixels && (e = 1 - e); const n = this._startPixel + e * this._length; return Iv(this._alignToPixels ? hn(this.chart, n, 0) : n) } getDecimalForPixel(e) { const n = (e - this._startPixel) / this._length; return this._reversePixels ? 1 - n : n } getBasePixel() { return this.getPixelForValue(this.getBaseValue()) } getBaseValue() { const { min: e, max: n } = this; return e < 0 && n < 0 ? n : e > 0 && n > 0 ? e : 0 } getContext(e) { const n = this.ticks || []; if (e >= 0 && e < n.length) { const i = n[e]; return i.$context || (i.$context = E1(this.getContext(), e, i)) } return this.$context || (this.$context = S1(this.chart.getContext(), this)) } _tickSize() { const e = this.options.ticks, n = Yt(this.labelRotation), i = Math.abs(Math.cos(n)), r = Math.abs(Math.sin(n)), o = this._getLabelSizes(), s = e.autoSkipPadding || 0, l = o ? o.widest.width + s : 0, a = o ? o.highest.height + s : 0; return this.isHorizontal() ? a * i > l * r ? l / i : a / r : a * r < l * i ? a / i : l / r } _isVisible() { const e = this.options.display; return e !== "auto" ? !!e : this.getMatchingVisibleMetas().length > 0 } _computeGridLineItems(e) { const n = this.axis, i = this.chart, r = this.options, { grid: o, position: s, border: l } = r, a = o.offset, u = this.isHorizontal(), f = this.ticks.length + (a ? 1 : 0), c = ji(o), h = [], g = l.setContext(this.getContext()), v = g.display ? g.width : 0, _ = v / 2, m = function (F) { return hn(i, F, v) }; let p, y, w, S, x, k, b, C, P, M, T, L; if (s === "top") p = m(this.bottom), k = this.bottom - c, C = p - _, M = m(e.top) + _, L = e.bottom; else if (s === "bottom") p = m(this.top), M = e.top, L = m(e.bottom) - _, k = p + _, C = this.top + c; else if (s === "left") p = m(this.right), x = this.right - c, b = p - _, P = m(e.left) + _, T = e.right; else if (s === "right") p = m(this.left), P = e.left, T = m(e.right) - _, x = p + _, b = this.left + c; else if (n === "x") { if (s === "center") p = m((e.top + e.bottom) / 2 + .5); else if (W(s)) { const F = Object.keys(s)[0], Y = s[F]; p = m(this.chart.scales[F].getPixelForValue(Y)) } M = e.top, L = e.bottom, k = p + _, C = k + c } else if (n === "y") { if (s === "center") p = m((e.left + e.right) / 2); else if (W(s)) { const F = Object.keys(s)[0], Y = s[F]; p = m(this.chart.scales[F].getPixelForValue(Y)) } x = p - _, b = x - c, P = e.left, T = e.right } const I = U(r.ticks.maxTicksLimit, f), D = Math.max(1, Math.ceil(f / I)); for (y = 0; y < f; y += D) { const F = this.getContext(y), Y = o.setContext(F), R = l.setContext(F), j = Y.lineWidth, N = Y.color, V = R.dash || [], Q = R.dashOffset, Be = Y.tickWidth, ke = Y.tickColor, kt = Y.tickBorderDash || [], He = Y.tickBorderDashOffset; w = k1(this, y, a), w !== void 0 && (S = hn(i, w, j), u ? x = b = P = T = S : k = C = M = L = S, h.push({ tx1: x, ty1: k, tx2: b, ty2: C, x1: P, y1: M, x2: T, y2: L, width: j, color: N, borderDash: V, borderDashOffset: Q, tickWidth: Be, tickColor: ke, tickBorderDash: kt, tickBorderDashOffset: He })) } return this._ticksLength = f, this._borderValue = p, h } _computeLabelItems(e) { const n = this.axis, i = this.options, { position: r, ticks: o } = i, s = this.isHorizontal(), l = this.ticks, { align: a, crossAlign: u, padding: d, mirror: f } = o, c = ji(i.grid), h = c + d, g = f ? -d : h, v = -Yt(this.labelRotation), _ = []; let m, p, y, w, S, x, k, b, C, P, M, T, L = "middle"; if (r === "top") x = this.bottom - g, k = this._getXAxisLabelAlignment(); else if (r === "bottom") x = this.top + g, k = this._getXAxisLabelAlignment(); else if (r === "left") { const D = this._getYAxisLabelAlignment(c); k = D.textAlign, S = D.x } else if (r === "right") { const D = this._getYAxisLabelAlignment(c); k = D.textAlign, S = D.x } else if (n === "x") { if (r === "center") x = (e.top + e.bottom) / 2 + h; else if (W(r)) { const D = Object.keys(r)[0], F = r[D]; x = this.chart.scales[D].getPixelForValue(F) + h } k = this._getXAxisLabelAlignment() } else if (n === "y") { if (r === "center") S = (e.left + e.right) / 2 - h; else if (W(r)) { const D = Object.keys(r)[0], F = r[D]; S = this.chart.scales[D].getPixelForValue(F) } k = this._getYAxisLabelAlignment(c).textAlign } n === "y" && (a === "start" ? L = "top" : a === "end" && (L = "bottom")); const I = this._getLabelSizes(); for (m = 0, p = l.length; m < p; ++m) { y = l[m], w = y.label; const D = o.setContext(this.getContext(m)); b = this.getPixelForTick(m) + o.labelOffset, C = this._resolveTickFontOptions(m), P = C.lineHeight, M = oe(w) ? w.length : 1; const F = M / 2, Y = D.color, R = D.textStrokeColor, j = D.textStrokeWidth; let N = k; s ? (S = b, k === "inner" && (m === p - 1 ? N = this.options.reverse ? "left" : "right" : m === 0 ? N = this.options.reverse ? "right" : "left" : N = "center"), r === "top" ? u === "near" || v !== 0 ? T = -M * P + P / 2 : u === "center" ? T = -I.highest.height / 2 - F * P + P : T = -I.highest.height + P / 2 : u === "near" || v !== 0 ? T = P / 2 : u === "center" ? T = I.highest.height / 2 - F * P : T = I.highest.height - M * P, f && (T *= -1), v !== 0 && !D.showLabelBackdrop && (S += P / 2 * Math.sin(v))) : (x = b, T = (1 - M) * P / 2); let V; if (D.showLabelBackdrop) { const Q = Te(D.backdropPadding), Be = I.heights[m], ke = I.widths[m]; let kt = T - Q.top, He = 0 - Q.left; switch (L) { case "middle": kt -= Be / 2; break; case "bottom": kt -= Be; break }switch (k) { case "center": He -= ke / 2; break; case "right": He -= ke; break }V = { left: He, top: kt, width: ke + Q.width, height: Be + Q.height, color: D.backdropColor } } _.push({ label: w, font: C, textOffset: T, options: { rotation: v, color: Y, strokeColor: R, strokeWidth: j, textAlign: N, textBaseline: L, translation: [S, x], backdrop: V } }) } return _ } _getXAxisLabelAlignment() { const { position: e, ticks: n } = this.options; if (-Yt(this.labelRotation)) return e === "top" ? "left" : "right"; let r = "center"; return n.align === "start" ? r = "left" : n.align === "end" ? r = "right" : n.align === "inner" && (r = "inner"), r } _getYAxisLabelAlignment(e) { const { position: n, ticks: { crossAlign: i, mirror: r, padding: o } } = this.options, s = this._getLabelSizes(), l = e + o, a = s.widest.width; let u, d; return n === "left" ? r ? (d = this.right + o, i === "near" ? u = "left" : i === "center" ? (u = "center", d += a / 2) : (u = "right", d += a)) : (d = this.right - l, i === "near" ? u = "right" : i === "center" ? (u = "center", d -= a / 2) : (u = "left", d = this.left)) : n === "right" ? r ? (d = this.left + o, i === "near" ? u = "right" : i === "center" ? (u = "center", d -= a / 2) : (u = "left", d -= a)) : (d = this.left + l, i === "near" ? u = "left" : i === "center" ? (u = "center", d += a / 2) : (u = "right", d = this.right)) : u = "right", { textAlign: u, x: d } } _computeLabelArea() { if (this.options.ticks.mirror) return; const e = this.chart, n = this.options.position; if (n === "left" || n === "right") return { top: 0, left: this.left, bottom: e.height, right: this.right }; if (n === "top" || n === "bottom") return { top: this.top, left: 0, bottom: this.bottom, right: e.width } } drawBackground() { const { ctx: e, options: { backgroundColor: n }, left: i, top: r, width: o, height: s } = this; n && (e.save(), e.fillStyle = n, e.fillRect(i, r, o, s), e.restore()) } getLineWidthForValue(e) { const n = this.options.grid; if (!this._isVisible() || !n.display) return 0; const r = this.ticks.findIndex(o => o.value === e); return r >= 0 ? n.setContext(this.getContext(r)).lineWidth : 0 } drawGrid(e) { const n = this.options.grid, i = this.ctx, r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e)); let o, s; const l = (a, u, d) => { !d.width || !d.color || (i.save(), i.lineWidth = d.width, i.strokeStyle = d.color, i.setLineDash(d.borderDash || []), i.lineDashOffset = d.borderDashOffset, i.beginPath(), i.moveTo(a.x, a.y), i.lineTo(u.x, u.y), i.stroke(), i.restore()) }; if (n.display) for (o = 0, s = r.length; o < s; ++o) { const a = r[o]; n.drawOnChartArea && l({ x: a.x1, y: a.y1 }, { x: a.x2, y: a.y2 }, a), n.drawTicks && l({ x: a.tx1, y: a.ty1 }, { x: a.tx2, y: a.ty2 }, { color: a.tickColor, width: a.tickWidth, borderDash: a.tickBorderDash, borderDashOffset: a.tickBorderDashOffset }) } } drawBorder() { const { chart: e, ctx: n, options: { border: i, grid: r } } = this, o = i.setContext(this.getContext()), s = i.display ? o.width : 0; if (!s) return; const l = r.setContext(this.getContext(0)).lineWidth, a = this._borderValue; let u, d, f, c; this.isHorizontal() ? (u = hn(e, this.left, s) - s / 2, d = hn(e, this.right, l) + l / 2, f = c = a) : (f = hn(e, this.top, s) - s / 2, c = hn(e, this.bottom, l) + l / 2, u = d = a), n.save(), n.lineWidth = o.width, n.strokeStyle = o.color, n.beginPath(), n.moveTo(u, f), n.lineTo(d, c), n.stroke(), n.restore() } drawLabels(e) { if (!this.options.ticks.display) return; const i = this.ctx, r = this._computeLabelArea(); r && Pu(i, r); const o = this.getLabelItems(e); for (const s of o) { const l = s.options, a = s.font, u = s.label, d = s.textOffset; gi(i, u, 0, d, a, l) } r && Ou(i) } drawTitle() { const { ctx: e, options: { position: n, title: i, reverse: r } } = this; if (!i.display) return; const o = ve(i.font), s = Te(i.padding), l = i.align; let a = o.lineHeight / 2; n === "bottom" || n === "center" || W(n) ? (a += s.bottom, oe(i.text) && (a += o.lineHeight * (i.text.length - 1))) : a += s.top; const { titleX: u, titleY: d, maxWidth: f, rotation: c } = P1(this, a, n, l); gi(e, i.text, 0, 0, o, { color: i.color, maxWidth: f, rotation: c, textAlign: C1(l, n, r), textBaseline: "middle", translation: [u, d] }) } draw(e) { this._isVisible() && (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e)) } _layers() { const e = this.options, n = e.ticks && e.ticks.z || 0, i = U(e.grid && e.grid.z, -1), r = U(e.border && e.border.z, 0); return !this._isVisible() || this.draw !== _i.prototype.draw ? [{ z: n, draw: o => { this.draw(o) } }] : [{ z: i, draw: o => { this.drawBackground(), this.drawGrid(o), this.drawTitle() } }, { z: r, draw: () => { this.drawBorder() } }, { z: n, draw: o => { this.drawLabels(o) } }] } getMatchingVisibleMetas(e) { const n = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + "AxisID", r = []; let o, s; for (o = 0, s = n.length; o < s; ++o) { const l = n[o]; l[i] === this.id && (!e || l.type === e) && r.push(l) } return r } _resolveTickFontOptions(e) { const n = this.options.ticks.setContext(this.getContext(e)); return ve(n.font) } _maxDigits() { const e = this._resolveTickFontOptions(0).lineHeight; return (this.isHorizontal() ? this.width : this.height) / e } } class ro { constructor(e, n, i) { this.type = e, this.scope = n, this.override = i, this.items = Object.create(null) } isForType(e) { return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype) } register(e) { const n = Object.getPrototypeOf(e); let i; T1(n) && (i = this.register(n)); const r = this.items, o = e.id, s = this.scope + "." + o; if (!o) throw new Error("class does not have id: " + e); return o in r || (r[o] = e, O1(e, s, i), this.override && se.override(e.id, e.overrides)), s } get(e) { return this.items[e] } unregister(e) { const n = this.items, i = e.id, r = this.scope; i in n && delete n[i], r && i in se[r] && (delete se[r][i], this.override && delete Rn[i]) } } function O1(t, e, n) { const i = _r(Object.create(null), [n ? se.get(n) : {}, se.get(e), t.defaults]); se.set(e, i), t.defaultRoutes && M1(e, t.defaultRoutes), t.descriptors && se.describe(e, t.descriptors) } function M1(t, e) { Object.keys(e).forEach(n => { const i = n.split("."), r = i.pop(), o = [t].concat(i).join("."), s = e[n].split("."), l = s.pop(), a = s.join("."); se.route(o, r, a, l) }) } function T1(t) { return "id" in t && "defaults" in t } class R1 { constructor() { this.controllers = new ro(bo, "datasets", !0), this.elements = new ro(An, "elements"), this.plugins = new ro(Object, "plugins"), this.scales = new ro(_i, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements] } add(...e) { this._each("register", e) } remove(...e) { this._each("unregister", e) } addControllers(...e) { this._each("register", e, this.controllers) } addElements(...e) { this._each("register", e, this.elements) } addPlugins(...e) { this._each("register", e, this.plugins) } addScales(...e) { this._each("register", e, this.scales) } getController(e) { return this._get(e, this.controllers, "controller") } getElement(e) { return this._get(e, this.elements, "element") } getPlugin(e) { return this._get(e, this.plugins, "plugin") } getScale(e) { return this._get(e, this.scales, "scale") } removeControllers(...e) { this._each("unregister", e, this.controllers) } removeElements(...e) { this._each("unregister", e, this.elements) } removePlugins(...e) { this._each("unregister", e, this.plugins) } removeScales(...e) { this._each("unregister", e, this.scales) } _each(e, n, i) { [...n].forEach(r => { const o = i || this._getRegistryForType(r); i || o.isForType(r) || o === this.plugins && r.id ? this._exec(e, o, r) : $(r, s => { const l = i || this._getRegistryForType(s); this._exec(e, l, s) }) }) } _exec(e, n, i) { const r = bu(e); K(i["before" + r], [], i), n[e](i), K(i["after" + r], [], i) } _getRegistryForType(e) { for (let n = 0; n < this._typedRegistries.length; n++) { const i = this._typedRegistries[n]; if (i.isForType(e)) return i } return this.plugins } _get(e, n, i) { const r = n.get(e); if (r === void 0) throw new Error('"' + e + '" is not a registered ' + i + "."); return r } } var vt = new R1; class A1 { constructor() { this._init = [] } notify(e, n, i, r) { n === "beforeInit" && (this._init = this._createDescriptors(e, !0), this._notify(this._init, e, "install")); const o = r ? this._descriptors(e).filter(r) : this._descriptors(e), s = this._notify(o, e, n, i); return n === "afterDestroy" && (this._notify(o, e, "stop"), this._notify(this._init, e, "uninstall")), s } _notify(e, n, i, r) { r = r || {}; for (const o of e) { const s = o.plugin, l = s[i], a = [n, r, o.options]; if (K(l, a, s) === !1 && r.cancelable) return !1 } return !0 } invalidate() { te(this._cache) || (this._oldCache = this._cache, this._cache = void 0) } _descriptors(e) { if (this._cache) return this._cache; const n = this._cache = this._createDescriptors(e); return this._notifyStateChanges(e), n } _createDescriptors(e, n) { const i = e && e.config, r = U(i.options && i.options.plugins, {}), o = j1(i); return r === !1 && !n ? [] : D1(e, o, r, n) } _notifyStateChanges(e) { const n = this._oldCache || [], i = this._cache, r = (o, s) => o.filter(l => !s.some(a => l.plugin.id === a.plugin.id)); this._notify(r(n, i), e, "stop"), this._notify(r(i, n), e, "start") } } function j1(t) { const e = {}, n = [], i = Object.keys(vt.plugins.items); for (let o = 0; o < i.length; o++)n.push(vt.getPlugin(i[o])); const r = t.plugins || []; for (let o = 0; o < r.length; o++) { const s = r[o]; n.indexOf(s) === -1 && (n.push(s), e[s.id] = !0) } return { plugins: n, localIds: e } } function L1(t, e) { return !e && t === !1 ? null : t === !0 ? {} : t } function D1(t, { plugins: e, localIds: n }, i, r) { const o = [], s = t.getContext(); for (const l of e) { const a = l.id, u = L1(i[a], r); u !== null && o.push({ plugin: l, options: N1(t.config, { plugin: l, local: n[a] }, u, s) }) } return o } function N1(t, { plugin: e, local: n }, i, r) { const o = t.pluginScopeKeys(e), s = t.getOptionScopes(i, o); return n && e.defaults && s.push(e.defaults), t.createResolver(s, r, [""], { scriptable: !1, indexable: !1, allKeys: !0 }) } function ya(t, e) { const n = se.datasets[t] || {}; return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || n.indexAxis || "x" } function z1(t, e) { let n = t; return t === "_index_" ? n = e : t === "_value_" && (n = e === "x" ? "y" : "x"), n } function I1(t, e) { return t === e ? "_index_" : "_value_" } function Md(t) { if (t === "x" || t === "y" || t === "r") return t } function F1(t) { if (t === "top" || t === "bottom") return "x"; if (t === "left" || t === "right") return "y" } function xa(t, ...e) { if (Md(t)) return t; for (const n of e) { const i = n.axis || F1(n.position) || t.length > 1 && Md(t[0].toLowerCase()); if (i) return i } throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`) } function Td(t, e, n) { if (n[e + "AxisID"] === t) return { axis: e } } function B1(t, e) { if (e.data && e.data.datasets) { const n = e.data.datasets.filter(i => i.xAxisID === t || i.yAxisID === t); if (n.length) return Td(t, "x", n[0]) || Td(t, "y", n[0]) } return {} } function H1(t, e) { const n = Rn[t.type] || { scales: {} }, i = e.scales || {}, r = ya(t.type, e), o = Object.create(null); return Object.keys(i).forEach(s => { const l = i[s]; if (!W(l)) return console.error(`Invalid scale configuration for scale: ${s}`); if (l._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${s}`); const a = xa(s, l, B1(s, t), se.scales[l.type]), u = I1(a, r), d = n.scales || {}; o[s] = Ji(Object.create(null), [{ axis: a }, l, d[a], d[u]]) }), t.data.datasets.forEach(s => { const l = s.type || t.type, a = s.indexAxis || ya(l, e), d = (Rn[l] || {}).scales || {}; Object.keys(d).forEach(f => { const c = z1(f, a), h = s[c + "AxisID"] || c; o[h] = o[h] || Object.create(null), Ji(o[h], [{ axis: c }, i[h], d[f]]) }) }), Object.keys(o).forEach(s => { const l = o[s]; Ji(l, [se.scales[l.type], se.scale]) }), o } function ig(t) { const e = t.options || (t.options = {}); e.plugins = U(e.plugins, {}), e.scales = H1(t, e) } function rg(t) { return t = t || {}, t.datasets = t.datasets || [], t.labels = t.labels || [], t } function W1(t) { return t = t || {}, t.data = rg(t.data), ig(t), t } const Rd = new Map, og = new Set; function oo(t, e) { let n = Rd.get(t); return n || (n = e(), Rd.set(t, n), og.add(n)), n } const Li = (t, e, n) => { const i = qo(e, n); i !== void 0 && t.add(i) }; class V1 { constructor(e) { this._config = W1(e), this._scopeCache = new Map, this._resolverCache = new Map } get platform() { return this._config.platform } get type() { return this._config.type } set type(e) { this._config.type = e } get data() { return this._config.data } set data(e) { this._config.data = rg(e) } get options() { return this._config.options } set options(e) { this._config.options = e } get plugins() { return this._config.plugins } update() { const e = this._config; this.clearCache(), ig(e) } clearCache() { this._scopeCache.clear(), this._resolverCache.clear() } datasetScopeKeys(e) { return oo(e, () => [[`datasets.${e}`, ""]]) } datasetAnimationScopeKeys(e, n) { return oo(`${e}.transition.${n}`, () => [[`datasets.${e}.transitions.${n}`, `transitions.${n}`], [`datasets.${e}`, ""]]) } datasetElementScopeKeys(e, n) { return oo(`${e}-${n}`, () => [[`datasets.${e}.elements.${n}`, `datasets.${e}`, `elements.${n}`, ""]]) } pluginScopeKeys(e) { const n = e.id, i = this.type; return oo(`${i}-plugin-${n}`, () => [[`plugins.${n}`, ...e.additionalOptionScopes || []]]) } _cachedScopes(e, n) { const i = this._scopeCache; let r = i.get(e); return (!r || n) && (r = new Map, i.set(e, r)), r } getOptionScopes(e, n, i) { const { options: r, type: o } = this, s = this._cachedScopes(e, i), l = s.get(n); if (l) return l; const a = new Set; n.forEach(d => { e && (a.add(e), d.forEach(f => Li(a, e, f))), d.forEach(f => Li(a, r, f)), d.forEach(f => Li(a, Rn[o] || {}, f)), d.forEach(f => Li(a, se, f)), d.forEach(f => Li(a, va, f)) }); const u = Array.from(a); return u.length === 0 && u.push(Object.create(null)), og.has(n) && s.set(n, u), u } chartOptionScopes() { const { options: e, type: n } = this; return [e, Rn[n] || {}, se.datasets[n] || {}, { type: n }, se, va] } resolveNamedOptions(e, n, i, r = [""]) { const o = { $shared: !0 }, { resolver: s, subPrefixes: l } = Ad(this._resolverCache, e, r); let a = s; if (U1(s, n)) { o.$shared = !1, i = an(i) ? i() : i; const u = this.createResolver(e, i, l); a = mi(s, i, u) } for (const u of n) o[u] = a[u]; return o } createResolver(e, n, i = [""], r) { const { resolver: o } = Ad(this._resolverCache, e, i); return W(n) ? mi(o, n, void 0, r) : o } } function Ad(t, e, n) { let i = t.get(e); i || (i = new Map, t.set(e, i)); const r = n.join(); let o = i.get(r); return o || (o = { resolver: Tu(e, n), subPrefixes: n.filter(l => !l.toLowerCase().includes("hover")) }, i.set(r, o)), o } const $1 = t => W(t) && Object.getOwnPropertyNames(t).reduce((e, n) => e || an(t[n]), !1); function U1(t, e) { const { isScriptable: n, isIndexable: i } = Vp(t); for (const r of e) { const o = n(r), s = i(r), l = (s || o) && t[r]; if (o && (an(l) || $1(l)) || s && oe(l)) return !0 } return !1 } var X1 = "4.3.0"; const Y1 = ["top", "bottom", "left", "right", "chartArea"]; function jd(t, e) { return t === "top" || t === "bottom" || Y1.indexOf(t) === -1 && e === "x" } function Ld(t, e) { return function (n, i) { return n[t] === i[t] ? n[e] - i[e] : n[t] - i[t] } } function Dd(t) { const e = t.chart, n = e.options.animation; e.notifyPlugins("afterRender"), K(n && n.onComplete, [t], e) } function Q1(t) { const e = t.chart, n = e.options.animation; K(n && n.onProgress, [t], e) } function sg(t) { return Yp() && typeof t == "string" ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t } const Eo = {}, Nd = t => { const e = sg(t); return Object.values(Eo).filter(n => n.canvas === e).pop() }; function K1(t, e, n) { const i = Object.keys(t); for (const r of i) { const o = +r; if (o >= e) { const s = t[r]; delete t[r], (n > 0 || o > e) && (t[o + n] = s) } } } function G1(t, e, n, i) { return !n || t.type === "mouseout" ? null : i ? e : t } function Z1(t) { const { xScale: e, yScale: n } = t; if (e && n) return { left: e.left, right: e.right, top: n.top, bottom: n.bottom } } class Bt { static register(...e) { vt.add(...e), zd() } static unregister(...e) { vt.remove(...e), zd() } constructor(e, n) { const i = this.config = new V1(n), r = sg(e), o = Nd(r); if (o) throw new Error("Canvas is already in use. Chart with ID '" + o.id + "' must be destroyed before the canvas with ID '" + o.canvas.id + "' can be reused."); const s = i.createResolver(i.chartOptionScopes(), this.getContext()); this.platform = new (i.platform || p1(r)), this.platform.updateConfig(i); const l = this.platform.acquireContext(r, s.aspectRatio), a = l && l.canvas, u = a && a.height, d = a && a.width; if (this.id = Pv(), this.ctx = l, this.canvas = a, this.width = d, this.height = u, this._options = s, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new A1, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = Vv(f => this.update(f), s.resizeDelay || 0), this._dataChanges = [], Eo[this.id] = this, !l || !a) { console.error("Failed to create chart: can't acquire context from the given item"); return } St.listen(this, "complete", Dd), St.listen(this, "progress", Q1), this._initialize(), this.attached && this.update() } get aspectRatio() { const { options: { aspectRatio: e, maintainAspectRatio: n }, width: i, height: r, _aspectRatio: o } = this; return te(e) ? n && o ? o : r ? i / r : null : e } get data() { return this.config.data } set data(e) { this.config.data = e } get options() { return this._options } set options(e) { this.config.options = e } get registry() { return vt } _initialize() { return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : cd(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this } clear() { return sd(this.canvas, this.ctx), this } stop() { return St.stop(this), this } resize(e, n) { St.running(this) ? this._resizeBeforeDraw = { width: e, height: n } : this._resize(e, n) } _resize(e, n) { const i = this.options, r = this.canvas, o = i.maintainAspectRatio && this.aspectRatio, s = this.platform.getMaximumSize(r, e, n, o), l = i.devicePixelRatio || this.platform.getDevicePixelRatio(), a = this.width ? "resize" : "attach"; this.width = s.width, this.height = s.height, this._aspectRatio = this.aspectRatio, cd(this, l, !0) && (this.notifyPlugins("resize", { size: s }), K(i.onResize, [this, s], this), this.attached && this._doResize(a) && this.render()) } ensureScalesHaveIDs() { const n = this.options.scales || {}; $(n, (i, r) => { i.id = r }) } buildOrUpdateScales() { const e = this.options, n = e.scales, i = this.scales, r = Object.keys(i).reduce((s, l) => (s[l] = !1, s), {}); let o = []; n && (o = o.concat(Object.keys(n).map(s => { const l = n[s], a = xa(s, l), u = a === "r", d = a === "x"; return { options: l, dposition: u ? "chartArea" : d ? "bottom" : "left", dtype: u ? "radialLinear" : d ? "category" : "linear" } }))), $(o, s => { const l = s.options, a = l.id, u = xa(a, l), d = U(l.type, s.dtype); (l.position === void 0 || jd(l.position, u) !== jd(s.dposition)) && (l.position = s.dposition), r[a] = !0; let f = null; if (a in i && i[a].type === d) f = i[a]; else { const c = vt.getScale(d); f = new c({ id: a, type: d, ctx: this.ctx, chart: this }), i[f.id] = f } f.init(l, e) }), $(r, (s, l) => { s || delete i[l] }), $(i, s => { Qt.configure(this, s, s.options), Qt.addBox(this, s) }) } _updateMetasets() { const e = this._metasets, n = this.data.datasets.length, i = e.length; if (e.sort((r, o) => r.index - o.index), i > n) { for (let r = n; r < i; ++r)this._destroyDatasetMeta(r); e.splice(n, i - n) } this._sortedMetasets = e.slice(0).sort(Ld("order", "index")) } _removeUnreferencedMetasets() { const { _metasets: e, data: { datasets: n } } = this; e.length > n.length && delete this._stacks, e.forEach((i, r) => { n.filter(o => o === i._dataset).length === 0 && this._destroyDatasetMeta(r) }) } buildOrUpdateControllers() { const e = [], n = this.data.datasets; let i, r; for (this._removeUnreferencedMetasets(), i = 0, r = n.length; i < r; i++) { const o = n[i]; let s = this.getDatasetMeta(i); const l = o.type || this.config.type; if (s.type && s.type !== l && (this._destroyDatasetMeta(i), s = this.getDatasetMeta(i)), s.type = l, s.indexAxis = o.indexAxis || ya(l, this.options), s.order = o.order || 0, s.index = i, s.label = "" + o.label, s.visible = this.isDatasetVisible(i), s.controller) s.controller.updateIndex(i), s.controller.linkScales(); else { const a = vt.getController(l), { datasetElementType: u, dataElementType: d } = se.datasets[l]; Object.assign(a, { dataElementType: vt.getElement(d), datasetElementType: u && vt.getElement(u) }), s.controller = new a(this, i), e.push(s.controller) } } return this._updateMetasets(), e } _resetElements() { $(this.data.datasets, (e, n) => { this.getDatasetMeta(n).controller.reset() }, this) } reset() { this._resetElements(), this.notifyPlugins("reset") } update(e) { const n = this.config; n.update(); const i = this._options = n.createResolver(n.chartOptionScopes(), this.getContext()), r = this._animationsDisabled = !i.animation; if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", { mode: e, cancelable: !0 }) === !1) return; const o = this.buildOrUpdateControllers(); this.notifyPlugins("beforeElementsUpdate"); let s = 0; for (let u = 0, d = this.data.datasets.length; u < d; u++) { const { controller: f } = this.getDatasetMeta(u), c = !r && o.indexOf(f) === -1; f.buildOrUpdateElements(c), s = Math.max(+f.getMaxOverflow(), s) } s = this._minPadding = i.layout.autoPadding ? s : 0, this._updateLayout(s), r || $(o, u => { u.reset() }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", { mode: e }), this._layers.sort(Ld("z", "_idx")); const { _active: l, _lastEvent: a } = this; a ? this._eventHandler(a, !0) : l.length && this._updateHoverStyles(l, l, !0), this.render() } _updateScales() { $(this.scales, e => { Qt.removeBox(this, e) }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales() } _checkEventBindings() { const e = this.options, n = new Set(Object.keys(this._listeners)), i = new Set(e.events); (!Zc(n, i) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(), this.bindEvents()) } _updateHiddenIndices() { const { _hiddenIndices: e } = this, n = this._getUniformDataChanges() || []; for (const { method: i, start: r, count: o } of n) { const s = i === "_removeElements" ? -o : o; K1(e, r, s) } } _getUniformDataChanges() { const e = this._dataChanges; if (!e || !e.length) return; this._dataChanges = []; const n = this.data.datasets.length, i = o => new Set(e.filter(s => s[0] === o).map((s, l) => l + "," + s.splice(1).join(","))), r = i(0); for (let o = 1; o < n; o++)if (!Zc(r, i(o))) return; return Array.from(r).map(o => o.split(",")).map(o => ({ method: o[1], start: +o[2], count: +o[3] })) } _updateLayout(e) { if (this.notifyPlugins("beforeLayout", { cancelable: !0 }) === !1) return; Qt.update(this, this.width, this.height, e); const n = this.chartArea, i = n.width <= 0 || n.height <= 0; this._layers = [], $(this.boxes, r => { i && r.position === "chartArea" || (r.configure && r.configure(), this._layers.push(...r._layers())) }, this), this._layers.forEach((r, o) => { r._idx = o }), this.notifyPlugins("afterLayout") } _updateDatasets(e) { if (this.notifyPlugins("beforeDatasetsUpdate", { mode: e, cancelable: !0 }) !== !1) { for (let n = 0, i = this.data.datasets.length; n < i; ++n)this.getDatasetMeta(n).controller.configure(); for (let n = 0, i = this.data.datasets.length; n < i; ++n)this._updateDataset(n, an(e) ? e({ datasetIndex: n }) : e); this.notifyPlugins("afterDatasetsUpdate", { mode: e }) } } _updateDataset(e, n) { const i = this.getDatasetMeta(e), r = { meta: i, index: e, mode: n, cancelable: !0 }; this.notifyPlugins("beforeDatasetUpdate", r) !== !1 && (i.controller._update(n), r.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", r)) } render() { this.notifyPlugins("beforeRender", { cancelable: !0 }) !== !1 && (St.has(this) ? this.attached && !St.running(this) && St.start(this) : (this.draw(), Dd({ chart: this }))) } draw() { let e; if (this._resizeBeforeDraw) { const { width: i, height: r } = this._resizeBeforeDraw; this._resize(i, r), this._resizeBeforeDraw = null } if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", { cancelable: !0 }) === !1) return; const n = this._layers; for (e = 0; e < n.length && n[e].z <= 0; ++e)n[e].draw(this.chartArea); for (this._drawDatasets(); e < n.length; ++e)n[e].draw(this.chartArea); this.notifyPlugins("afterDraw") } _getSortedDatasetMetas(e) { const n = this._sortedMetasets, i = []; let r, o; for (r = 0, o = n.length; r < o; ++r) { const s = n[r]; (!e || s.visible) && i.push(s) } return i } getSortedVisibleDatasetMetas() { return this._getSortedDatasetMetas(!0) } _drawDatasets() { if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 }) === !1) return; const e = this.getSortedVisibleDatasetMetas(); for (let n = e.length - 1; n >= 0; --n)this._drawDataset(e[n]); this.notifyPlugins("afterDatasetsDraw") } _drawDataset(e) { const n = this.ctx, i = e._clip, r = !i.disabled, o = Z1(e) || this.chartArea, s = { meta: e, index: e.index, cancelable: !0 }; this.notifyPlugins("beforeDatasetDraw", s) !== !1 && (r && Pu(n, { left: i.left === !1 ? 0 : o.left - i.left, right: i.right === !1 ? this.width : o.right + i.right, top: i.top === !1 ? 0 : o.top - i.top, bottom: i.bottom === !1 ? this.height : o.bottom + i.bottom }), e.controller.draw(), r && Ou(n), s.cancelable = !1, this.notifyPlugins("afterDatasetDraw", s)) } isPointInArea(e) { return qn(e, this.chartArea, this._minPadding) } getElementsAtEventForMode(e, n, i, r) { const o = Yy.modes[n]; return typeof o == "function" ? o(this, e, i, r) : [] } getDatasetMeta(e) { const n = this.data.datasets[e], i = this._metasets; let r = i.filter(o => o && o._dataset === n).pop(); return r || (r = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: n && n.order || 0, index: e, _dataset: n, _parsed: [], _sorted: !1 }, i.push(r)), r } getContext() { return this.$context || (this.$context = Nn(null, { chart: this, type: "chart" })) } getVisibleDatasetCount() { return this.getSortedVisibleDatasetMetas().length } isDatasetVisible(e) { const n = this.data.datasets[e]; if (!n) return !1; const i = this.getDatasetMeta(e); return typeof i.hidden == "boolean" ? !i.hidden : !n.hidden } setDatasetVisibility(e, n) { const i = this.getDatasetMeta(e); i.hidden = !n } toggleDataVisibility(e) { this._hiddenIndices[e] = !this._hiddenIndices[e] } getDataVisibility(e) { return !this._hiddenIndices[e] } _updateVisibility(e, n, i) { const r = i ? "show" : "hide", o = this.getDatasetMeta(e), s = o.controller._resolveAnimations(void 0, r); Jo(n) ? (o.data[n].hidden = !i, this.update()) : (this.setDatasetVisibility(e, i), s.update(o, { visible: i }), this.update(l => l.datasetIndex === e ? r : void 0)) } hide(e, n) { this._updateVisibility(e, n, !1) } show(e, n) { this._updateVisibility(e, n, !0) } _destroyDatasetMeta(e) { const n = this._metasets[e]; n && n.controller && n.controller._destroy(), delete this._metasets[e] } _stop() { let e, n; for (this.stop(), St.remove(this), e = 0, n = this.data.datasets.length; e < n; ++e)this._destroyDatasetMeta(e) } destroy() { this.notifyPlugins("beforeDestroy"); const { canvas: e, ctx: n } = this; this._stop(), this.config.clearCache(), e && (this.unbindEvents(), sd(e, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete Eo[this.id], this.notifyPlugins("afterDestroy") } toBase64Image(...e) { return this.canvas.toDataURL(...e) } bindEvents() { this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0 } bindUserEvents() { const e = this._listeners, n = this.platform, i = (o, s) => { n.addEventListener(this, o, s), e[o] = s }, r = (o, s, l) => { o.offsetX = s, o.offsetY = l, this._eventHandler(o) }; $(this.options.events, o => i(o, r)) } bindResponsiveEvents() { this._responsiveListeners || (this._responsiveListeners = {}); const e = this._responsiveListeners, n = this.platform, i = (a, u) => { n.addEventListener(this, a, u), e[a] = u }, r = (a, u) => { e[a] && (n.removeEventListener(this, a, u), delete e[a]) }, o = (a, u) => { this.canvas && this.resize(a, u) }; let s; const l = () => { r("attach", l), this.attached = !0, this.resize(), i("resize", o), i("detach", s) }; s = () => { this.attached = !1, r("resize", o), this._stop(), this._resize(0, 0), i("attach", l) }, n.isAttached(this.canvas) ? l() : s() } unbindEvents() { $(this._listeners, (e, n) => { this.platform.removeEventListener(this, n, e) }), this._listeners = {}, $(this._responsiveListeners, (e, n) => { this.platform.removeEventListener(this, n, e) }), this._responsiveListeners = void 0 } updateHoverStyle(e, n, i) { const r = i ? "set" : "remove"; let o, s, l, a; for (n === "dataset" && (o = this.getDatasetMeta(e[0].datasetIndex), o.controller["_" + r + "DatasetHoverStyle"]()), l = 0, a = e.length; l < a; ++l) { s = e[l]; const u = s && this.getDatasetMeta(s.datasetIndex).controller; u && u[r + "HoverStyle"](s.element, s.datasetIndex, s.index) } } getActiveElements() { return this._active || [] } setActiveElements(e) { const n = this._active || [], i = e.map(({ datasetIndex: o, index: s }) => { const l = this.getDatasetMeta(o); if (!l) throw new Error("No dataset found at index " + o); return { datasetIndex: o, element: l.data[s], index: s } }); !Go(i, n) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, n)) } notifyPlugins(e, n, i) { return this._plugins.notify(this, e, n, i) } isPluginEnabled(e) { return this._plugins._cache.filter(n => n.plugin.id === e).length === 1 } _updateHoverStyles(e, n, i) { const r = this.options.hover, o = (a, u) => a.filter(d => !u.some(f => d.datasetIndex === f.datasetIndex && d.index === f.index)), s = o(n, e), l = i ? e : o(e, n); s.length && this.updateHoverStyle(s, r.mode, !1), l.length && r.mode && this.updateHoverStyle(l, r.mode, !0) } _eventHandler(e, n) { const i = { event: e, replay: n, cancelable: !0, inChartArea: this.isPointInArea(e) }, r = s => (s.options.events || this.options.events).includes(e.native.type); if (this.notifyPlugins("beforeEvent", i, r) === !1) return; const o = this._handleEvent(e, n, i.inChartArea); return i.cancelable = !1, this.notifyPlugins("afterEvent", i, r), (o || i.changed) && this.render(), this } _handleEvent(e, n, i) { const { _active: r = [], options: o } = this, s = n, l = this._getActiveElements(e, r, i, s), a = jv(e), u = G1(e, this._lastEvent, i, a); i && (this._lastEvent = null, K(o.onHover, [e, l, this], this), a && K(o.onClick, [e, l, this], this)); const d = !Go(l, r); return (d || n) && (this._active = l, this._updateHoverStyles(l, r, n)), this._lastEvent = u, d } _getActiveElements(e, n, i, r) { if (e.type === "mouseout") return []; if (!i) return n; const o = this.options.hover; return this.getElementsAtEventForMode(e, o.mode, o, r) } } z(Bt, "defaults", se), z(Bt, "instances", Eo), z(Bt, "overrides", Rn), z(Bt, "registry", vt), z(Bt, "version", X1), z(Bt, "getChart", Nd); function zd() { return $(Bt.instances, t => t._plugins.invalidate()) } function q1(t, e, n) { const { startAngle: i, pixelMargin: r, x: o, y: s, outerRadius: l, innerRadius: a } = e; let u = r / l; t.beginPath(), t.arc(o, s, l, i - u, n + u), a > r ? (u = r / a, t.arc(o, s, a, n + u, i - u, !0)) : t.arc(o, s, r, n + ue, i - ue), t.closePath(), t.clip() } function J1(t) { return Mu(t, ["outerStart", "outerEnd", "innerStart", "innerEnd"]) } function ex(t, e, n, i) { const r = J1(t.options.borderRadius), o = (n - e) / 2, s = Math.min(o, i * e / 2), l = a => { const u = (n - Math.min(o, a)) * i / 2; return tt(a, 0, Math.min(o, u)) }; return { outerStart: l(r.outerStart), outerEnd: l(r.outerEnd), innerStart: tt(r.innerStart, 0, s), innerEnd: tt(r.innerEnd, 0, s) } } function Fn(t, e, n, i) { return { x: n + t * Math.cos(e), y: i + t * Math.sin(e) } } function ls(t, e, n, i, r, o) { const { x: s, y: l, startAngle: a, pixelMargin: u, innerRadius: d } = e, f = Math.max(e.outerRadius + i + n - u, 0), c = d > 0 ? d + i + n + u : 0; let h = 0; const g = r - a; if (i) { const D = d > 0 ? d - i : 0, F = f > 0 ? f - i : 0, Y = (D + F) / 2, R = Y !== 0 ? g * Y / (Y + i) : g; h = (g - R) / 2 } const v = Math.max(.001, g * f - n / we) / f, _ = (g - v) / 2, m = a + _ + h, p = r - _ - h, { outerStart: y, outerEnd: w, innerStart: S, innerEnd: x } = ex(e, c, f, p - m), k = f - y, b = f - w, C = m + y / k, P = p - w / b, M = c + S, T = c + x, L = m + S / M, I = p - x / T; if (t.beginPath(), o) { const D = (C + P) / 2; if (t.arc(s, l, f, C, D), t.arc(s, l, f, D, P), w > 0) { const j = Fn(b, P, s, l); t.arc(j.x, j.y, w, P, p + ue) } const F = Fn(T, p, s, l); if (t.lineTo(F.x, F.y), x > 0) { const j = Fn(T, I, s, l); t.arc(j.x, j.y, x, p + ue, I + Math.PI) } const Y = (p - x / c + (m + S / c)) / 2; if (t.arc(s, l, c, p - x / c, Y, !0), t.arc(s, l, c, Y, m + S / c, !0), S > 0) { const j = Fn(M, L, s, l); t.arc(j.x, j.y, S, L + Math.PI, m - ue) } const R = Fn(k, m, s, l); if (t.lineTo(R.x, R.y), y > 0) { const j = Fn(k, C, s, l); t.arc(j.x, j.y, y, m - ue, C) } } else { t.moveTo(s, l); const D = Math.cos(C) * f + s, F = Math.sin(C) * f + l; t.lineTo(D, F); const Y = Math.cos(P) * f + s, R = Math.sin(P) * f + l; t.lineTo(Y, R) } t.closePath() } function tx(t, e, n, i, r) { const { fullCircles: o, startAngle: s, circumference: l } = e; let a = e.endAngle; if (o) { ls(t, e, n, i, a, r); for (let u = 0; u < o; ++u)t.fill(); isNaN(l) || (a = s + (l % xe || xe)) } return ls(t, e, n, i, a, r), t.fill(), a } function nx(t, e, n, i, r) { const { fullCircles: o, startAngle: s, circumference: l, options: a } = e, { borderWidth: u, borderJoinStyle: d, borderDash: f, borderDashOffset: c } = a, h = a.borderAlign === "inner"; if (!u) return; t.setLineDash(f || []), t.lineDashOffset = c, h ? (t.lineWidth = u * 2, t.lineJoin = d || "round") : (t.lineWidth = u, t.lineJoin = d || "bevel"); let g = e.endAngle; if (o) { ls(t, e, n, i, g, r); for (let v = 0; v < o; ++v)t.stroke(); isNaN(l) || (g = s + (l % xe || xe)) } h && q1(t, e, g), o || (ls(t, e, n, i, g, r), t.stroke()) } class Wi extends An { constructor(n) { super(); z(this, "circumference"); z(this, "endAngle"); z(this, "fullCircles"); z(this, "innerRadius"); z(this, "outerRadius"); z(this, "pixelMargin"); z(this, "startAngle"); this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, n && Object.assign(this, n) } inRange(n, i, r) { const o = this.getProps(["x", "y"], r), { angle: s, distance: l } = Lp(o, { x: n, y: i }), { startAngle: a, endAngle: u, innerRadius: d, outerRadius: f, circumference: c } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], r), h = (this.options.spacing + this.options.borderWidth) / 2, v = U(c, u - a) >= xe || Dp(s, a, u), _ = Bi(l, d + h, f + h); return v && _ } getCenterPoint(n) { const { x: i, y: r, startAngle: o, endAngle: s, innerRadius: l, outerRadius: a } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], n), { offset: u, spacing: d } = this.options, f = (o + s) / 2, c = (l + a + d + u) / 2; return { x: i + Math.cos(f) * c, y: r + Math.sin(f) * c } } tooltipPosition(n) { return this.getCenterPoint(n) } draw(n) { const { options: i, circumference: r } = this, o = (i.offset || 0) / 4, s = (i.spacing || 0) / 2, l = i.circular; if (this.pixelMargin = i.borderAlign === "inner" ? .33 : 0, this.fullCircles = r > xe ? Math.floor(r / xe) : 0, r === 0 || this.innerRadius < 0 || this.outerRadius < 0) return; n.save(); const a = (this.startAngle + this.endAngle) / 2; n.translate(Math.cos(a) * o, Math.sin(a) * o); const u = 1 - Math.sin(Math.min(we, r || 0)), d = o * u; n.fillStyle = i.backgroundColor, n.strokeStyle = i.borderColor, tx(n, this, d, s, l), nx(n, this, d, s, l), n.restore() } } z(Wi, "id", "arc"), z(Wi, "defaults", { borderAlign: "center", borderColor: "#fff", borderDash: [], borderDashOffset: 0, borderJoinStyle: void 0, borderRadius: 0, borderWidth: 2, offset: 0, spacing: 0, angle: void 0, circular: !0 }), z(Wi, "defaultRoutes", { backgroundColor: "backgroundColor" }), z(Wi, "descriptors", { _scriptable: !0, _indexable: n => n !== "borderDash" }); const Id = (t, e) => { let { boxHeight: n = e, boxWidth: i = e } = t; return t.usePointStyle && (n = Math.min(n, e), i = t.pointStyleWidth || Math.min(i, e)), { boxWidth: i, boxHeight: n, itemHeight: Math.max(e, n) } }, ix = (t, e) => t !== null && e !== null && t.datasetIndex === e.datasetIndex && t.index === e.index; class Fd extends An { constructor(e) { super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(e, n, i) { this.maxWidth = e, this.maxHeight = n, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit() } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height) } buildLabels() { const e = this.options.labels || {}; let n = K(e.generateLabels, [this.chart], this) || []; e.filter && (n = n.filter(i => e.filter(i, this.chart.data))), e.sort && (n = n.sort((i, r) => e.sort(i, r, this.chart.data))), this.options.reverse && n.reverse(), this.legendItems = n } fit() { const { options: e, ctx: n } = this; if (!e.display) { this.width = this.height = 0; return } const i = e.labels, r = ve(i.font), o = r.size, s = this._computeTitleHeight(), { boxWidth: l, itemHeight: a } = Id(i, o); let u, d; n.font = r.string, this.isHorizontal() ? (u = this.maxWidth, d = this._fitRows(s, o, l, a) + 10) : (d = this.maxHeight, u = this._fitCols(s, r, l, a) + 10), this.width = Math.min(u, e.maxWidth || this.maxWidth), this.height = Math.min(d, e.maxHeight || this.maxHeight) } _fitRows(e, n, i, r) { const { ctx: o, maxWidth: s, options: { labels: { padding: l } } } = this, a = this.legendHitBoxes = [], u = this.lineWidths = [0], d = r + l; let f = e; o.textAlign = "left", o.textBaseline = "middle"; let c = -1, h = -d; return this.legendItems.forEach((g, v) => { const _ = i + n / 2 + o.measureText(g.text).width; (v === 0 || u[u.length - 1] + _ + 2 * l > s) && (f += d, u[u.length - (v > 0 ? 0 : 1)] = 0, h += d, c++), a[v] = { left: 0, top: h, row: c, width: _, height: r }, u[u.length - 1] += _ + l }), f } _fitCols(e, n, i, r) { const { ctx: o, maxHeight: s, options: { labels: { padding: l } } } = this, a = this.legendHitBoxes = [], u = this.columnSizes = [], d = s - e; let f = l, c = 0, h = 0, g = 0, v = 0; return this.legendItems.forEach((_, m) => { const { itemWidth: p, itemHeight: y } = rx(i, n, o, _, r); m > 0 && h + y + 2 * l > d && (f += c + l, u.push({ width: c, height: h }), g += c + l, v++, c = h = 0), a[m] = { left: g, top: h, col: v, width: p, height: y }, c = Math.max(c, p), h += y + l }), f += c, u.push({ width: c, height: h }), f } adjustHitBoxes() { if (!this.options.display) return; const e = this._computeTitleHeight(), { legendHitBoxes: n, options: { align: i, labels: { padding: r }, rtl: o } } = this, s = li(o, this.left, this.width); if (this.isHorizontal()) { let l = 0, a = We(i, this.left + r, this.right - this.lineWidths[l]); for (const u of n) l !== u.row && (l = u.row, a = We(i, this.left + r, this.right - this.lineWidths[l])), u.top += this.top + e + r, u.left = s.leftForLtr(s.x(a), u.width), a += u.width + r } else { let l = 0, a = We(i, this.top + e + r, this.bottom - this.columnSizes[l].height); for (const u of n) u.col !== l && (l = u.col, a = We(i, this.top + e + r, this.bottom - this.columnSizes[l].height)), u.top = a, u.left += this.left + r, u.left = s.leftForLtr(s.x(u.left), u.width), a += u.height + r } } isHorizontal() { return this.options.position === "top" || this.options.position === "bottom" } draw() { if (this.options.display) { const e = this.ctx; Pu(e, this), this._draw(), Ou(e) } } _draw() { const { options: e, columnSizes: n, lineWidths: i, ctx: r } = this, { align: o, labels: s } = e, l = se.color, a = li(e.rtl, this.left, this.width), u = ve(s.font), { padding: d } = s, f = u.size, c = f / 2; let h; this.drawTitle(), r.textAlign = a.textAlign("left"), r.textBaseline = "middle", r.lineWidth = .5, r.font = u.string; const { boxWidth: g, boxHeight: v, itemHeight: _ } = Id(s, f), m = function (x, k, b) { if (isNaN(g) || g <= 0 || isNaN(v) || v < 0) return; r.save(); const C = U(b.lineWidth, 1); if (r.fillStyle = U(b.fillStyle, l), r.lineCap = U(b.lineCap, "butt"), r.lineDashOffset = U(b.lineDashOffset, 0), r.lineJoin = U(b.lineJoin, "miter"), r.lineWidth = C, r.strokeStyle = U(b.strokeStyle, l), r.setLineDash(U(b.lineDash, [])), s.usePointStyle) { const P = { radius: v * Math.SQRT2 / 2, pointStyle: b.pointStyle, rotation: b.rotation, borderWidth: C }, M = a.xPlus(x, g / 2), T = k + c; Wp(r, P, M, T, s.pointStyleWidth && g) } else { const P = k + Math.max((f - v) / 2, 0), M = a.leftForLtr(x, g), T = si(b.borderRadius); r.beginPath(), Object.values(T).some(L => L !== 0) ? rs(r, { x: M, y: P, w: g, h: v, radius: T }) : r.rect(M, P, g, v), r.fill(), C !== 0 && r.stroke() } r.restore() }, p = function (x, k, b) { gi(r, b.text, x, k + _ / 2, u, { strikethrough: b.hidden, textAlign: a.textAlign(b.textAlign) }) }, y = this.isHorizontal(), w = this._computeTitleHeight(); y ? h = { x: We(o, this.left + d, this.right - i[0]), y: this.top + d + w, line: 0 } : h = { x: this.left + d, y: We(o, this.top + w + d, this.bottom - n[0].height), line: 0 }, Qp(this.ctx, e.textDirection); const S = _ + d; this.legendItems.forEach((x, k) => { r.strokeStyle = x.fontColor, r.fillStyle = x.fontColor; const b = r.measureText(x.text).width, C = a.textAlign(x.textAlign || (x.textAlign = s.textAlign)), P = g + c + b; let M = h.x, T = h.y; a.setWidth(this.width), y ? k > 0 && M + P + d > this.right && (T = h.y += S, h.line++, M = h.x = We(o, this.left + d, this.right - i[h.line])) : k > 0 && T + S > this.bottom && (M = h.x = M + n[h.line].width + d, h.line++, T = h.y = We(o, this.top + w + d, this.bottom - n[h.line].height)); const L = a.x(M); if (m(L, T, x), M = $v(C, M + g + c, y ? M + P : this.right, e.rtl), p(a.x(M), T, x), y) h.x += P + d; else if (typeof x.text != "string") { const I = u.lineHeight; h.y += lg(x, I) } else h.y += S }), Kp(this.ctx, e.textDirection) } drawTitle() { const e = this.options, n = e.title, i = ve(n.font), r = Te(n.padding); if (!n.display) return; const o = li(e.rtl, this.left, this.width), s = this.ctx, l = n.position, a = i.size / 2, u = r.top + a; let d, f = this.left, c = this.width; if (this.isHorizontal()) c = Math.max(...this.lineWidths), d = this.top + u, f = We(e.align, f, this.right - c); else { const g = this.columnSizes.reduce((v, _) => Math.max(v, _.height), 0); d = u + We(e.align, this.top, this.bottom - g - e.labels.padding - this._computeTitleHeight()) } const h = We(l, f, f + c); s.textAlign = o.textAlign(Fp(l)), s.textBaseline = "middle", s.strokeStyle = n.color, s.fillStyle = n.color, s.font = i.string, gi(s, n.text, h, d, i) } _computeTitleHeight() { const e = this.options.title, n = ve(e.font), i = Te(e.padding); return e.display ? n.lineHeight + i.height : 0 } _getLegendItemAt(e, n) { let i, r, o; if (Bi(e, this.left, this.right) && Bi(n, this.top, this.bottom)) { for (o = this.legendHitBoxes, i = 0; i < o.length; ++i)if (r = o[i], Bi(e, r.left, r.left + r.width) && Bi(n, r.top, r.top + r.height)) return this.legendItems[i] } return null } handleEvent(e) { const n = this.options; if (!lx(e.type, n)) return; const i = this._getLegendItemAt(e.x, e.y); if (e.type === "mousemove" || e.type === "mouseout") { const r = this._hoveredItem, o = ix(r, i); r && !o && K(n.onLeave, [e, r, this], this), this._hoveredItem = i, i && !o && K(n.onHover, [e, i, this], this) } else i && K(n.onClick, [e, i, this], this) } } function rx(t, e, n, i, r) { const o = ox(i, t, e, n), s = sx(r, i, e.lineHeight); return { itemWidth: o, itemHeight: s } } function ox(t, e, n, i) { let r = t.text; return r && typeof r != "string" && (r = r.reduce((o, s) => o.length > s.length ? o : s)), e + n.size / 2 + i.measureText(r).width } function sx(t, e, n) { let i = t; return typeof e.text != "string" && (i = lg(e, n)), i } function lg(t, e) { const n = t.text ? t.text.length + .5 : 0; return e * n } function lx(t, e) { return !!((t === "mousemove" || t === "mouseout") && (e.onHover || e.onLeave) || e.onClick && (t === "click" || t === "mouseup")) } var ax = { id: "legend", _element: Fd, start(t, e, n) { const i = t.legend = new Fd({ ctx: t.ctx, options: n, chart: t }); Qt.configure(t, i, n), Qt.addBox(t, i) }, stop(t) { Qt.removeBox(t, t.legend), delete t.legend }, beforeUpdate(t, e, n) { const i = t.legend; Qt.configure(t, i, n), i.options = n }, afterUpdate(t) { const e = t.legend; e.buildLabels(), e.adjustHitBoxes() }, afterEvent(t, e) { e.replay || t.legend.handleEvent(e.event) }, defaults: { display: !0, position: "top", align: "center", fullSize: !0, reverse: !1, weight: 1e3, onClick(t, e, n) { const i = e.datasetIndex, r = n.chart; r.isDatasetVisible(i) ? (r.hide(i), e.hidden = !0) : (r.show(i), e.hidden = !1) }, onHover: null, onLeave: null, labels: { color: t => t.chart.options.color, boxWidth: 40, padding: 10, generateLabels(t) { const e = t.data.datasets, { labels: { usePointStyle: n, pointStyle: i, textAlign: r, color: o, useBorderRadius: s, borderRadius: l } } = t.legend.options; return t._getSortedDatasetMetas().map(a => { const u = a.controller.getStyle(n ? 0 : void 0), d = Te(u.borderWidth); return { text: e[a.index].label, fillStyle: u.backgroundColor, fontColor: o, hidden: !a.visible, lineCap: u.borderCapStyle, lineDash: u.borderDash, lineDashOffset: u.borderDashOffset, lineJoin: u.borderJoinStyle, lineWidth: (d.width + d.height) / 4, strokeStyle: u.borderColor, pointStyle: i || u.pointStyle, rotation: u.rotation, textAlign: r || u.textAlign, borderRadius: s && (l || u.borderRadius), datasetIndex: a.index } }, this) } }, title: { color: t => t.chart.options.color, display: !1, position: "center", text: "" } }, descriptors: { _scriptable: t => !t.startsWith("on"), labels: { _scriptable: t => !["generateLabels", "filter", "sort"].includes(t) } } }; const Vi = { average(t) { if (!t.length) return !1; let e, n, i = 0, r = 0, o = 0; for (e = 0, n = t.length; e < n; ++e) { const s = t[e].element; if (s && s.hasValue()) { const l = s.tooltipPosition(); i += l.x, r += l.y, ++o } } return { x: i / o, y: r / o } }, nearest(t, e) { if (!t.length) return !1; let n = e.x, i = e.y, r = Number.POSITIVE_INFINITY, o, s, l; for (o = 0, s = t.length; o < s; ++o) { const a = t[o].element; if (a && a.hasValue()) { const u = a.getCenterPoint(), d = zv(e, u); d < r && (r = d, l = a) } } if (l) { const a = l.tooltipPosition(); n = a.x, i = a.y } return { x: n, y: i } } }; function gt(t, e) { return e && (oe(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t } function Et(t) {
  return (typeof t == "string" || t instanceof String) && t.indexOf(`
`) > -1 ? t.split(`
`) : t
} function ux(t, e) { const { element: n, datasetIndex: i, index: r } = e, o = t.getDatasetMeta(i).controller, { label: s, value: l } = o.getLabelAndValue(r); return { chart: t, label: s, parsed: o.getParsed(r), raw: t.data.datasets[i].data[r], formattedValue: l, dataset: o.getDataset(), dataIndex: r, datasetIndex: i, element: n } } function Bd(t, e) { const n = t.chart.ctx, { body: i, footer: r, title: o } = t, { boxWidth: s, boxHeight: l } = e, a = ve(e.bodyFont), u = ve(e.titleFont), d = ve(e.footerFont), f = o.length, c = r.length, h = i.length, g = Te(e.padding); let v = g.height, _ = 0, m = i.reduce((w, S) => w + S.before.length + S.lines.length + S.after.length, 0); if (m += t.beforeBody.length + t.afterBody.length, f && (v += f * u.lineHeight + (f - 1) * e.titleSpacing + e.titleMarginBottom), m) { const w = e.displayColors ? Math.max(l, a.lineHeight) : a.lineHeight; v += h * w + (m - h) * a.lineHeight + (m - 1) * e.bodySpacing } c && (v += e.footerMarginTop + c * d.lineHeight + (c - 1) * e.footerSpacing); let p = 0; const y = function (w) { _ = Math.max(_, n.measureText(w).width + p) }; return n.save(), n.font = u.string, $(t.title, y), n.font = a.string, $(t.beforeBody.concat(t.afterBody), y), p = e.displayColors ? s + 2 + e.boxPadding : 0, $(i, w => { $(w.before, y), $(w.lines, y), $(w.after, y) }), p = 0, n.font = d.string, $(t.footer, y), n.restore(), _ += g.width, { width: _, height: v } } function cx(t, e) { const { y: n, height: i } = e; return n < i / 2 ? "top" : n > t.height - i / 2 ? "bottom" : "center" } function dx(t, e, n, i) { const { x: r, width: o } = i, s = n.caretSize + n.caretPadding; if (t === "left" && r + o + s > e.width || t === "right" && r - o - s < 0) return !0 } function fx(t, e, n, i) { const { x: r, width: o } = n, { width: s, chartArea: { left: l, right: a } } = t; let u = "center"; return i === "center" ? u = r <= (l + a) / 2 ? "left" : "right" : r <= o / 2 ? u = "left" : r >= s - o / 2 && (u = "right"), dx(u, t, e, n) && (u = "center"), u } function Hd(t, e, n) { const i = n.yAlign || e.yAlign || cx(t, n); return { xAlign: n.xAlign || e.xAlign || fx(t, e, n, i), yAlign: i } } function hx(t, e) { let { x: n, width: i } = t; return e === "right" ? n -= i : e === "center" && (n -= i / 2), n } function px(t, e, n) { let { y: i, height: r } = t; return e === "top" ? i += n : e === "bottom" ? i -= r + n : i -= r / 2, i } function Wd(t, e, n, i) { const { caretSize: r, caretPadding: o, cornerRadius: s } = t, { xAlign: l, yAlign: a } = n, u = r + o, { topLeft: d, topRight: f, bottomLeft: c, bottomRight: h } = si(s); let g = hx(e, l); const v = px(e, a, u); return a === "center" ? l === "left" ? g += u : l === "right" && (g -= u) : l === "left" ? g -= Math.max(d, c) + r : l === "right" && (g += Math.max(f, h) + r), { x: tt(g, 0, i.width - e.width), y: tt(v, 0, i.height - e.height) } } function so(t, e, n) { const i = Te(n.padding); return e === "center" ? t.x + t.width / 2 : e === "right" ? t.x + t.width - i.right : t.x + i.left } function Vd(t) { return gt([], Et(t)) } function gx(t, e, n) { return Nn(t, { tooltip: e, tooltipItems: n, type: "tooltip" }) } function $d(t, e) { const n = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks; return n ? t.override(n) : t } const ag = { beforeTitle: bt, title(t) { if (t.length > 0) { const e = t[0], n = e.chart.data.labels, i = n ? n.length : 0; if (this && this.options && this.options.mode === "dataset") return e.dataset.label || ""; if (e.label) return e.label; if (i > 0 && e.dataIndex < i) return n[e.dataIndex] } return "" }, afterTitle: bt, beforeBody: bt, beforeLabel: bt, label(t) { if (this && this.options && this.options.mode === "dataset") return t.label + ": " + t.formattedValue || t.formattedValue; let e = t.dataset.label || ""; e && (e += ": "); const n = t.formattedValue; return te(n) || (e += n), e }, labelColor(t) { const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { borderColor: n.borderColor, backgroundColor: n.backgroundColor, borderWidth: n.borderWidth, borderDash: n.borderDash, borderDashOffset: n.borderDashOffset, borderRadius: 0 } }, labelTextColor() { return this.options.bodyColor }, labelPointStyle(t) { const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { pointStyle: n.pointStyle, rotation: n.rotation } }, afterLabel: bt, afterBody: bt, beforeFooter: bt, footer: bt, afterFooter: bt }; function je(t, e, n, i) { const r = t[e].call(n, i); return typeof r > "u" ? ag[e].call(n, i) : r } class _a extends An { constructor(e) { super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0 } initialize(e) { this.options = e, this._cachedAnimations = void 0, this.$context = void 0 } _resolveAnimations() { const e = this._cachedAnimations; if (e) return e; const n = this.chart, i = this.options.setContext(this.getContext()), r = i.enabled && n.options.animation && i.animations, o = new Gp(this.chart, r); return r._cacheable && (this._cachedAnimations = Object.freeze(o)), o } getContext() { return this.$context || (this.$context = gx(this.chart.getContext(), this, this._tooltipItems)) } getTitle(e, n) { const { callbacks: i } = n, r = je(i, "beforeTitle", this, e), o = je(i, "title", this, e), s = je(i, "afterTitle", this, e); let l = []; return l = gt(l, Et(r)), l = gt(l, Et(o)), l = gt(l, Et(s)), l } getBeforeBody(e, n) { return Vd(je(n.callbacks, "beforeBody", this, e)) } getBody(e, n) { const { callbacks: i } = n, r = []; return $(e, o => { const s = { before: [], lines: [], after: [] }, l = $d(i, o); gt(s.before, Et(je(l, "beforeLabel", this, o))), gt(s.lines, je(l, "label", this, o)), gt(s.after, Et(je(l, "afterLabel", this, o))), r.push(s) }), r } getAfterBody(e, n) { return Vd(je(n.callbacks, "afterBody", this, e)) } getFooter(e, n) { const { callbacks: i } = n, r = je(i, "beforeFooter", this, e), o = je(i, "footer", this, e), s = je(i, "afterFooter", this, e); let l = []; return l = gt(l, Et(r)), l = gt(l, Et(o)), l = gt(l, Et(s)), l } _createItems(e) { const n = this._active, i = this.chart.data, r = [], o = [], s = []; let l = [], a, u; for (a = 0, u = n.length; a < u; ++a)l.push(ux(this.chart, n[a])); return e.filter && (l = l.filter((d, f, c) => e.filter(d, f, c, i))), e.itemSort && (l = l.sort((d, f) => e.itemSort(d, f, i))), $(l, d => { const f = $d(e.callbacks, d); r.push(je(f, "labelColor", this, d)), o.push(je(f, "labelPointStyle", this, d)), s.push(je(f, "labelTextColor", this, d)) }), this.labelColors = r, this.labelPointStyles = o, this.labelTextColors = s, this.dataPoints = l, l } update(e, n) { const i = this.options.setContext(this.getContext()), r = this._active; let o, s = []; if (!r.length) this.opacity !== 0 && (o = { opacity: 0 }); else { const l = Vi[i.position].call(this, r, this._eventPosition); s = this._createItems(i), this.title = this.getTitle(s, i), this.beforeBody = this.getBeforeBody(s, i), this.body = this.getBody(s, i), this.afterBody = this.getAfterBody(s, i), this.footer = this.getFooter(s, i); const a = this._size = Bd(this, i), u = Object.assign({}, l, a), d = Hd(this.chart, i, u), f = Wd(i, u, d, this.chart); this.xAlign = d.xAlign, this.yAlign = d.yAlign, o = { opacity: 1, x: f.x, y: f.y, width: a.width, height: a.height, caretX: l.x, caretY: l.y } } this._tooltipItems = s, this.$context = void 0, o && this._resolveAnimations().update(this, o), e && i.external && i.external.call(this, { chart: this.chart, tooltip: this, replay: n }) } drawCaret(e, n, i, r) { const o = this.getCaretPosition(e, i, r); n.lineTo(o.x1, o.y1), n.lineTo(o.x2, o.y2), n.lineTo(o.x3, o.y3) } getCaretPosition(e, n, i) { const { xAlign: r, yAlign: o } = this, { caretSize: s, cornerRadius: l } = i, { topLeft: a, topRight: u, bottomLeft: d, bottomRight: f } = si(l), { x: c, y: h } = e, { width: g, height: v } = n; let _, m, p, y, w, S; return o === "center" ? (w = h + v / 2, r === "left" ? (_ = c, m = _ - s, y = w + s, S = w - s) : (_ = c + g, m = _ + s, y = w - s, S = w + s), p = _) : (r === "left" ? m = c + Math.max(a, d) + s : r === "right" ? m = c + g - Math.max(u, f) - s : m = this.caretX, o === "top" ? (y = h, w = y - s, _ = m - s, p = m + s) : (y = h + v, w = y + s, _ = m + s, p = m - s), S = y), { x1: _, x2: m, x3: p, y1: y, y2: w, y3: S } } drawTitle(e, n, i) { const r = this.title, o = r.length; let s, l, a; if (o) { const u = li(i.rtl, this.x, this.width); for (e.x = so(this, i.titleAlign, i), n.textAlign = u.textAlign(i.titleAlign), n.textBaseline = "middle", s = ve(i.titleFont), l = i.titleSpacing, n.fillStyle = i.titleColor, n.font = s.string, a = 0; a < o; ++a)n.fillText(r[a], u.x(e.x), e.y + s.lineHeight / 2), e.y += s.lineHeight + l, a + 1 === o && (e.y += i.titleMarginBottom - l) } } _drawColorBox(e, n, i, r, o) { const s = this.labelColors[i], l = this.labelPointStyles[i], { boxHeight: a, boxWidth: u } = o, d = ve(o.bodyFont), f = so(this, "left", o), c = r.x(f), h = a < d.lineHeight ? (d.lineHeight - a) / 2 : 0, g = n.y + h; if (o.usePointStyle) { const v = { radius: Math.min(u, a) / 2, pointStyle: l.pointStyle, rotation: l.rotation, borderWidth: 1 }, _ = r.leftForLtr(c, u) + u / 2, m = g + a / 2; e.strokeStyle = o.multiKeyBackground, e.fillStyle = o.multiKeyBackground, ld(e, v, _, m), e.strokeStyle = s.borderColor, e.fillStyle = s.backgroundColor, ld(e, v, _, m) } else { e.lineWidth = W(s.borderWidth) ? Math.max(...Object.values(s.borderWidth)) : s.borderWidth || 1, e.strokeStyle = s.borderColor, e.setLineDash(s.borderDash || []), e.lineDashOffset = s.borderDashOffset || 0; const v = r.leftForLtr(c, u), _ = r.leftForLtr(r.xPlus(c, 1), u - 2), m = si(s.borderRadius); Object.values(m).some(p => p !== 0) ? (e.beginPath(), e.fillStyle = o.multiKeyBackground, rs(e, { x: v, y: g, w: u, h: a, radius: m }), e.fill(), e.stroke(), e.fillStyle = s.backgroundColor, e.beginPath(), rs(e, { x: _, y: g + 1, w: u - 2, h: a - 2, radius: m }), e.fill()) : (e.fillStyle = o.multiKeyBackground, e.fillRect(v, g, u, a), e.strokeRect(v, g, u, a), e.fillStyle = s.backgroundColor, e.fillRect(_, g + 1, u - 2, a - 2)) } e.fillStyle = this.labelTextColors[i] } drawBody(e, n, i) { const { body: r } = this, { bodySpacing: o, bodyAlign: s, displayColors: l, boxHeight: a, boxWidth: u, boxPadding: d } = i, f = ve(i.bodyFont); let c = f.lineHeight, h = 0; const g = li(i.rtl, this.x, this.width), v = function (b) { n.fillText(b, g.x(e.x + h), e.y + c / 2), e.y += c + o }, _ = g.textAlign(s); let m, p, y, w, S, x, k; for (n.textAlign = s, n.textBaseline = "middle", n.font = f.string, e.x = so(this, _, i), n.fillStyle = i.bodyColor, $(this.beforeBody, v), h = l && _ !== "right" ? s === "center" ? u / 2 + d : u + 2 + d : 0, w = 0, x = r.length; w < x; ++w) { for (m = r[w], p = this.labelTextColors[w], n.fillStyle = p, $(m.before, v), y = m.lines, l && y.length && (this._drawColorBox(n, e, w, g, i), c = Math.max(f.lineHeight, a)), S = 0, k = y.length; S < k; ++S)v(y[S]), c = f.lineHeight; $(m.after, v) } h = 0, c = f.lineHeight, $(this.afterBody, v), e.y -= o } drawFooter(e, n, i) { const r = this.footer, o = r.length; let s, l; if (o) { const a = li(i.rtl, this.x, this.width); for (e.x = so(this, i.footerAlign, i), e.y += i.footerMarginTop, n.textAlign = a.textAlign(i.footerAlign), n.textBaseline = "middle", s = ve(i.footerFont), n.fillStyle = i.footerColor, n.font = s.string, l = 0; l < o; ++l)n.fillText(r[l], a.x(e.x), e.y + s.lineHeight / 2), e.y += s.lineHeight + i.footerSpacing } } drawBackground(e, n, i, r) { const { xAlign: o, yAlign: s } = this, { x: l, y: a } = e, { width: u, height: d } = i, { topLeft: f, topRight: c, bottomLeft: h, bottomRight: g } = si(r.cornerRadius); n.fillStyle = r.backgroundColor, n.strokeStyle = r.borderColor, n.lineWidth = r.borderWidth, n.beginPath(), n.moveTo(l + f, a), s === "top" && this.drawCaret(e, n, i, r), n.lineTo(l + u - c, a), n.quadraticCurveTo(l + u, a, l + u, a + c), s === "center" && o === "right" && this.drawCaret(e, n, i, r), n.lineTo(l + u, a + d - g), n.quadraticCurveTo(l + u, a + d, l + u - g, a + d), s === "bottom" && this.drawCaret(e, n, i, r), n.lineTo(l + h, a + d), n.quadraticCurveTo(l, a + d, l, a + d - h), s === "center" && o === "left" && this.drawCaret(e, n, i, r), n.lineTo(l, a + f), n.quadraticCurveTo(l, a, l + f, a), n.closePath(), n.fill(), r.borderWidth > 0 && n.stroke() } _updateAnimationTarget(e) { const n = this.chart, i = this.$animations, r = i && i.x, o = i && i.y; if (r || o) { const s = Vi[e.position].call(this, this._active, this._eventPosition); if (!s) return; const l = this._size = Bd(this, e), a = Object.assign({}, s, this._size), u = Hd(n, e, a), d = Wd(e, a, u, n); (r._to !== d.x || o._to !== d.y) && (this.xAlign = u.xAlign, this.yAlign = u.yAlign, this.width = l.width, this.height = l.height, this.caretX = s.x, this.caretY = s.y, this._resolveAnimations().update(this, d)) } } _willRender() { return !!this.opacity } draw(e) { const n = this.options.setContext(this.getContext()); let i = this.opacity; if (!i) return; this._updateAnimationTarget(n); const r = { width: this.width, height: this.height }, o = { x: this.x, y: this.y }; i = Math.abs(i) < .001 ? 0 : i; const s = Te(n.padding), l = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length; n.enabled && l && (e.save(), e.globalAlpha = i, this.drawBackground(o, e, r, n), Qp(e, n.textDirection), o.y += s.top, this.drawTitle(o, e, n), this.drawBody(o, e, n), this.drawFooter(o, e, n), Kp(e, n.textDirection), e.restore()) } getActiveElements() { return this._active || [] } setActiveElements(e, n) { const i = this._active, r = e.map(({ datasetIndex: l, index: a }) => { const u = this.chart.getDatasetMeta(l); if (!u) throw new Error("Cannot find a dataset at index " + l); return { datasetIndex: l, element: u.data[a], index: a } }), o = !Go(i, r), s = this._positionChanged(r, n); (o || s) && (this._active = r, this._eventPosition = n, this._ignoreReplayEvents = !0, this.update(!0)) } handleEvent(e, n, i = !0) { if (n && this._ignoreReplayEvents) return !1; this._ignoreReplayEvents = !1; const r = this.options, o = this._active || [], s = this._getActiveElements(e, o, n, i), l = this._positionChanged(s, e), a = n || !Go(s, o) || l; return a && (this._active = s, (r.enabled || r.external) && (this._eventPosition = { x: e.x, y: e.y }, this.update(!0, n))), a } _getActiveElements(e, n, i, r) { const o = this.options; if (e.type === "mouseout") return []; if (!r) return n; const s = this.chart.getElementsAtEventForMode(e, o.mode, o, i); return o.reverse && s.reverse(), s } _positionChanged(e, n) { const { caretX: i, caretY: r, options: o } = this, s = Vi[o.position].call(this, e, n); return s !== !1 && (i !== s.x || r !== s.y) } } z(_a, "positioners", Vi); var mx = { id: "tooltip", _element: _a, positioners: Vi, afterInit(t, e, n) { n && (t.tooltip = new _a({ chart: t, options: n })) }, beforeUpdate(t, e, n) { t.tooltip && t.tooltip.initialize(n) }, reset(t, e, n) { t.tooltip && t.tooltip.initialize(n) }, afterDraw(t) { const e = t.tooltip; if (e && e._willRender()) { const n = { tooltip: e }; if (t.notifyPlugins("beforeTooltipDraw", { ...n, cancelable: !0 }) === !1) return; e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", n) } }, afterEvent(t, e) { if (t.tooltip) { const n = e.replay; t.tooltip.handleEvent(e.event, n, e.inChartArea) && (e.changed = !0) } }, defaults: { enabled: !0, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bodyFont: {}, bodyAlign: "left", footerColor: "#fff", footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: "bold" }, footerAlign: "left", padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (t, e) => e.bodyFont.size, boxWidth: (t, e) => e.bodyFont.size, multiKeyBackground: "#fff", displayColors: !0, boxPadding: 0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, animation: { duration: 400, easing: "easeOutQuart" }, animations: { numbers: { type: "number", properties: ["x", "y", "width", "height", "caretX", "caretY"] }, opacity: { easing: "linear", duration: 200 } }, callbacks: ag }, defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" }, descriptors: { _scriptable: t => t !== "filter" && t !== "itemSort" && t !== "external", _indexable: !1, callbacks: { _scriptable: !1, _indexable: !1 }, animation: { _fallback: !1 }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] }; function vx(t, e) { const n = [], { bounds: r, step: o, min: s, max: l, precision: a, count: u, maxTicks: d, maxDigits: f, includeBounds: c } = t, h = o || 1, g = d - 1, { min: v, max: _ } = e, m = !te(s), p = !te(l), y = !te(u), w = (_ - v) / (f + 1); let S = Jc((_ - v) / g / h) * h, x, k, b, C; if (S < 1e-14 && !m && !p) return [{ value: v }, { value: _ }]; C = Math.ceil(_ / S) - Math.floor(v / S), C > g && (S = Jc(C * S / g / h) * h), te(a) || (x = Math.pow(10, a), S = Math.ceil(S * x) / x), r === "ticks" ? (k = Math.floor(v / S) * S, b = Math.ceil(_ / S) * S) : (k = v, b = _), m && p && o && Nv((l - s) / o, S / 1e3) ? (C = Math.round(Math.min((l - s) / S, d)), S = (l - s) / C, k = s, b = l) : y ? (k = m ? s : k, b = p ? l : b, C = u - 1, S = (b - k) / C) : (C = (b - k) / S, ko(C, Math.round(C), S / 1e3) ? C = Math.round(C) : C = Math.ceil(C)); const P = Math.max(ed(S), ed(k)); x = Math.pow(10, te(a) ? P : a), k = Math.round(k * x) / x, b = Math.round(b * x) / x; let M = 0; for (m && (c && k !== s ? (n.push({ value: s }), k < s && M++, ko(Math.round((k + M * S) * x) / x, s, Ud(s, w, t)) && M++) : k < s && M++); M < C; ++M) { const T = Math.round((k + M * S) * x) / x; if (p && T > l) break; n.push({ value: T }) } return p && c && b !== l ? n.length && ko(n[n.length - 1].value, l, Ud(l, w, t)) ? n[n.length - 1].value = l : n.push({ value: l }) : (!p || b === l) && n.push({ value: b }), n } function Ud(t, e, { horizontal: n, minRotation: i }) { const r = Yt(i), o = (n ? Math.sin(r) : Math.cos(r)) || .001, s = .75 * e * ("" + t).length; return Math.min(e / o, s) } class as extends _i { constructor(e) { super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0 } parse(e, n) { return te(e) || (typeof e == "number" || e instanceof Number) && !isFinite(+e) ? null : +e } handleTickRangeOptions() { const { beginAtZero: e } = this.options, { minDefined: n, maxDefined: i } = this.getUserBounds(); let { min: r, max: o } = this; const s = a => r = n ? r : a, l = a => o = i ? o : a; if (e) { const a = ts(r), u = ts(o); a < 0 && u < 0 ? l(0) : a > 0 && u > 0 && s(0) } if (r === o) { let a = o === 0 ? 1 : Math.abs(o * .05); l(o + a), e || s(r - a) } this.min = r, this.max = o } getTickLimit() { const e = this.options.ticks; let { maxTicksLimit: n, stepSize: i } = e, r; return i ? (r = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1, r > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${r} ticks. Limiting to 1000.`), r = 1e3)) : (r = this.computeTickLimit(), n = n || 11), n && (r = Math.min(n, r)), r } computeTickLimit() { return Number.POSITIVE_INFINITY } buildTicks() { const e = this.options, n = e.ticks; let i = this.getTickLimit(); i = Math.max(2, i); const r = { maxTicks: i, bounds: e.bounds, min: e.min, max: e.max, precision: n.precision, step: n.stepSize, count: n.count, maxDigits: this._maxDigits(), horizontal: this.isHorizontal(), minRotation: n.minRotation || 0, includeBounds: n.includeBounds !== !1 }, o = this._range || this, s = vx(r, o); return e.bounds === "ticks" && jp(s, this, "value"), e.reverse ? (s.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s } configure() { const e = this.ticks; let n = this.min, i = this.max; if (super.configure(), this.options.offset && e.length) { const r = (i - n) / Math.max(e.length - 1, 1) / 2; n -= r, i += r } this._startValue = n, this._endValue = i, this._valueRange = i - n } getLabelForValue(e) { return Cu(e, this.chart.options.locale, this.options.ticks.format) } } class Xd extends as { determineDataLimits() { const { min: e, max: n } = this.getMinMax(!0); this.min = he(e) ? e : 0, this.max = he(n) ? n : 1, this.handleTickRangeOptions() } computeTickLimit() { const e = this.isHorizontal(), n = e ? this.width : this.height, i = Yt(this.options.ticks.minRotation), r = (e ? Math.sin(i) : Math.cos(i)) || .001, o = this._resolveTickFontOptions(0); return Math.ceil(n / Math.min(40, o.lineHeight / r)) } getPixelForValue(e) { return e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange) } getValueForPixel(e) { return this._startValue + this.getDecimalForPixel(e) * this._valueRange } } z(Xd, "id", "linear"), z(Xd, "defaults", { ticks: { callback: Cs.formatters.numeric } }); const kr = t => Math.floor(Xt(t)), gn = (t, e) => Math.pow(10, kr(t) + e); function Yd(t) { return t / Math.pow(10, kr(t)) === 1 } function Qd(t, e, n) { const i = Math.pow(10, n), r = Math.floor(t / i); return Math.ceil(e / i) - r } function yx(t, e) { const n = e - t; let i = kr(n); for (; Qd(t, e, i) > 10;)i++; for (; Qd(t, e, i) < 10;)i--; return Math.min(i, kr(t)) } function xx(t, { min: e, max: n }) { e = Ve(t.min, e); const i = [], r = kr(e); let o = yx(e, n), s = o < 0 ? Math.pow(10, Math.abs(o)) : 1; const l = Math.pow(10, o), a = r > o ? Math.pow(10, r) : 0, u = Math.round((e - a) * s) / s, d = Math.floor((e - a) / l / 10) * l * 10; let f = Math.floor((u - d) / Math.pow(10, o)), c = Ve(t.min, Math.round((a + d + f * Math.pow(10, o)) * s) / s); for (; c < n;)i.push({ value: c, major: Yd(c), significand: f }), f >= 10 ? f = f < 15 ? 15 : 20 : f++, f >= 20 && (o++, f = 2, s = o >= 0 ? 1 : s), c = Math.round((a + d + f * Math.pow(10, o)) * s) / s; const h = Ve(t.max, c); return i.push({ value: h, major: Yd(h), significand: f }), i } class Kd extends _i { constructor(e) { super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0 } parse(e, n) { const i = as.prototype.parse.apply(this, [e, n]); if (i === 0) { this._zero = !0; return } return he(i) && i > 0 ? i : null } determineDataLimits() { const { min: e, max: n } = this.getMinMax(!0); this.min = he(e) ? Math.max(0, e) : null, this.max = he(n) ? Math.max(0, n) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !he(this._userMin) && (this.min = e === gn(this.min, 0) ? gn(this.min, -1) : gn(this.min, 0)), this.handleTickRangeOptions() } handleTickRangeOptions() { const { minDefined: e, maxDefined: n } = this.getUserBounds(); let i = this.min, r = this.max; const o = l => i = e ? i : l, s = l => r = n ? r : l; i === r && (i <= 0 ? (o(1), s(10)) : (o(gn(i, -1)), s(gn(r, 1)))), i <= 0 && o(gn(r, -1)), r <= 0 && s(gn(i, 1)), this.min = i, this.max = r } buildTicks() { const e = this.options, n = { min: this._userMin, max: this._userMax }, i = xx(n, this); return e.bounds === "ticks" && jp(i, this, "value"), e.reverse ? (i.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), i } getLabelForValue(e) { return e === void 0 ? "0" : Cu(e, this.chart.options.locale, this.options.ticks.format) } configure() { const e = this.min; super.configure(), this._startValue = Xt(e), this._valueRange = Xt(this.max) - Xt(e) } getPixelForValue(e) { return (e === void 0 || e === 0) && (e = this.min), e === null || isNaN(e) ? NaN : this.getPixelForDecimal(e === this.min ? 0 : (Xt(e) - this._startValue) / this._valueRange) } getValueForPixel(e) { const n = this.getDecimalForPixel(e); return Math.pow(10, this._startValue + n * this._valueRange) } } z(Kd, "id", "logarithmic"), z(Kd, "defaults", { ticks: { callback: Cs.formatters.logarithmic, major: { enabled: !0 } } }); function wa(t) { const e = t.ticks; if (e.display && t.display) { const n = Te(e.backdropPadding); return U(e.font && e.font.size, se.font.size) + n.height } return 0 } function _x(t, e, n) { return n = oe(n) ? n : [n], { w: ey(t, e.string, n), h: n.length * e.lineHeight } } function Gd(t, e, n, i, r) { return t === i || t === r ? { start: e - n / 2, end: e + n / 2 } : t < i || t > r ? { start: e - n, end: e } : { start: e, end: e + n } } function wx(t) { const e = { l: t.left + t._padding.left, r: t.right - t._padding.right, t: t.top + t._padding.top, b: t.bottom - t._padding.bottom }, n = Object.assign({}, e), i = [], r = [], o = t._pointLabels.length, s = t.options.pointLabels, l = s.centerPointLabels ? we / o : 0; for (let a = 0; a < o; a++) { const u = s.setContext(t.getPointLabelContext(a)); r[a] = u.padding; const d = t.getPointPosition(a, t.drawingArea + r[a], l), f = ve(u.font), c = _x(t.ctx, f, t._pointLabels[a]); i[a] = c; const h = yt(t.getIndexAngle(a) + l), g = Math.round(Su(h)), v = Gd(g, d.x, c.w, 0, 180), _ = Gd(g, d.y, c.h, 90, 270); kx(n, e, h, v, _) } t.setCenterPoint(e.l - n.l, n.r - e.r, e.t - n.t, n.b - e.b), t._pointLabelItems = Ex(t, i, r) } function kx(t, e, n, i, r) { const o = Math.abs(Math.sin(n)), s = Math.abs(Math.cos(n)); let l = 0, a = 0; i.start < e.l ? (l = (e.l - i.start) / o, t.l = Math.min(t.l, e.l - l)) : i.end > e.r && (l = (i.end - e.r) / o, t.r = Math.max(t.r, e.r + l)), r.start < e.t ? (a = (e.t - r.start) / s, t.t = Math.min(t.t, e.t - a)) : r.end > e.b && (a = (r.end - e.b) / s, t.b = Math.max(t.b, e.b + a)) } function bx(t, e, n) { const i = t.drawingArea, { extra: r, additionalAngle: o, padding: s, size: l } = n, a = t.getPointPosition(e, i + r + s, o), u = Math.round(Su(yt(a.angle + ue))), d = Ox(a.y, l.h, u), f = Cx(u), c = Px(a.x, l.w, f); return { visible: !0, x: a.x, y: d, textAlign: f, left: c, top: d, right: c + l.w, bottom: d + l.h } } function Sx(t, e) { if (!e) return !0; const { left: n, top: i, right: r, bottom: o } = t; return !(qn({ x: n, y: i }, e) || qn({ x: n, y: o }, e) || qn({ x: r, y: i }, e) || qn({ x: r, y: o }, e)) } function Ex(t, e, n) { const i = [], r = t._pointLabels.length, o = t.options, { centerPointLabels: s, display: l } = o.pointLabels, a = { extra: wa(o) / 2, additionalAngle: s ? we / r : 0 }; let u; for (let d = 0; d < r; d++) { a.padding = n[d], a.size = e[d]; const f = bx(t, d, a); i.push(f), l === "auto" && (f.visible = Sx(f, u), f.visible && (u = f)) } return i } function Cx(t) { return t === 0 || t === 180 ? "center" : t < 180 ? "left" : "right" } function Px(t, e, n) { return n === "right" ? t -= e : n === "center" && (t -= e / 2), t } function Ox(t, e, n) { return n === 90 || n === 270 ? t -= e / 2 : (n > 270 || n < 90) && (t -= e), t } function Mx(t, e, n) { const { left: i, top: r, right: o, bottom: s } = n, { backdropColor: l } = e; if (!te(l)) { const a = si(e.borderRadius), u = Te(e.backdropPadding); t.fillStyle = l; const d = i - u.left, f = r - u.top, c = o - i + u.width, h = s - r + u.height; Object.values(a).some(g => g !== 0) ? (t.beginPath(), rs(t, { x: d, y: f, w: c, h, radius: a }), t.fill()) : t.fillRect(d, f, c, h) } } function Tx(t, e) { const { ctx: n, options: { pointLabels: i } } = t; for (let r = e - 1; r >= 0; r--) { const o = t._pointLabelItems[r]; if (!o.visible) continue; const s = i.setContext(t.getPointLabelContext(r)); Mx(n, s, o); const l = ve(s.font), { x: a, y: u, textAlign: d } = o; gi(n, t._pointLabels[r], a, u + l.lineHeight / 2, l, { color: s.color, textAlign: d, textBaseline: "middle" }) } } function ug(t, e, n, i) { const { ctx: r } = t; if (n) r.arc(t.xCenter, t.yCenter, e, 0, xe); else { let o = t.getPointPosition(0, e); r.moveTo(o.x, o.y); for (let s = 1; s < i; s++)o = t.getPointPosition(s, e), r.lineTo(o.x, o.y) } } function Rx(t, e, n, i, r) { const o = t.ctx, s = e.circular, { color: l, lineWidth: a } = e; !s && !i || !l || !a || n < 0 || (o.save(), o.strokeStyle = l, o.lineWidth = a, o.setLineDash(r.dash), o.lineDashOffset = r.dashOffset, o.beginPath(), ug(t, n, s, i), o.closePath(), o.stroke(), o.restore()) } function Ax(t, e, n) { return Nn(t, { label: n, index: e, type: "pointLabel" }) } class lo extends as { constructor(e) { super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [] } setDimensions() { const e = this._padding = Te(wa(this.options) / 2), n = this.width = this.maxWidth - e.width, i = this.height = this.maxHeight - e.height; this.xCenter = Math.floor(this.left + n / 2 + e.left), this.yCenter = Math.floor(this.top + i / 2 + e.top), this.drawingArea = Math.floor(Math.min(n, i) / 2) } determineDataLimits() { const { min: e, max: n } = this.getMinMax(!1); this.min = he(e) && !isNaN(e) ? e : 0, this.max = he(n) && !isNaN(n) ? n : 0, this.handleTickRangeOptions() } computeTickLimit() { return Math.ceil(this.drawingArea / wa(this.options)) } generateTickLabels(e) { as.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map((n, i) => { const r = K(this.options.pointLabels.callback, [n, i], this); return r || r === 0 ? r : "" }).filter((n, i) => this.chart.getDataVisibility(i)) } fit() { const e = this.options; e.display && e.pointLabels.display ? wx(this) : this.setCenterPoint(0, 0, 0, 0) } setCenterPoint(e, n, i, r) { this.xCenter += Math.floor((e - n) / 2), this.yCenter += Math.floor((i - r) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, n, i, r)) } getIndexAngle(e) { const n = xe / (this._pointLabels.length || 1), i = this.options.startAngle || 0; return yt(e * n + Yt(i)) } getDistanceFromCenterForValue(e) { if (te(e)) return NaN; const n = this.drawingArea / (this.max - this.min); return this.options.reverse ? (this.max - e) * n : (e - this.min) * n } getValueForDistanceFromCenter(e) { if (te(e)) return NaN; const n = e / (this.drawingArea / (this.max - this.min)); return this.options.reverse ? this.max - n : this.min + n } getPointLabelContext(e) { const n = this._pointLabels || []; if (e >= 0 && e < n.length) { const i = n[e]; return Ax(this.getContext(), e, i) } } getPointPosition(e, n, i = 0) { const r = this.getIndexAngle(e) - ue + i; return { x: Math.cos(r) * n + this.xCenter, y: Math.sin(r) * n + this.yCenter, angle: r } } getPointPositionForValue(e, n) { return this.getPointPosition(e, this.getDistanceFromCenterForValue(n)) } getBasePosition(e) { return this.getPointPositionForValue(e || 0, this.getBaseValue()) } getPointLabelPosition(e) { const { left: n, top: i, right: r, bottom: o } = this._pointLabelItems[e]; return { left: n, top: i, right: r, bottom: o } } drawBackground() { const { backgroundColor: e, grid: { circular: n } } = this.options; if (e) { const i = this.ctx; i.save(), i.beginPath(), ug(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length), i.closePath(), i.fillStyle = e, i.fill(), i.restore() } } drawGrid() { const e = this.ctx, n = this.options, { angleLines: i, grid: r, border: o } = n, s = this._pointLabels.length; let l, a, u; if (n.pointLabels.display && Tx(this, s), r.display && this.ticks.forEach((d, f) => { if (f !== 0) { a = this.getDistanceFromCenterForValue(d.value); const c = this.getContext(f), h = r.setContext(c), g = o.setContext(c); Rx(this, h, a, s, g) } }), i.display) { for (e.save(), l = s - 1; l >= 0; l--) { const d = i.setContext(this.getPointLabelContext(l)), { color: f, lineWidth: c } = d; !c || !f || (e.lineWidth = c, e.strokeStyle = f, e.setLineDash(d.borderDash), e.lineDashOffset = d.borderDashOffset, a = this.getDistanceFromCenterForValue(n.ticks.reverse ? this.min : this.max), u = this.getPointPosition(l, a), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(u.x, u.y), e.stroke()) } e.restore() } } drawBorder() { } drawLabels() { const e = this.ctx, n = this.options, i = n.ticks; if (!i.display) return; const r = this.getIndexAngle(0); let o, s; e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(r), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach((l, a) => { if (a === 0 && !n.reverse) return; const u = i.setContext(this.getContext(a)), d = ve(u.font); if (o = this.getDistanceFromCenterForValue(this.ticks[a].value), u.showLabelBackdrop) { e.font = d.string, s = e.measureText(l.label).width, e.fillStyle = u.backdropColor; const f = Te(u.backdropPadding); e.fillRect(-s / 2 - f.left, -o - d.size / 2 - f.top, s + f.width, d.size + f.height) } gi(e, l.label, 0, -o, d, { color: u.color }) }), e.restore() } drawTitle() { } } z(lo, "id", "radialLinear"), z(lo, "defaults", { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: !1 }, startAngle: 0, ticks: { showLabelBackdrop: !0, callback: Cs.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: !0, font: { size: 10 }, callback(e) { return e }, padding: 5, centerPointLabels: !1 } }), z(lo, "defaultRoutes", { "angleLines.color": "borderColor", "pointLabels.color": "color", "ticks.color": "color" }), z(lo, "descriptors", { angleLines: { _fallback: "grid" } }); const Os = { millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 } }, De = Object.keys(Os); function jx(t, e) { return t - e } function Zd(t, e) { if (te(e)) return null; const n = t._adapter, { parser: i, round: r, isoWeekday: o } = t._parseOpts; let s = e; return typeof i == "function" && (s = i(s)), he(s) || (s = typeof i == "string" ? n.parse(s, i) : n.parse(s)), s === null ? null : (r && (s = r === "week" && (ns(o) || o === !0) ? n.startOf(s, "isoWeek", o) : n.startOf(s, r)), +s) } function qd(t, e, n, i) { const r = De.length; for (let o = De.indexOf(t); o < r - 1; ++o) { const s = Os[De[o]], l = s.steps ? s.steps : Number.MAX_SAFE_INTEGER; if (s.common && Math.ceil((n - e) / (l * s.size)) <= i) return De[o] } return De[r - 1] } function Lx(t, e, n, i, r) { for (let o = De.length - 1; o >= De.indexOf(n); o--) { const s = De[o]; if (Os[s].common && t._adapter.diff(r, i, s) >= e - 1) return s } return De[n ? De.indexOf(n) : 0] } function Dx(t) { for (let e = De.indexOf(t) + 1, n = De.length; e < n; ++e)if (Os[De[e]].common) return De[e] } function Jd(t, e, n) { if (!n) t[e] = !0; else if (n.length) { const { lo: i, hi: r } = Eu(n, e), o = n[i] >= e ? n[i] : n[r]; t[o] = !0 } } function Nx(t, e, n, i) { const r = t._adapter, o = +r.startOf(e[0].value, i), s = e[e.length - 1].value; let l, a; for (l = o; l <= s; l = +r.add(l, 1, i))a = n[l], a >= 0 && (e[a].major = !0); return e } function ef(t, e, n) { const i = [], r = {}, o = e.length; let s, l; for (s = 0; s < o; ++s)l = e[s], r[l] = s, i.push({ value: l, major: !1 }); return o === 0 || !n ? i : Nx(t, i, r, n) } class us extends _i { constructor(e) { super(e), this._cache = { data: [], labels: [], all: [] }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0 } init(e, n = {}) { const i = e.time || (e.time = {}), r = this._adapter = new Wy._date(e.adapters.date); r.init(n), Ji(i.displayFormats, r.formats()), this._parseOpts = { parser: i.parser, round: i.round, isoWeekday: i.isoWeekday }, super.init(e), this._normalized = n.normalized } parse(e, n) { return e === void 0 ? null : Zd(this, e) } beforeLayout() { super.beforeLayout(), this._cache = { data: [], labels: [], all: [] } } determineDataLimits() { const e = this.options, n = this._adapter, i = e.time.unit || "day"; let { min: r, max: o, minDefined: s, maxDefined: l } = this.getUserBounds(); function a(u) { !s && !isNaN(u.min) && (r = Math.min(r, u.min)), !l && !isNaN(u.max) && (o = Math.max(o, u.max)) } (!s || !l) && (a(this._getLabelBounds()), (e.bounds !== "ticks" || e.ticks.source !== "labels") && a(this.getMinMax(!1))), r = he(r) && !isNaN(r) ? r : +n.startOf(Date.now(), i), o = he(o) && !isNaN(o) ? o : +n.endOf(Date.now(), i) + 1, this.min = Math.min(r, o - 1), this.max = Math.max(r + 1, o) } _getLabelBounds() { const e = this.getLabelTimestamps(); let n = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY; return e.length && (n = e[0], i = e[e.length - 1]), { min: n, max: i } } buildTicks() { const e = this.options, n = e.time, i = e.ticks, r = i.source === "labels" ? this.getLabelTimestamps() : this._generate(); e.bounds === "ticks" && r.length && (this.min = this._userMin || r[0], this.max = this._userMax || r[r.length - 1]); const o = this.min, s = this.max, l = Bv(r, o, s); return this._unit = n.unit || (i.autoSkip ? qd(n.minUnit, this.min, this.max, this._getLabelCapacity(o)) : Lx(this, l.length, n.minUnit, this.min, this.max)), this._majorUnit = !i.major.enabled || this._unit === "year" ? void 0 : Dx(this._unit), this.initOffsets(r), e.reverse && l.reverse(), ef(this, l, this._majorUnit) } afterAutoSkip() { this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(e => +e.value)) } initOffsets(e = []) { let n = 0, i = 0, r, o; this.options.offset && e.length && (r = this.getDecimalForValue(e[0]), e.length === 1 ? n = 1 - r : n = (this.getDecimalForValue(e[1]) - r) / 2, o = this.getDecimalForValue(e[e.length - 1]), e.length === 1 ? i = o : i = (o - this.getDecimalForValue(e[e.length - 2])) / 2); const s = e.length < 3 ? .5 : .25; n = tt(n, 0, s), i = tt(i, 0, s), this._offsets = { start: n, end: i, factor: 1 / (n + 1 + i) } } _generate() { const e = this._adapter, n = this.min, i = this.max, r = this.options, o = r.time, s = o.unit || qd(o.minUnit, n, i, this._getLabelCapacity(n)), l = U(r.ticks.stepSize, 1), a = s === "week" ? o.isoWeekday : !1, u = ns(a) || a === !0, d = {}; let f = n, c, h; if (u && (f = +e.startOf(f, "isoWeek", a)), f = +e.startOf(f, u ? "day" : s), e.diff(i, n, s) > 1e5 * l) throw new Error(n + " and " + i + " are too far apart with stepSize of " + l + " " + s); const g = r.ticks.source === "data" && this.getDataTimestamps(); for (c = f, h = 0; c < i; c = +e.add(c, l, s), h++)Jd(d, c, g); return (c === i || r.bounds === "ticks" || h === 1) && Jd(d, c, g), Object.keys(d).sort((v, _) => v - _).map(v => +v) } getLabelForValue(e) { const n = this._adapter, i = this.options.time; return i.tooltipFormat ? n.format(e, i.tooltipFormat) : n.format(e, i.displayFormats.datetime) } format(e, n) { const r = this.options.time.displayFormats, o = this._unit, s = n || r[o]; return this._adapter.format(e, s) } _tickFormatFunction(e, n, i, r) { const o = this.options, s = o.ticks.callback; if (s) return K(s, [e, n, i], this); const l = o.time.displayFormats, a = this._unit, u = this._majorUnit, d = a && l[a], f = u && l[u], c = i[n], h = u && f && c && c.major; return this._adapter.format(e, r || (h ? f : d)) } generateTickLabels(e) { let n, i, r; for (n = 0, i = e.length; n < i; ++n)r = e[n], r.label = this._tickFormatFunction(r.value, n, e) } getDecimalForValue(e) { return e === null ? NaN : (e - this.min) / (this.max - this.min) } getPixelForValue(e) { const n = this._offsets, i = this.getDecimalForValue(e); return this.getPixelForDecimal((n.start + i) * n.factor) } getValueForPixel(e) { const n = this._offsets, i = this.getDecimalForPixel(e) / n.factor - n.end; return this.min + i * (this.max - this.min) } _getLabelSize(e) { const n = this.options.ticks, i = this.ctx.measureText(e).width, r = Yt(this.isHorizontal() ? n.maxRotation : n.minRotation), o = Math.cos(r), s = Math.sin(r), l = this._resolveTickFontOptions(0).size; return { w: i * o + l * s, h: i * s + l * o } } _getLabelCapacity(e) { const n = this.options.time, i = n.displayFormats, r = i[n.unit] || i.millisecond, o = this._tickFormatFunction(e, 0, ef(this, [e], this._majorUnit), r), s = this._getLabelSize(o), l = Math.floor(this.isHorizontal() ? this.width / s.w : this.height / s.h) - 1; return l > 0 ? l : 1 } getDataTimestamps() { let e = this._cache.data || [], n, i; if (e.length) return e; const r = this.getMatchingVisibleMetas(); if (this._normalized && r.length) return this._cache.data = r[0].controller.getAllParsedValues(this); for (n = 0, i = r.length; n < i; ++n)e = e.concat(r[n].controller.getAllParsedValues(this)); return this._cache.data = this.normalize(e) } getLabelTimestamps() { const e = this._cache.labels || []; let n, i; if (e.length) return e; const r = this.getLabels(); for (n = 0, i = r.length; n < i; ++n)e.push(Zd(this, r[n])); return this._cache.labels = this._normalized ? e : this.normalize(e) } normalize(e) { return Wv(e.sort(jx)) } } z(us, "id", "time"), z(us, "defaults", { bounds: "data", adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", callback: !1, major: { enabled: !1 } } }); function ao(t, e, n) { let i = 0, r = t.length - 1, o, s, l, a; n ? (e >= t[i].pos && e <= t[r].pos && ({ lo: i, hi: r } = ma(t, "pos", e)), { pos: o, time: l } = t[i], { pos: s, time: a } = t[r]) : (e >= t[i].time && e <= t[r].time && ({ lo: i, hi: r } = ma(t, "time", e)), { time: o, pos: l } = t[i], { time: s, pos: a } = t[r]); const u = s - o; return u ? l + (a - l) * (e - o) / u : l } class tf extends us { constructor(e) { super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0 } initOffsets() { const e = this._getTimestampsForTable(), n = this._table = this.buildLookupTable(e); this._minPos = ao(n, this.min), this._tableRange = ao(n, this.max) - this._minPos, super.initOffsets(e) } buildLookupTable(e) { const { min: n, max: i } = this, r = [], o = []; let s, l, a, u, d; for (s = 0, l = e.length; s < l; ++s)u = e[s], u >= n && u <= i && r.push(u); if (r.length < 2) return [{ time: n, pos: 0 }, { time: i, pos: 1 }]; for (s = 0, l = r.length; s < l; ++s)d = r[s + 1], a = r[s - 1], u = r[s], Math.round((d + a) / 2) !== u && o.push({ time: u, pos: s / (l - 1) }); return o } _getTimestampsForTable() { let e = this._cache.all || []; if (e.length) return e; const n = this.getDataTimestamps(), i = this.getLabelTimestamps(); return n.length && i.length ? e = this.normalize(n.concat(i)) : e = n.length ? n : i, e = this._cache.all = e, e } getDecimalForValue(e) { return (ao(this._table, e) - this._minPos) / this._tableRange } getValueForPixel(e) { const n = this._offsets, i = this.getDecimalForPixel(e) / n.factor - n.end; return ao(this._table, i * this._tableRange + this._minPos, !0) } } z(tf, "id", "timeseries"), z(tf, "defaults", us.defaults); Bt.register(Wi, mx, ax);/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */var ka = function (t, e) { return ka = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var r in i) i.hasOwnProperty(r) && (n[r] = i[r]) }, ka(t, e) }; function zx(t, e) { ka(t, e); function n() { this.constructor = t } t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n) } var Ix = 100, Fx = 100, nf = 50, ba = 50, Sa = 50; function rf(t) { var e = t.className, n = t.counterClockwise, i = t.dashRatio, r = t.pathRadius, o = t.strokeWidth, s = t.style; return Oe.createElement("path", { className: e, style: Object.assign({}, s, Hx({ pathRadius: r, dashRatio: i, counterClockwise: n })), d: Bx({ pathRadius: r, counterClockwise: n }), strokeWidth: o, fillOpacity: 0 }) } function Bx(t) {
  var e = t.pathRadius, n = t.counterClockwise, i = e, r = n ? 1 : 0; return `
      M `+ ba + "," + Sa + `
      m 0,-`+ i + `
      a `+ i + "," + i + " " + r + " 1 1 0," + 2 * i + `
      a `+ i + "," + i + " " + r + " 1 1 0,-" + 2 * i + `
    `} function Hx(t) { var e = t.counterClockwise, n = t.dashRatio, i = t.pathRadius, r = Math.PI * 2 * i, o = (1 - n) * r; return { strokeDasharray: r + "px " + r + "px", strokeDashoffset: (e ? -o : o) + "px" } } (function (t) { zx(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.prototype.getBackgroundPadding = function () { return this.props.background ? this.props.backgroundPadding : 0 }, e.prototype.getPathRadius = function () { return nf - this.props.strokeWidth / 2 - this.getBackgroundPadding() }, e.prototype.getPathRatio = function () { var n = this.props, i = n.value, r = n.minValue, o = n.maxValue, s = Math.min(Math.max(i, r), o); return (s - r) / (o - r) }, e.prototype.render = function () { var n = this.props, i = n.circleRatio, r = n.className, o = n.classes, s = n.counterClockwise, l = n.styles, a = n.strokeWidth, u = n.text, d = this.getPathRadius(), f = this.getPathRatio(); return Oe.createElement("svg", { className: o.root + " " + r, style: l.root, viewBox: "0 0 " + Ix + " " + Fx, "data-test-id": "CircularProgressbar" }, this.props.background ? Oe.createElement("circle", { className: o.background, style: l.background, cx: ba, cy: Sa, r: nf }) : null, Oe.createElement(rf, { className: o.trail, counterClockwise: s, dashRatio: i, pathRadius: d, strokeWidth: a, style: l.trail }), Oe.createElement(rf, { className: o.path, counterClockwise: s, dashRatio: f * i, pathRadius: d, strokeWidth: a, style: l.path }), u ? Oe.createElement("text", { className: o.text, style: l.text, x: ba, y: Sa }, u) : null) }, e.defaultProps = { background: !1, backgroundPadding: 0, circleRatio: 1, classes: { root: "CircularProgressbar", trail: "CircularProgressbar-trail", path: "CircularProgressbar-path", text: "CircularProgressbar-text", background: "CircularProgressbar-background" }, counterClockwise: !1, className: "", maxValue: 100, minValue: 0, strokeWidth: 8, styles: { root: {}, trail: {}, path: {}, text: {}, background: {} }, text: "" }, e })(Oe.Component); const Wx = () => E.jsxs("div", { id: "tokenomics", className: "tokenomics token_bg parallax_bg", children: [E.jsx("div", { className: "overlay" }), E.jsxs("div", { className: "toke_wrap", children: [E.jsxs("div", { className: "token_heading", children: [E.jsx(Mr, { duration: 1e3, delay: 800, children: E.jsx("div", {}) }), E.jsx(Or, { top: !0, duration: 800, delay: 800, children: E.jsx("h1", { children: "Tokenomics" }) })] }), E.jsxs("div", { className: "address", children: [E.jsx("p", { children: E.jsx("b", { children: "Official Contract : " }) }), E.jsx("p", { children: E.jsx("b", { children: "0xf5f9b538cbe8af7bd9be81d21795974435478127" }) })] }), E.jsxs("div", { className: "token_details", children: [E.jsx("div", { className: "token_chart", children: E.jsxs(me, { top: !0, duration: 800, delay: 800, children: [E.jsx("h2", { children: "Supply" }), E.jsx("h2", { children: "4,200,000,000,000" })] }) }), E.jsx("div", { className: "token_models", children: E.jsx($0, { duration: 900, delay: 500, children: E.jsx("div", { children: E.jsx("h2", { children: "1% Tax" }) }) }) })] })] })] }); function Vx() { return E.jsx("div", { id: "roadmap", className: "roadmap roadmap_bg parallax_bg", style: { background: "#61ce70" }, children: E.jsxs("div", { className: "container", children: [E.jsxs("div", { className: "token_heading", children: [E.jsx(Mr, { duration: 1e3, delay: 800, children: E.jsx("div", {}) }), E.jsx(Or, { top: !0, duration: 800, delay: 800, children: E.jsx("h1", { children: "Roadmap" }) })] }), E.jsxs("div", { className: "roadmap-image", children: [E.jsx("div", { className: "roadmap-bg" }), E.jsx("div", { className: "pointer-div pointer-div1", children: E.jsxs("div", { className: "right-pointer", children: [E.jsx(me, { top: !0, duration: 800, delay: 100, children: E.jsx("h4", { children: "Phase 1 " }) }), E.jsx(me, { bottom: !0, duration: 800, delay: 120, children: E.jsx("p", { children: E.jsxs("ul", { children: [E.jsx("li", { children: "based event" }), E.jsx("li", { children: "Official launch of AI token" }), E.jsx("li", { children: "CoinGecko and CoinMarketCap listings" }), E.jsx("li", { children: "Achieve 1,000+ holders milestone" }), E.jsx("li", { children: "Utilize our memetic power to get #AI trending on Twitter" })] }) }) })] }) }), E.jsx("div", { className: "pointer-div pointer-div2", children: E.jsxs("div", { className: "right-pointer", children: [E.jsx(me, { top: !0, duration: 800, delay: 100, children: E.jsx("h4", { children: "Phase 2" }) }), E.jsx(me, { bottom: !0, duration: 800, delay: 150, children: E.jsx("p", { children: E.jsxs("ul", { children: [E.jsx("li", { children: "Introduction of AI Launchpad, Vaults, Dapps, TG Bot, and Swap" }), E.jsx("li", { children: "Community partnerships and collaborations" }), E.jsx("li", { children: "Centralized Exchange (CEX) listings" }), E.jsx("li", { children: "Achieve 10,000+ holders milestone" }), E.jsx("li", { children: "Exclusive giveaways to engage and reward the community" })] }) }) })] }) }), E.jsx("div", { className: "pointer-div pointer-div3", children: E.jsxs("div", { className: "right-pointer", children: [E.jsx(me, { top: !0, duration: 800, delay: 100, children: E.jsx("h4", { children: "Phase 3" }) }), E.jsx(me, { bottom: !0, duration: 800, delay: 150, children: E.jsx("p", { children: E.jsxs("ul", { children: [E.jsx("li", { children: "Release of AI merchandise" }), E.jsx("li", { children: "Initiate Pepevations: innovative projects and initiatives powered by AI" }), E.jsx("li", { children: "Tier-1 Exchange listings to increase market reach" }), E.jsx("li", { children: "Expand our community influence with meme takeover campaigns" })] }) }) })] }) })] })] }) }) } const $x = () => E.jsxs("div", { className: "hero heroBg parallax_bg", children: [E.jsx("div", { className: "overlay" }), E.jsx("div", { className: "hero_content container", children: E.jsxs("div", { className: "hc_1", children: [E.jsx(oi, { top: !0, duration: 800, delay: 800, children: E.jsx("h2", { children: "The ultimate crypto meme token platform designed to revolutionize the world of memecoins!" }) }), E.jsx(oi, { bottom: !0, duration: 800, delay: 800, children: E.jsx("p", { children: "Discover AI, the MEMECOIN MAKER! Your one stop shop for Memecoins!" }) })] }) })] }), Ux = () => E.jsx("div", { className: "utility", children: E.jsxs("div", { className: "container", children: [E.jsxs("div", { className: "token_heading", children: [E.jsx(Mr, { duration: 1e3, delay: 800, children: E.jsx("div", {}) }), E.jsx(Or, { top: !0, duration: 800, delay: 800, children: E.jsx("h1", { children: "Utility" }) })] }), E.jsxs("div", { className: "utility_content", children: [E.jsx("div", { className: "uc_main", children: E.jsxs("div", { children: [E.jsx(me, { top: !0, duration: 800, delay: 800, children: E.jsx("h2", { children: "AIPad " }) }), E.jsx(me, { bottom: !0, duration: 800, delay: 800, children: E.jsx("p", { children: "The AI Launchpad simplifies participation in new pepe token offerings. It's designed for both crypto newcomers and seasoned enthusiasts, allowing you to quickly engage with promising pepecoin projects. Start your pepecoin journey with ease and confidence using the AI Launchpad!" }) })] }) }), E.jsx("div", { className: "uc_main", children: E.jsxs("div", { children: [E.jsx(me, { top: !0, duration: 800, delay: 800, children: E.jsx("h2", { children: "AI Contract Creation" }) }), E.jsx(me, { bottom: !0, duration: 800, delay: 800, children: E.jsx("p", { children: "Recognizing the complexities of blockchain contracts, AI offers a Contract Creation utility. This service simplifies the process of generating secure and reliable smart contracts for your project. Our team of experienced blockchain developers works meticulously to create contracts tailored to your specific needs, ensuring they are robust, secure, and optimized for performance. With AI's Contract Creation, you can focus more on your project's growth and less on the technicalities." }) })] }) }), E.jsx("div", { className: "uc_main", children: E.jsxs("div", { children: [E.jsx(me, { top: !0, duration: 800, delay: 800, children: E.jsx("h2", { children: "AI Vaults" }) }), E.jsx(me, { bottom: !0, duration: 800, delay: 800, children: E.jsx("p", { children: "A safe and secure locker for all your pepecoins.With AI Vaults, you can store and manage your tokens with confidence, knowing that they are protected by our state-of-the-art security systems." }) })] }) }), E.jsx("div", { className: "uc_main", children: E.jsxs("div", { children: [E.jsx(me, { top: !0, duration: 800, delay: 800, children: E.jsx("h2", { children: "AI LOGO & Graphic Generation" }) }), E.jsx(me, { bottom: !0, duration: 800, delay: 800, children: E.jsx("p", { children: "Stepping into the future of design, AI introduces AI Logo & Graphic Generation. This service utilizes advanced artificial intelligence technology to automate the creation of unique and visually striking logos and graphics. Whether you're launching a new project or rebranding an existing one, our AI-driven design tool provides high-quality graphics that resonate with your brand's identity and mission." }) })] }) }), E.jsx("div", { className: "uc_main", children: E.jsxs("div", { children: [E.jsx(me, { top: !0, duration: 800, delay: 800, children: E.jsxs("h2", { children: ["AI TG Bot ", E.jsx("br", {}), " (Shill to Earn)"] }) }), E.jsx(me, { bottom: !0, duration: 800, delay: 800, children: E.jsx("p", { children: "Incentive /effort based rewards. The more you shill the more you earn! shill AI and earn AI + eth! Our proprietary tg bot tracks user activity! get monthly payouts. Get ready to shill-and-earn!" }) })] }) })] })] }) }), Xx = "./dexview-eac7c671.png", Yx = "/assets/pinksale-70ef5a1d.png", Qx = () => E.jsxs("div", { className: "partner_wrap", children: [E.jsxs("div", { className: "token_heading", children: [E.jsx(Mr, { duration: 1e3, delay: 800, children: E.jsx("div", {}) }), E.jsx(Or, { top: !0, duration: 800, delay: 800, children: E.jsx("h1", { children: "Partners" }) })] }), E.jsxs("div", { className: "p_img_wrap", children: [E.jsx("a", { href: "https://www.dexview.com/", target: "_blank", rel: "noopener noreferrer", children: E.jsx("img", { src: Xx, alt: "" }) }), E.jsx("a", { href: "", target: "_blank", rel: "noopener noreferrer", children: E.jsx("img", { src: Yx, alt: "" }) })] })] }), Kx = () => E.jsxs("div", { className: "home", children: [E.jsx(nv, {}), E.jsx($x, {}), E.jsx(rv, {}), E.jsx(Mi, {}), E.jsx(Ux, {}), E.jsx(Mi, {}), E.jsx(Wx, {}), E.jsx(Mi, {}), E.jsx(Vx, {}), E.jsx(Mi, { color: "green" }), E.jsx(Qx, {}), E.jsx(Mi, {})] }); const Gx = () => E.jsxs("div", { className: "Loader", children: [E.jsx("img", { src: "https://raw.githubusercontent.com/WebSiteLaunchPad/xerc20/main/logo.png", alt: "" }), E.jsxs("div", { children: [E.jsx("h1", { children: "Loading" }), E.jsx("span", { className: "dot_anim da_anim1", children: "." }), E.jsx("span", { className: "dot_anim da_anim2", children: "." }), E.jsx("span", { className: "dot_anim da_anim3", children: "." })] })] }); function Zx() { const [t, e] = Oe.useState(!0); return Oe.useEffect(() => { setTimeout(() => { e(!1) }, 2e3) }, []), E.jsx(E.Fragment, { children: t ? E.jsx(Gx, {}) : E.jsxs(E.Fragment, { children: [E.jsx(ev, {}), E.jsx(Kx, {}), E.jsx(Z0, {})] }) }) } ul.createRoot(document.getElementById("root")).render(E.jsx(Zx, {}));
